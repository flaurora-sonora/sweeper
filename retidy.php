<?php

define('DS', DIRECTORY_SEPARATOR);
include("DTD.php");
include("OM.php");

class ReTidy {

	// work started: June 2008
	//public static $version = 1.01;
	//public static $version = 2.00;
	//public static $version = 2.04;
	//public static $version = 2.05;
	public static $version = 2.6;
	//public static $build = 20080624;
	//public static $build = 20090824;
	//public static $build = 20120930;
	//public static $build = 20150619;
	public static $build = 20181201;

	// the default profile
	public $config_profile = 'maximum';
	public $config = false;

	// the timers for cleanCode()
	public $timer_start = false;
	public $timer_end = false;
	public $timer_total = false;

	// this is the verbose/debug output
	// use getMessages() to read this value
	protected $messages = '';
	protected $total_changes = '';	

	// the configuration used for cleaning a document is named a profile.
	// when you construct a new ReTidy('whatever') object, the profile is loaded from a file using prefix + whatever + suffix.
	// in this case ../profiles/whatever.php
	//protected $profile_prefix = DS . 'profiles' . DS; // no longer hard-coded here (2012-05-18)
	protected $profile_suffix = '.php';

	// when you configure a profile to use the external htmltidy binary you must have a folder where the PHP script is allowed to save the generated htmltidy configuration file (which is based on your profile configuration)
	protected $htmltidy_config_dir = '/tmp';

	protected $code = false; // use getCode() and setCode($code)
	protected $dom = false;
	protected $xpath = false;
	protected static $xhtmlns = 'http://www.w3.org/1999/xhtml';

	protected static $lang = array(
		'__toString' => 'Sweeper version %1$s build %2$s',
		'loadProfile_done' => 'Sweeper configuration profile has been loaded',
		'loadTemplate_done' => 'Template has been loaded',
		'loadLanguage_done' => 'Language has been loaded',
		'loadWET_done' => 'WET has been loaded',
		'loadDepartment_done' => 'Department has been loaded',		
		'loadProfile_notfound' => 'Profile configuration file was not found: %s',
		'loadTemplate_notfound' => 'Template configuration file was not found: %s',
		'loadLanguage_notfound' => 'Language was not found: %s',
		'loadDepartment_notfound' => 'Department was not found: %s',		
		'loadProfile_error' => 'Profile configuration file did not return an array!',
		'loadTemplate_error' => 'Template configuration file did not return an array!',
		'loadLanguage_error' => 'Language did not return an array!',
		'loadDepartment_error' => 'Department did not return an array!',		
		'cleanCode_noinit' => 'No code, or no configuration found! You cannot run cleanCode() now.',
		'dom_init_error' => 'Fatal error trying to initialize the DOMDocument!',
		'dom_xpath_warning' => 'The XPath DOM interface could not be initialized!',
		'dom_save_error' => 'Cannot save the DOM code: no DOM found!',
	);

	/***********
	 * TO DO:
	 *
	 * - better page
	 * - better documentation
	 * - GUI for uploading a file to be cleaned and picker for profile
	 * - GUI for editing a profile
	 * - more code loops, repeat the cleanup until nothing to do remains
	 * - config option: output body only
	 * - fix the new line duplication in <pre> tags
	 * - in dom_merge_parent_attr do proper merging for the style attribute
	 * - configure htmltidy to generate style attributes instead of CSS classes for the purpose of using the style information to generate headings based on font-size, color and other styling information
	 * - generate headings based on case detection, style information and other information
	 *
	 ***********/

	function __construct($profile = false, $profile_prefix = false) {
		$this->profile_prefix = dirname(__FILE__) . '/' . $profile_prefix;
		$this->loadProfile($profile);
	}

	function __destruct() {
		$this->free_mem();
		if($this->htmltidy_config_file) {
			unlink($this->htmltidy_config_file);
		}
	}

	function __toString() {
		return sprintf(self::$lang['__toString'], self::$version, self::$build);
	}

	function loadProfile($profile = false) {
		if($profile == $this->config_profile && is_array($this->config)) return true;
		if($profile) $this->config_profile = $profile;
		if(!$this->config_profile) return false;
		$config_include = $this->profile_prefix . $this->config_profile . $this->profile_suffix;
		if(!file_exists($config_include)) {
			$this->logMsg(sprintf(self::$lang['loadProfile_notfound'], $config_include));
			return false;
		}
		$this->config = include($config_include);
		if(!is_array($this->config)) {
			$this->config = false;
			$this->logMsg(self::$lang['loadProfile_error']);
			return false;
		}
		$this->logMsg(self::$lang['loadProfile_done'] . ': ' . $this->config_profile);
		return true;
	}

	function setCode($code) {
		$this->code = $code;
	}

	function getCode() {
		return $this->code;
	}
	
	function setFile($file) {
		$this->file = $file;
	}

	function getFile() {
		return $this->file;
	}
	
	function getConfig() {
		return $this->config;
	}	
	
	function setTemplate($template) {
		$this->template = $template;
		$this->logMsg(self::$lang['loadTemplate_done'] . ': ' . $this->template);
	}

	function getTemplate() {
		return $this->template;
	}
	
	function setLanguage($language) {
		$this->language = $language;
		if($this->language === 'unknown') {
			ReTidy::warning(self::$lang['loadLanguage_done'] . ': ' . $this->language);
		} else {
			$this->logMsg(self::$lang['loadLanguage_done'] . ': ' . $this->language);
		}
	}
	
	function setWET($WET) {
		$this->WET = $WET;
		$this->logMsg(self::$lang['loadWET_done'] . ': ' . $this->WET);
	}	

	function getLanguage() {
		return $this->language;
	}
	
	function setDepartment($EngDepAcro) {
		$this->department = $EngDepAcro;
		$this->logMsg(self::$lang['loadDepartment_done'] . ': ' . $this->department);		
	}
	
	function setAcronymPath($acronym_path) {
		$this->abbr_path = $acronym_path;
	}	

	function getDepartment() {
		return $this->department;
	}

	function getAcronymPath() {
		return $this->abbr_path;
	}	

	function getMessages() {
		if(!$this->total_changes) {
			$this->total_changes = 0;
		}
		$this->messages .= "<b>Total changes in this file: " . $this->total_changes . "</b><br>\r\n<br>\r\n";
		return $this->messages;
	}
	
	function getChanges() {
		return $this->total_changes;
	}	

	function free_mem()	{
		$this->code = false;
		$this->template = false;
		$this->language = false;		
		$this->messages = '';
		$this->toc_ids = false;
		// I suppose this should be added to for more memory-friendly code since we have added
		// objects? properties? to our ReTidy object.
	}
	
	function link_titles() {
		$changes_counter = 0;
		// we want to remove link titles from links whose link titles are the same as their link text
		preg_match_all('/<a([^<>]*? href="[^"]*?"[^<>]*?)>(.*?)<\/a>/is', $this->code, $matches);
		//var_dump($matches);
		foreach($matches[0] as $index => $value) {
			$attributes_string = $matches[1][$index];
			$link_text = $matches[2][$index];
			preg_match('/ title="([^"]*?)"/is', $attributes_string, $title_matches);
			if(ReTidy::trim_nbsp($title_matches[1]) === ReTidy::trim_nbsp(ReTidy::tagless($link_text))) { // then remove it
				//var_dump($value);
				$attributes_string = str_replace($title_matches[0], '', $attributes_string);
				$this->code = str_replace($value, '<a' . $attributes_string . '>' . $link_text . '</a>', $this->code, $count);
				$changes_counter += $count;
			}
		}
		$this->logMsgIf('link titles removed', $changes_counter);
		// as well as potentially apply them when it is unclear where the link goes from the context (which is harder to program.
	}
	
	function templateCode_older() {
		// no longer used (2011-10-06)
		if ($this->template !== "none") {
			print('do not use this function 43096809683069836');exit(0);
			$bodycode = ReTidy::getBodyCode();
			if(strpos($bodycode, '<div class="center">') !== false) {
				var_dump(OM::getTagString('abvb<div class="center">adsfds</div>sdsgdsgds', '<div class="center">'));exit(0);
				$bodycode = substr(OM::getTagString($bodycode, '<div class="center">'), strlen('<div class="center">'), strlen($bodycode)-strlen('<div class="center">')-4);
			}
			$this->code = str_replace("{content}", $bodycode, file_get_contents($this->template));
		}
	}
	
	function getContentArrayForTemplating($code, $strip_template_content_comments = false) {
		//print('$code1: ' . htmlentities($code));
		// assume the main <h1> is directly in the content <div>
	//	$inventing_h1 = false;
	//	$h1_strpos = strpos($code, '<h1');
		//print('$h1_strpos: ');var_dump($h1_strpos);
		//print('code}}}<br>');
		//print($code);
		//print('{{{code<br>');
		//exit(0);
		$found_h1 = false;
	//	if($h1_strpos === false) {
			// ideally we would run structure on every file and this problem would go away, but it shouldn't be bad to write a possibly overlapping solution here
			// take a shot; look for what seems like paragraph content then take the first block in its container
			preg_match_all('/<(p|h[1-6])[^<>]*?>(.*?)<\/\1>/is', $code, $possible_heading_matches, PREG_OFFSET_CAPTURE);
			//var_dump($possible_heading_matches);
			foreach($possible_heading_matches[0] as $index => $value) {
				$possible_heading_content = $possible_heading_matches[2][$index][0];
				//var_dump($possible_heading_content);
				/*if(substr_count($possible_heading_content, '.') > 2 || substr_count($paragraph_content, ':') > 0) {
					$paragraph_offset = $possible_heading_matches[0][$index][1];
					$blockArray = OM::getContainingBlock($code, $paragraph_offset);
					//$blockString = $blockArray[0];
					//$offset_contained_string_in_block = $blockArray[1];
					$containing_block_offset = $blockArray[2];
					preg_match('/<(h1|h2|h3|h4|h5|h6|p)[^<>]*?>(.*?)<\/\1>/is', $code, $h1_matches, PREG_OFFSET_CAPTURE, $containing_block_offset);
					$h1_strpos = $h1_matches[0][1];
					$inventing_h1 = true;
					break;
				}*/
				if(ReTidy::isIndexical($possible_heading_content)) {
					//print('possible_heading_content is indexical.<br>');
					//print('$possible_heading_content: ' . $possible_heading_content);
					$h1_strpos = $possible_heading_matches[0][$index][1];
					$h1_including_tag = $possible_heading_matches[0][$index][0];
					$h1_previous_tag_name = $possible_heading_matches[1][$index][0];
					$found_h1 = true;
	//				$inventing_h1 = true;
					break;
				}
			}
	//		if(!$inventing_h1) {
	//			//print($code);
	//			print('h1 not detected or created in getContentArrayForTemplating; this needs to be fixed.');exit(0);
	//		}
	//	}
		$get_content_more_crudely = true;
		if(strpos($code, '<div') === false) {
			//print('here347459475948759<br>');
		} else {
			//print('here347459475948760<br>');
			if($found_h1) {
				// we assume the code is syntactically sound for this...
				preg_match_all('/<div/is', substr($code, 0, $h1_strpos), $open_div_matches, PREG_OFFSET_CAPTURE);
				preg_match_all('/<\/div>/is', substr($code, 0, $h1_strpos), $close_div_matches, PREG_OFFSET_CAPTURE);
				//print('$open_div_matches: ');var_dump($open_div_matches);
				$counter1 = sizeof($open_div_matches[0]) - 1;
				$counter2 = sizeof($close_div_matches[0]) - 1;
				$found_content_div = false;
				//print('here183945606067<br>');
				if(sizeof($open_div_matches) > 0) {
					while($counter1 > -1) {
						//print('here183945606068<br>');
						$strpos_open_div = $open_div_matches[0][$counter1][1];
						while($counter2 > -1) {
							//print('here183945606069<br>');
							$strpos_close_div = $close_div_matches[0][$counter2][1];
							$counter2--;
							if($strpos_close_div > $strpos_open_div) {
								$counter1--;
								continue 2;
							} else {
								$strpos_content_div = $strpos_open_div;
								$found_content_div = true;
								break 2;
							}
						}
						$counter1--;
					}
				}
			}
			if(!$found_content_div) {
				//print('here347459475948761<br>');
			} else {
				//print('here347459475948762<br>');
				//$strpos_content_div = ReTidy::strpos_last(substr($code, 0, $h1_strpos), '<div');
				$content_div_code = OM::getOString($code, '<div', '</div>', $strpos_content_div);
				//print('$content_div_code: ');var_dump($content_div_code);
				$strlen_opening_content_div = strpos($content_div_code, '>') + 1;
				$content = substr($content_div_code, $strlen_opening_content_div, strlen($content_div_code) - $strlen_opening_content_div - 6);
				/*print('XXX9o9beep39o9XXX
');
				print('$content (div-wise): ' . $content);
				print('
XXX9o9beep49o9XXX
				');*/
				$content_offset = $strpos_content_div + $strlen_opening_content_div;
				$get_content_more_crudely = false;
			}
		}
		if($get_content_more_crudely) {
			//print('here347459475948763<br>');
			$body = OM::getOString($code, '<body', '</body>');
			if(strlen($body) === 0) {
				//print('here347459475948764<br>');
				//if($h1_strpos === false) {
				if(!$found_h1) {
					//return $code; // we return the unchanged code
					//ReTidy::fatal_error('did not find the &lt;body&gt; of the document or it has zero length');exit(0);
					$strpos_last_meta = ReTidy::strpos_last($code, '<meta');
					$content_offset = $strpos_last_meta + strpos($code, '>', $strpos_last_meta);
					$content = substr($code, $content_offset);
				} else {
					$content_offset = $h1_strpos;
					$content = substr($code, $h1_strpos);
				}
			} else {
				//print('here347459475948765<br>');
				$body_offset = strpos($code, '<body');
				preg_match('/<body[^<>]*?>/is', $body, $opening_body_tag_matches, PREG_OFFSET_CAPTURE);
				$opening_body_tag = $opening_body_tag_matches[0][0];
				$strlen_opening_body_tag = strlen($opening_body_tag);
				$content = substr($body, $strlen_opening_body_tag, strlen($body) - $strlen_opening_body_tag - 7);
				$content_offset = $body_offset + $opening_body_tag_matches[0][1] + $strlen_opening_body_tag;
				//$cleaned_content = $content;
			}
		}
		/*
		// content; in this generalized templater order, attempts at grabbing the content are from the more specific to the more general
		$opening_content_div = '<div id="cn-centre-col-inner">';
		$strpos_content_div = strpos($code, $opening_content_div);
		if($strpos_content_div !== false) {
			$content_div_code = OM::getOString($code, '<div', '</div>', $strpos_content_div);
			$strlen_opening_content_div = strlen($opening_content_div);
			$content = substr($content_div_code, $strlen_opening_content_div, strlen($content_div_code) - $strlen_opening_content_div - 6);
			$content_offset = $strpos_content_div + $strlen_opening_content_div;
			//print($content);exit(0);
			// call the end of content comment comment part of the content container rather than the content itself...
			// treating the open and close differently and possibly leaving us open to future problems...
			//$pos_close_content_comment = strpos($content, '<!-- clf2-nsi2 theme ends / Fin du thème clf2-nsi2 -->');
			//if($pos_close_content_comment !== false) {
			//	$content = substr($content, 0, $pos_close_content_comment);
			//}
			//print($content);exit(0);
			if($strip_template_content_comments) {
				// remove template comments from the beginning of the content
				$cleaned_content = $content;
				$cleaned_content = str_replace('<!-- Content title begins / Début du titre du contenu -->', '', $cleaned_content);
				$cleaned_content = str_replace('<!-- Content Title ends / Fin du titre du contenu -->', '', $cleaned_content);
				$cleaned_content = str_replace('<!-- clf2-nsi2 theme begins / Début du thème clf2-nsi2 -->', '', $cleaned_content);
				// remove template comments from the end of the content?
				$cleaned_content = str_replace('<!-- clf2-nsi2 theme ends / Fin du thème clf2-nsi2 -->', '', $cleaned_content);
			}
		} else {
			$opening_content_div = '<div class="center">';
			$strpos_content_div = strpos($code, $opening_content_div);
			if($strpos_content_div !== false) {
				$content_div_code = OM::getOString($code, '<div', '</div>', $strpos_content_div);
				$strlen_opening_content_div = strlen($opening_content_div);
				$content = substr($content_div_code, $strlen_opening_content_div, strlen($content_div_code) - $strlen_opening_content_div - 6);
				$content_offset = $strpos_content_div + $strlen_opening_content_div;
				if($strip_template_content_comments) {
					// remove template comments from the beginning of the content
					$cleaned_content = $content;
					$cleaned_content = str_replace('<!-- CONTENT TITLE BEGINS | DEBUT DU TITRE DU CONTENU -->', '', $cleaned_content);
					$cleaned_content = str_replace('<!-- CONTENT TITLE ENDS | FIN DU TITRE DU CONTENU -->', '', $cleaned_content);
				}
			} else {
				$body = OM::getOString($code, '<body', '</body>');
				if(strlen($body) === 0) {
					//return $code; // we return the unchanged code
					ReTidy::fatal_error('did not find the &lt;body&gt; of the document or it has zero length');exit(0);
				} else {
					preg_match('/<body[^<>]*?>/is', $body, $opening_body_tag_matches, PREG_OFFSET_CAPTURE);
					$opening_body_tag = $opening_body_tag_matches[0][0];
					$strlen_opening_body_tag = strlen($opening_body_tag);
					$content = substr($body, $strlen_opening_body_tag, strlen($body) - $strlen_opening_body_tag - 7);
					$content_offset = $opening_body_tag_matches[0][1] + $strlen_opening_body_tag;
					$cleaned_content = $content;
				}
			}
		}*/
		// force every document to have an h1 and force the h1 to be at the start of the content
		//print('$h1_including_tag1: ' . $h1_including_tag);
		//print('$h1_previous_tag_name: ');var_dump($h1_previous_tag_name);
		//print('content_in_templating1: ' . $content);
		if(!$found_h1) {
			$h1_including_tag = '<h1>Dummy h1</h1>';
			$added_h1_length = strlen($h1_including_tag);
			$h1_previous_tag_name = 'h1';
			//$h1_strpos = $content_offset + 4;
		} else {
			$added_h1_length = 0;
			// cutting the h1 out
			//$content = substr($content, 0, $h1_strpos) . substr($content, $h1_strpos + strlen($h1_including_tag));
			//$content = substr($code, $content_offset, $h1_strpos) . substr($code, $h1_strpos + strlen($h1_including_tag), strlen($code) - $content_offset - ($h1_strpos + strlen($h1_including_tag)) - strlen(substr($code, $content_offset + strlen($content))));
			//$content = substr($code, $content_offset, $h1_strpos) . substr($code, $h1_strpos + strlen($h1_including_tag));
			$length_of_after_content = strlen($code) - $content_offset - strlen($content);
			$length_of_after_h1_including_tag = strlen($code) - ($h1_strpos + strlen($h1_including_tag));
			//print('after_content: ' . substr($code, $content_offset + strlen($content)));
			//print('after_h1_including_tag : ' . substr($code, $h1_strpos + strlen($h1_including_tag)));
			//$length_of_after_content = strlen(substr($code, $content_offset + strlen($content)));
			//$length_of_after_h1_including_tag = strlen(substr($code, $h1_strpos + strlen($h1_including_tag)));
			//print('substr($code, $content_offset, $h1_strpos - $content_offset) : ' . substr($code, $content_offset, $h1_strpos - $content_offset) );
			//print('substr($code, $h1_strpos + strlen($h1_including_tag), $length_of_after_h1_including_tag - $length_of_after_content) : ' . substr($code, $h1_strpos + strlen($h1_including_tag), $length_of_after_h1_including_tag - $length_of_after_content));
			$content = substr($code, $content_offset, $h1_strpos - $content_offset) . substr($code, $h1_strpos + strlen($h1_including_tag), $length_of_after_h1_including_tag - $length_of_after_content);
		}
		//print('substr($code, $h1_strpos, strlen($h1_including_tag)): ' . substr($code, $h1_strpos, strlen($h1_including_tag)));
		//print('$content in templating2: ');ReTidy::var_dump_full($content);
		$h1_including_tag = str_replace('<' . $h1_previous_tag_name, '<h1', $h1_including_tag);
		$h1_including_tag = str_replace('</' . $h1_previous_tag_name . '>', '</h1>', $h1_including_tag);
		$length_adjustment_due_to_previous_tag_name = 2 * (strlen('h1') - strlen($h1_previous_tag_name));
		//print('$h1_including_tag2: ' . $h1_including_tag);
		$content = $h1_including_tag . $content;
		//print('$content: ');var_dump($content);
		//print('$code2: ' . htmlentities($code));
		//print('content_in_templating3: ' . $content);
		//print('$code, $content_offset, $content: ');ReTidy::var_dump_full($code, $content_offset, $content);
		$code = substr($code, 0, $content_offset) . $content . substr($code, $content_offset + strlen($content) - $length_adjustment_due_to_previous_tag_name - $added_h1_length);
		// 2017-10-05
		// 2018-07-25; previously it was unclear why -2, but frequently we are converting a <p> to an <h1> making a difference in length of 2
		//$code = substr($code, 0, $content_offset) . $content . substr($code, $content_offset + strlen($content));
		//print('$code3: ' . htmlentities($code));
		// h1 inside the content
	//	if(!$inventing_h1) {
			preg_match('/<h1[^<>]*?>(.*?)<\/h1>/is', $content, $h1_matches, PREG_OFFSET_CAPTURE);
			$h1 = $h1_matches[1][0];
	//	} else {
			//print('should never get here...3489573495873');exit(0);
			//$h1 = $h1_matches[2][0];
	//		$h1 = $possible_heading_content;
	//	}
		// remove anchors and comments from the h1; if they are required, then the new versions should exist in the template
		$cleaned_h1 = $h1;
		$cleaned_h1 = preg_replace('/<a [^<>]*?>/is', '', $cleaned_h1);
		$cleaned_h1 = preg_replace('/<!--[^<>]*?-->/is', '', $cleaned_h1);
		$cleaned_h1 = str_replace('</a>', '', $cleaned_h1);
		$h1_offset = $content_offset + $h1_matches[1][1];
		// exclude the <h1> from the content for the purposes of templating
		//$content = substr($content, $h1_matches[0][1] + strlen($h1_matches[0][0]));
		//$content = str_replace($h1_matches[0][0], '', $content); // not good enough
		$content = substr($content, $h1_matches[0][1] + strlen($h1_matches[0][0]));
		//print('content_in_templating4: ' . $content);
		$content_offset += $h1_matches[0][1] + strlen($h1_matches[0][0]); 
		// exclude the date modified from the content for the purposes of templating
		// this is very specific so we might need to have date modified detection similar to what's in the templateCode function (around line 600)
		if(preg_match('/<dl[^<>]*?>\s*<dt>(Date modified:|Date de modification&#160;:)<\/dt>\s*<dd>\s*<span>\s*<time>([^<>]*?)<\/time>\s*<\/span>\s*<\/dd>\s*<\/dl>/is', $content, $date_modified_matches, PREG_OFFSET_CAPTURE)) {
			//var_dump($date_modified_matches);
			$content = substr($content, 0, $date_modified_matches[0][1]);
		}
		//print('content_in_templating5: ' . $content);
		$cleaned_content = $content;
		//print('$cleaned_content1: ' . $cleaned_content);
		$array_content_comments_to_remove = array(
		'<!-- Content title begins / Début du titre du contenu -->',
		'<!-- Content Title ends / Fin du titre du contenu -->',
		'<!-- clf2-nsi2 theme begins / Début du thème clf2-nsi2 -->',
		'<!-- clf2-nsi2 theme ends / Fin du thème clf2-nsi2 -->',
		'<!-- CONTENT TITLE BEGINS | DEBUT DU TITRE DU CONTENU -->',
		'<!-- CONTENT TITLE ENDS | FIN DU TITRE DU CONTENU -->',
		'<!-- InstanceEndEditable -->',
		);
		foreach($array_content_comments_to_remove as $index => $value) {
			$cleaned_content = str_replace($value, '', $cleaned_content);
		}
		//print('$cleaned_content2: ' . $cleaned_content);
		$array_regex_content_comments_to_remove = array(
		'<!-- InstanceBeginEditable name="[^"]*?" -->',
		);
		foreach($array_regex_content_comments_to_remove as $index => $value) {
			$cleaned_content = preg_replace('/' . $value . '/is', '', $cleaned_content);
		}
		//print('ContentArray	: ');var_dump(array($content, $content_offset, $cleaned_content, $h1, $h1_offset, $cleaned_h1));
		//print('$cleaned_content3: ' . $cleaned_content);
		//print('$code in getContentArray: ' . $code);
		return array($code, $content, $content_offset, $cleaned_content, $h1, $h1_offset, $cleaned_h1);
	}
	
	function getContentArray($code, $strip_template_content_comments = false) {
		// content; in this generalized templater order, attempts at grabbing the content are from the more specific to the more general
		$opening_content_div = '<div id="cn-centre-col-inner">';
		$strpos_content_div = strpos($code, $opening_content_div);
		if($strpos_content_div !== false) {
			$content_div_code = OM::getOString($code, '<div', '</div>', $strpos_content_div);
			$strlen_opening_content_div = strlen($opening_content_div);
			$content = substr($content_div_code, $strlen_opening_content_div, strlen($content_div_code) - $strlen_opening_content_div - 6);
			$content_offset = $strpos_content_div + $strlen_opening_content_div;
			//print($content);exit(0);
			// call the end of content comment comment part of the content container rather than the content itself...
			// treating the open and close differently and possibly leaving us open to future problems...
			//$pos_close_content_comment = strpos($content, '<!-- clf2-nsi2 theme ends / Fin du thème clf2-nsi2 -->');
			//if($pos_close_content_comment !== false) {
			//	$content = substr($content, 0, $pos_close_content_comment);
			//}
			//print($content);exit(0);
			if($strip_template_content_comments) {
				// remove template comments from the beginning of the content
				$content = str_replace('<!-- Content title begins / Début du titre du contenu -->', '', $content);
				$content = str_replace('<!-- Content Title ends / Fin du titre du contenu -->', '', $content);
				$content = str_replace('<!-- clf2-nsi2 theme begins / Début du thème clf2-nsi2 -->', '', $content);
				// remove template comments from the end of the content?
				$content = str_replace('<!-- clf2-nsi2 theme ends / Fin du thème clf2-nsi2 -->', '', $content);
			}
		} else {
			$opening_content_div = '<div class="center">';
			$strpos_content_div = strpos($code, $opening_content_div);
			if($strpos_content_div !== false) {
				$content_div_code = OM::getOString($code, '<div', '</div>', $strpos_content_div);
				$strlen_opening_content_div = strlen($opening_content_div);
				$content = substr($content_div_code, $strlen_opening_content_div, strlen($content_div_code) - $strlen_opening_content_div - 6);
				$content_offset = $strpos_content_div + $strlen_opening_content_div;
				if($strip_template_content_comments) {
					// remove template comments from the beginning of the content
					$content = str_replace('<!-- CONTENT TITLE BEGINS | DEBUT DU TITRE DU CONTENU -->', '', $content);
					$content = str_replace('<!-- CONTENT TITLE ENDS | FIN DU TITRE DU CONTENU -->', '', $content);
				}
			} else {
				$body = OM::getOString($code, '<body', '</body>');
				if(strlen($body) === 0) {
					return $code; // we return the unchanged code
				} else {
					preg_match('/<body[^<>]*?>/is', $body, $opening_body_tag_matches, PREG_OFFSET_CAPTURE);
					$opening_body_tag = $opening_body_tag_matches[0][0];
					$strlen_opening_body_tag = strlen($opening_body_tag);
					$content = substr($body, $strlen_opening_body_tag, strlen($body) - $strlen_opening_body_tag - 7);
					$content_offset = $opening_body_tag_matches[0][1] + $strlen_opening_body_tag;
				}
			}
		}
		return array($content, $content_offset);
	}
	
	function repair_PPSC_Template() {
		if(strpos($this->code, "<!-- InstanceBegin template=") !== false) {
			if(!preg_match('/<!-- InstanceBeginEditable name="doctitle" -->(.*?)<!-- InstanceEndEditable -->/is', $this->code, $doctitle_matches)) {
				print('doctitle not found');exit(0);
			} else {
				//print('$doctitle_matches: ');var_dump($doctitle_matches);
				preg_match('/\s*/is', $doctitle_matches[1], $doctitle_space_matches);
				if(strlen($doctitle_matches[1]) === strlen($doctitle_space_matches[0])) {
					//print('need to repair the doctitle');exit(0);
					$this->code = preg_replace('/<!-- Title begins \/ Début du titre -->\s*<!-- InstanceBeginEditable name="doctitle" -->\s*<!-- InstanceEndEditable -->\s*<!-- Title ends \/ Fin du titre -->/is', '', $this->code);
					$this->code = str_replace('<title', '<!-- Title begins / Début du titre -->
<!-- InstanceBeginEditable name="doctitle" -->
<title', $this->code);
					$this->code = str_replace('</title>', '</title>
<!-- InstanceEndEditable -->
<!-- Title ends / Fin du titre -->', $this->code);
					$this->logMsgIf('PPSC doctitle repaired', 1);
				}
			}
			if(!preg_match('/<!-- InstanceBeginEditable name="meta" -->(.*?)<!-- InstanceEndEditable -->/is', $this->code, $meta_matches)) {
				print('meta not found');exit(0);
			} else {
				preg_match('/\s*/is', $meta_matches[1], $meta_space_matches);
				if(strlen($meta_matches[1]) === strlen($meta_space_matches[0])) {
					//print('need to repair the meta');exit(0);
					$this->code = preg_replace('/<!-- Meta-data begins \/ Début des métadonnées -->\s*<!-- InstanceBeginEditable name="meta" -->\s*<!-- InstanceEndEditable -->\s*<!-- Meta-data ends \/ Fin des métadonnées -->/is', '', $this->code);
					$this->code = str_replace('<meta name="dcterms.description"', '<!-- Meta-data begins / Début des métadonnées -->
<!-- InstanceBeginEditable name="meta" -->
<meta name="dcterms.description"', $this->code);
					$this->code = preg_replace('/<meta name="dcterms.language" scheme="ISO639-2" content="[^"]*" \/>/is', '$0
<!-- InstanceEndEditable -->
<!-- Meta-data ends / Fin des métadonnées -->', $this->code);
					$this->logMsgIf('PPSC meta repaired', 1);
					// repair the instance marker
					preg_match('/<!-- InstanceBegin template="[^<>]*>/is', $this->code, $instance_matches);
					$instance_code = $instance_matches[0];
					$this->code = str_replace($instance_code, '', $this->code);
					$this->code = str_replace('<head>', $instance_code . '
<head>', $this->code);
					$this->code = str_replace('<!-- Web Experience Toolkit (WET) / Boîte à outils de l\'expérience Web (BOEW) 
	Terms and conditions of use: http://tbs-sct.ircan.gc.ca/projects/gcwwwtemplates/wiki/Terms
	Conditions régissant l\'utilisation : http://tbs-sct.ircan.gc.ca/projects/gcwwwtemplates/wiki/Conditions
	-->', '', $this->code);
					$this->code = str_replace('<!-- Title begins', '<!-- Web Experience Toolkit (WET) / Boîte à outils de l\'expérience Web (BOEW) 
	Terms and conditions of use: http://tbs-sct.ircan.gc.ca/projects/gcwwwtemplates/wiki/Terms
	Conditions régissant l\'utilisation : http://tbs-sct.ircan.gc.ca/projects/gcwwwtemplates/wiki/Conditions
	-->
<!-- Title begins', $this->code);
					$this->code = str_replace('<!-- Favicon (optional) begins / Début du favicon (optionnel) -->
<!--  -->
<!-- Favicon (optional) ends / Find du favicon (optionnel) -->', '', $this->code);
					$this->code = str_replace('<!-- Meta-data begins', '<!-- Favicon (optional) begins / Début du favicon (optionnel) -->
<!--  -->
<!-- Favicon (optional) ends / Find du favicon (optionnel) -->
<!-- Meta-data begins', $this->code);
				}
			}
		}
	}
	
	function clean_CSS() {
		//var_dump($this->file);exit(0);
		if(strpos($this->file, ".css") === false) {
			
		} else {
			// CSS parser
			//include('..' . DS . 'csstidy' . DS . 'class.csstidy.php');
			require_once('csstidy' . DS . 'class.csstidy.php');

			/*$css_code = '
			a {
			color:black;
			background-color:blue;
			}';*/

			$css = new csstidy();

			$css->set_cfg('remove_last_;',TRUE);

			//$css->parse($css_code);
			$css->parse($this->code);

			//echo $css->print->formatted();
			//echo $css->print->plain();
			$this->code = $css->print->plain();
		}
	}
	
	function clean_feeds() { // this function should never be used if other functions act with suffucient exactitude 
		//var_dump($this->file);
		if(strpos($this->code, '<feed xmlns="http://www.w3.org/2005/Atom"') === false && strpos($this->code, '<feed xmlns="https://www.w3.org/2005/Atom"') === false) { // this is not a feed file
		
		} else {
			include_once('feed_generator' . DS . 'FeedWriter.php');
			//include('feed_generator' . DS . 'FeedWriter.php');
			$changed_feed_file = false;
			$TestFeed = new FeedWriter(ATOM);
			
			$feed_pos = strpos($this->code, '<feed');
			$first_entry_pos = strpos($this->code, '<entry');
			$header_code = substr($this->code, $feed_pos, $first_entry_pos - $feed_pos);
			preg_match_all('/<id[^<>]*?>(.*?)<\/id>/is', $header_code, $id_matches);
			//print('$id_matches: ');var_dump($id_matches);exit(0);
			if(sizeof($id_matches[0]) === 1) {
				$current_id = $id_matches[1][0];
			} else {
				print('Found other than one ID in Atom RSS header...');var_dump($header_code);exit(0);
			}
			preg_match_all('/<link[^<>]*? href="([^"]*?)"[^<>]*?>(.*?)<\/link>/is', $header_code, $link_matches);
			if(sizeof($id_matches[0]) === 1) {
				$current_link = $link_matches[1][0];
			} else { // we have to be a bit more clever
				$found_default_link = false;
				foreach($link_matches[0] as $index => $value) {
					if(strpos($link_matches[0][$index], 'rel="self"') !== false) {
						$found_default_link = true;
						$current_link = $link_matches[1][$index];
						break;
					}
				}
				if($found_default_link) {
					print('Could not find default link for Atom RSS feed file...');var_dump($header_code);exit(0);
				}
			}
			$generated_id = $TestFeed->uuid($current_link, 'urn:uuid:');
			if($generated_id !== $current_id) {
				$this->code = str_replace($current_id, $generated_id, $this->code);
				$this->logMsg('Feed file ID with link: ' . $current_link . ' was changed.');
				$changed_feed_file = true;
			}
				
			preg_match_all('/<entry(.*?)<\/entry>/is', $this->code, $entry_matches);
			$counter = sizeof($entry_matches[0]) - 1;
			while($counter > -1) {
				$entry_match = $initial_entry_match = $entry_matches[0][$counter];
				preg_match_all('/<id[^<>]*?>(.*?)<\/id>/is', $entry_match, $id_matches);
				if(sizeof($id_matches[0]) === 1) {
					$current_id = $id_matches[1][0];
				} else {
					print('Found other than one ID in an Atom RSS entry...');var_dump($entry_match);exit(0);
				}
				preg_match_all('/<link[^<>]*? href="([^"]*?)"[^<>]*?>(.*?)<\/link>/is', $entry_match, $link_matches);
				if(sizeof($id_matches[0]) === 1) {
					$current_link = $link_matches[1][0];
				} else { // we have to be a bit more clever
					$found_default_link = false;
					foreach($link_matches[0] as $index => $value) {
						if(strpos($link_matches[0][$index], 'rel="self"') !== false) {
							$found_default_link = true;
							$current_link = $link_matches[1][$index];
							break;
						}
					}
					if($found_default_link) {
						print('Could not find default link for an Atom RSS entry...');var_dump($entry_match);exit(0);
					}
				}
				$generated_id = $TestFeed->uuid($current_link, 'urn:uuid:');
				if($generated_id !== $current_id) {
					//var_dump($generated_id, $current_id);
					//print('current_id: ');var_dump($current_id);
					//print('generated_id: ');var_dump($generated_id);
					$entry_match = str_replace($current_id, $generated_id, $entry_match);
					$this->logMsg('ID on entry with link: ' . $current_link . ' was changed.');
				}/* else {
					print('hi3740650056<br>');
				}*/
				//print('here37485969707<br>');
				if($entry_match != $initial_entry_match) {
					//print('here37485969708<br>');
					$this->code = str_replace($initial_entry_match, $entry_match, $this->code);
					$changed_feed_file = true;
				}
				$counter--;
			}
			//print('here37485969709<br>');
			if($changed_feed_file) {
				//print('here37485969710<br>');
				//var_dump(date("Y-m-d"), time("Y-m-d"));
				$this->code = preg_replace('/<feed([^<>]*?)>(.*?)<updated>([0-9]{4})\-([0-9]{2})\-([0-9]{2})([^<>]*?)<\/updated>/is', '<feed$1>$2<updated>' . date("Y-m-d") . '$6</updated>', $this->code);
			}
		}
	}
	
	function str_replace_from_offset($search, $replace, $subject, $count = -1, $offset = 0) { // this function should never be used if other functions act with suffucient exactitude 
		$substr = substr($subject, $offset);
		$substr = str_replace($search, $replace, $substr, $count);
		$subject = substr($subject, 0, $offset) . $substr;
		return $subject;
	}
	
	function templateCode($template_code, $save_template = false, $error_reporting = true, $find_metadata = false) {
		//print('$this->template2: ');var_dump($this->template);
		//print('$this->code1: ' . $this->code);
		//print('here3495960670708<br>');
		if(strlen($template_code) === 0) {
			print('Template code: ' . $template_code . ' was improperly specified.');exit(0);
		}
		//print('here355696970<br>');
		ReTidy::convert_to(ReTidy::find_charset($template_code));
		$found_title = true;
		//var_dump(preg_match('/<title>(.*?)<\/title>/is', $this->code, $title_matches, PREG_OFFSET_CAPTURE));
		//print('$this->code2: ' . $this->code);
		if(preg_match('/<title>(.*?)<\/title>/is', $this->code, $title_matches, PREG_OFFSET_CAPTURE) !== 1) { $found_title = false; }
		//print('$template_code3.4: ' . htmlentities($template_code));
		if($find_metadata) {
			preg_match_all('/<meta name="([^"]*?)"[^<>]*? content="([^"]*?)"/is', $this->code, $this->saved_metadata_matches, PREG_OFFSET_CAPTURE);
		}
		//print('here4756680970970978-0<br>');
		if($this->made_new_classes === true) {
			//print('here4756680970970978-1<br>');
			$styleOStrings = OM::getAllOStrings($this->code, '<style', '</style>');
			if(sizeof($styleOStrings) > 1) {
				ReTidy::warning('More than one &lt;style&gt; found in templateCode.');
				print('$styleOStrings: ');var_dump($templateStyleOStrings);
			}
			$styleOString = $styleOStrings[0][0];
			//print('$styleOString: ' . htmlentities($styleOString));
			//if(strpos($styleOString, '{') !== false) {
			//print('here4756680970970978-2<br>');
				//$embedded_style_information = OM::getOStringContents($styleOString);
			$styleOString = preg_replace('/}\s*/is', '}
', $styleOString);
			$styleOString = str_replace('>', '>
', $styleOString);
			$templateStyleOStrings = OM::getAllOStrings($template_code, '<style', '</style>');
			if(sizeof($templateStyleOStrings) > 1) {
				ReTidy::warning('More than one &lt;style&gt; found in templateCode2.');
				print('$templateStyleOStrings: ');var_dump($templateStyleOStrings);
			}
			$templateStyleOString = $templateStyleOStrings[0][0];
			//print('$templateStyleOString: ');var_dump($templateStyleOString);
			if(strpos($templateStyleOString, '{') !== false) {
				//print('here4756680970970978-3<br>');
				//$template_embedded_style_information = OM::getOStringContents($templateStyleOString);
				$template_code = str_replace($templateStyleOString, $styleOString, $template_code);
			}
			//}
		}
		//print('here355696971<br>');
		//print('$this->code3.5: ' . htmlentities($this->code));
		//print('$template_code3.5: ' . htmlentities($template_code));
		$contentArray = ReTidy::getContentArrayForTemplating($this->code, true);
		//print('$contentArray: ');var_dump($contentArray);
		//print('$this->code3.6: ' . htmlentities($this->code));
		$title = $title_matches[1][0];
		$title_offset = $title_matches[1][1];
		$this->code = $contentArray[0];
		$content = $contentArray[1];
		$content_offset = $contentArray[2];
		$cleaned_content = $contentArray[3];
		$h1 = $contentArray[4];
		$h1_offset = $contentArray[5];
		$cleaned_h1 = $contentArray[6];
		//print('$content: ' . $content);
		//print('$cleaned_content: ' . $cleaned_content);
		// still have to do path processing
		// proper embedded stylesheets
		// date modified
		/*      <dl id="cn-doc-dates">
        <dt>Date Modified:</dt>
        <dd><!-- InstanceBeginEditable name="date" -->2012-04-23<!-- InstanceEndEditable --></dd>
      </dl>
	  */
		//print('here355696972<br>');
		if($find_metadata && preg_match_all('/((Date Modified)|(Date de modification))/is', $this->code, $date_modified_text_matches, PREG_OFFSET_CAPTURE)) {
			//Date Modified: <span class="date"><!-- InstanceBeginEditable name="ft" -->2009-03-10<!-- InstanceEndEditable --></span>
			//print('date_modified_text_matches: ');var_dump($date_modified_text_matches);
			$counter77 = sizeof($date_modified_text_matches[0]) - 1;
			$date_modified_tag_matches = array();
			while(sizeof($date_modified_tag_matches) === 0) {
				if($counter77 === -1) {
					print('Failed to find the date modifed.3945876347638');exit(0);
				}
				$pos_date_modified_text = $date_modified_text_matches[0][$counter77][1];
				preg_match('/<((dd)|(span)|(time))/is', $this->code, $date_modified_tag_matches, PREG_OFFSET_CAPTURE, $pos_date_modified_text);
				$counter77--;
			}
			//print('date_modified_tag_matches: ');var_dump($date_modified_tag_matches);
			$pos_date_modified = $date_modified_tag_matches[0][1];
			$tagName = $date_modified_tag_matches[1][0];
			//$date_modified_text_position = 'Date Modified:';
			//$strlen_date_modified_opening_tag = strlen($date_modified_opening_tag);
			//$pos_date_modified = strpos($this->code, $date_modified_opening_tag);
			$opening_piece = '<' . $tagName;
			$closing_string = '</' . $tagName . '>';
			$strlen_closing_string = strlen($closing_string);
			$date_modified_tag = OM::getOString($this->code, $opening_piece, $closing_string, $pos_date_modified);
			//print('date_modified_tag: ');var_dump($date_modified_tag);
			$opening_string = substr($date_modified_tag, 0, strpos($date_modified_tag, '>') + 1);
			$strlen_opening_string = strlen($opening_string);
			$date_modified = substr($date_modified_tag, $strlen_opening_string, strlen($date_modified_tag) - $strlen_opening_string - $strlen_closing_string);
			$cleaned_date_modified = ReTidy::tagless($date_modified);
			$cleaned_date_modified = str_replace('&ndash;', '-', $cleaned_date_modified);
			$cleaned_date_modified = str_replace('&#8211;', '-', $cleaned_date_modified);
			$cleaned_date_modified = str_replace('&#x2013;', '-', $cleaned_date_modified);
			$cleaned_date_modified = str_replace('–', '-', $cleaned_date_modified);
			$cleaned_date_modified = str_replace('&mdash;', '-', $cleaned_date_modified);
			$cleaned_date_modified = str_replace('&#8212;', '-', $cleaned_date_modified);
			$cleaned_date_modified = str_replace('&#x2014;', '-', $cleaned_date_modified);
			$cleaned_date_modified = str_replace('—', '-', $cleaned_date_modified);
			//print('date_modified: ');var_dump($date_modified);
			//print('cleaned_date_modified: ');var_dump($cleaned_date_modified);
			$found_date_modified = true;
		} else {
			$found_date_modified = false;
		}
	//	$breadcrumb_offset = $breadcrumb_matches[1][1];
		//print('here355696973<br>');
		$date_modified_offset = $pos_date_modified + $strlen_opening_string;
		
		/*if($error_reporting) {
			//$this->logMsg("=== detemplate Begin ===");
			if($found_title) {
				if(strlen($title) === 0) {
					ReTidy::warning('Title of length 0!');
				}
				if($title_count === 0) {
					ReTidy::warning('Title conversion failed!');
				}
			}
		//	if($found_breadcrumb) {
		//		if(strlen($breadcrumb) === 0) {
		//			ReTidy::warning('Breadcrumb of length 0!');
		//		}
		//		if($breadcrumb_count === 0) {
		//			ReTidy::warning('Breadcrumb conversion failed!');
		//		}
		//	}
			if(strlen($h1) === 0) {
				ReTidy::warning('h1 of length 0!');
			}
			if($h1_count === 0) {
				ReTidy::warning('h1 conversion failed!');
			}
			if(strlen($content) === 0) {
				ReTidy::warning('Content of length 0!');
			}
			if($content_count === 0) {
				ReTidy::warning('Content conversion failed!');
			}
			if($found_date_modified) {
				if(strlen($date_modified) === 0) {
					ReTidy::warning('Date modified of length 0!');
				}
				if($date_modified_count === 0) {
					ReTidy::warning('Date modified conversion failed!');
				}
			}
			// better error reporting would be good
			//$this->logMsg("=== detemplate End ===");
		}*/
		//print('$this->code3.7: ' . htmlentities($this->code));
		$replacement_array = array();
		if($found_date_modified) {
			$replacement_array[$date_modified_offset] = array('{date_modified}', $date_modified);
		}
		$replacement_array[$h1_offset] = array('{h1}', $h1);
		$replacement_array[$content_offset] = array('{content}', $content);
		if($found_title) {
			$replacement_array[$title_offset] = array('{title}', $title);
		}
	//	if($found_breadcrumb) {
	//		$replacement_array[$breadcrumb_offset] = array('{breadcrumb}', $breadcrumb);
	//	}
		//print('$replacement_array1: ');var_dump($replacement_array);
		//print('$this->saved_metadata_matches: ');var_dump($this->saved_metadata_matches);
		foreach($this->saved_metadata_matches[0] as $index => $value) {
			$replacement_array[$this->saved_metadata_matches[2][$index][1]] = array('{' . $this->saved_metadata_matches[1][$index][0] . '}', $this->saved_metadata_matches[2][$index][0]);
		}
		ksort($replacement_array);
		$replacement_array = array_reverse($replacement_array, true);
		//print('$this->code4: ' . htmlentities($this->code));
		//print('$replacement_array2: ');var_dump($replacement_array);
		foreach($replacement_array as $offset => $code_part_array) {
			$code_part_replacement = $code_part_array[0];
			$code_part = $code_part_array[1];
			//var_dump($code_part_replacement, $code_part);
			//$this->code = substr($this->code, 0, $offset) . $region_content . substr($this->code, $offset + strlen('{' . $region_name . '}'));
			/*print('






doing ' . $code_part_replacement . '
' . $code_part . '
');*/
			//print('$offset, strlen($code_part): ' . $offset . ', ' . strlen($code_part) . '<br>');
			$this->code = substr($this->code, 0, $offset) . $code_part_replacement . substr($this->code, $offset + strlen($code_part));
			//print('--.+.--<br>');
			//print($this->code);
		}
		//print('$this->code5: ' . htmlentities($this->code));
		// saved_code_parts is no longer an appropriate name for how this function is
		if(!$found_date_modified) {
			$cleaned_date_modified = $this->saved_code_parts['date_modified'];
		}
		// save template we are de-templating from to file
		$this->saved_code_parts = array();
		$this->saved_code_parts['h1'] = $cleaned_h1;
		$this->saved_code_parts['content'] = $cleaned_content;
		if($found_title) {
			$this->saved_code_parts['title'] = $title;
		}

		//$this->saved_code_parts['breadcrumb'] = $breadcrumb;

		$this->saved_code_parts['date_modified'] = $cleaned_date_modified;

		foreach($this->saved_metadata_matches[0] as $index => $value) {
			$this->saved_code_parts[$this->saved_metadata_matches[1][$index][0]] = $this->saved_metadata_matches[2][$index][0];
		}
		// this saved templates record keeping could be not run if it is time-intensive
		if($save_template) {
			$dir = 'Templates' . DS . 'saved';
			$handle = opendir($dir);
			$this_template_has_already_been_saved = false;
			if(file_exists('Templates' . DS . 'saved' . DS . 'saved_templates.txt')) {
				$saved_templates_file_contents = file_get_contents('Templates' . DS . 'saved' . DS . 'saved_templates.txt');
			} else {
				$saved_templates_file_contents = '';
			}
			$initial_saved_templates_array = $saved_templates_array = explode('
', $saved_templates_file_contents);
			while(($entry = readdir($handle)) !== false) {
				//print('here290405-05<br>');
				$entry_path = $dir . '/' . $entry;
				if(is_file($entry_path) && substr($entry, strlen($entry) - 5) === '.html') {
					//print('here290405-06<br>');
					$saved_template_contents = file_get_contents($entry_path);
					//var_dump($saved_template_contents, $this->code);
					if($saved_template_contents === $this->code) {
						//print('here290405-07<br>');
						foreach($saved_templates_array as $index => $name_tab_count) {
							//print('here290405-08<br>');
							$name = substr($name_tab_count, 0, strpos($name_tab_count, '	'));
							if($name === substr($entry, 0, strlen($entry) - 5)) {
								//print('here290405-09<br>');
								$count = substr($name_tab_count, strpos($name_tab_count, '	') + 1);
								$updated_saved_templates_array_item = $name . '	' . ($count + 1);
								$saved_templates_array[$index] = $updated_saved_templates_array_item;
								break;
							}
						}
						$this_template_has_already_been_saved = true;
						break;
					}
				}
			}
			closedir($handle);
			$this->saved_template = $this->code;
			if(!$this_template_has_already_been_saved) {
				//print('here290405-10<br>');
				$new_saved_template_counter = 1;
				if(preg_match('/[A-Z]{2,}/s', $title, $acronym_matches)) {
					//print('here290405-11<br>');
					// would like to ignore false acronyms: III, IV etc...
					$new_saved_template_base = $acronym_matches[0];
				} else {
					//print('here290405-12<br>');
					$new_saved_template_base = 'unknown';
				}
				$new_saved_template_name = $new_saved_template_base . $new_saved_template_counter;
				$this_name_has_already_been_used = true; // initialization
				while($this_name_has_already_been_used) {
					//print('here290405-13<br>');
					$this_name_has_already_been_used = false;
					foreach($saved_templates_array as $index => $name_tab_count) {
						//print('here290405-14<br>');
						$name = substr($name_tab_count, 0, strpos($name_tab_count, '	'));
						if($name === $new_saved_template_name) {
							//print('here290405-15<br>');
							$new_saved_template_counter++;
							$new_saved_template_name = $new_saved_template_base . $new_saved_template_counter;
							$this_name_has_already_been_used = true;
							break;
						}
					}
				}
				$saved_templates_array[] = $new_saved_template_name . '	1';
				$new_saved_template_filename = $new_saved_template_name . '.html';
				file_put_contents($dir . '/' . $new_saved_template_filename, $this->saved_template);
				//var_dump($this->saved_template);
			}
			//var_dump($initial_saved_templates_array, $saved_templates_array);
			if($initial_saved_templates_array != $saved_templates_array) {
				$new_saved_templates_file_contents = implode('
', $saved_templates_array);
				file_put_contents('Templates' . DS . 'saved' . DS . 'saved_templates.txt', $new_saved_templates_file_contents);
			}
		}
		//print('$this->code6: ' . $this->code);
		//$this->code = file_get_contents('Templates\XHTML-blank-css.html');
		$this->code = $template_code;
		//$this->code = str_replace('{title}', $this->saved_code_parts['title'], $this->code, $title_count);
		//$this->code = str_replace('{h1}', $this->saved_code_parts['h1'], $this->code, $h1_count);
		//$this->code = str_replace('{content}', $this->saved_code_parts['content'], $this->code, $content_count);
		//print('$replacement_array, $this->saved_code_parts: ');var_dump($replacement_array, $this->saved_code_parts);
		//print('$template_code: ' . $template_code);
		$region_names_string = '';
		foreach($this->saved_code_parts as $index => $value) {
			$region_names_string .= ReTidy::preg_escape($index) . '|';
		}
		$region_names_string = substr($region_names_string, 0, strlen($region_names_string) - 1);
		//var_dump($region_names_string);
		//print('$this->saved_code_parts[\'content\']: ' . $this->saved_code_parts['content']);
		//print('$this->code6.5: ' . htmlentities($this->code));
		preg_match_all('/\{(' . $region_names_string . ')\}/is', $this->code, $template_region_matches, PREG_OFFSET_CAPTURE);
		//print('$template_region_matches: ');var_dump($template_region_matches);
		$region_replacements_done_array = array();
		$counter = sizeof($template_region_matches[0]) - 1;
		while($counter > -1) {
			$region_name = $template_region_matches[1][$counter][0];
			//print('$region_name: ');var_dump($region_name);
			if(!isset($region_replacements_done_array[$region_name])) {
				$region_replacements_done_array[$region_name] = 0;
			}
			$region_content = $this->saved_code_parts[$region_name];
			$offset = $template_region_matches[0][$counter][1];
			if(isset($region_content)) {
				//print('here3457493040304304<br>');
				//print('substr($this->code, $offset, strlen(\'{\' . $region_name . \'}\')): ');var_dump(substr($this->code, $offset, strlen('{' . $region_name . '}')));
				//ReTidy::warning('Direct template region match ' . $region_name . ' found.');
				$this->code = substr($this->code, 0, $offset) . $region_content . substr($this->code, $offset + strlen('{' . $region_name . '}'));
				//print('substr($this->code, 0, $offset), $region_content, substr($this->code, $offset + strlen(\'{\' . $region_name . \'}\'))');var_dump(substr($this->code, 0, $offset), $region_content, substr($this->code, $offset + strlen('{' . $region_name . '}')));
				/*print('doing ' . $region_name . '
' . $this->code);*/
				$region_replacements_done_array[$region_name]++;
			} else {
				//print('here3457493040304305<br>');
				$found_indexical_match_for_region = false;
				$found_title = false;
				foreach($replacement_array as $index2 => $value2) {
					$region_name2 = substr($value2[0], 1, strlen($value2[0]) - 2);
					$region_content2 = $this->saved_code_parts[$region_name2];
					if($region_name2 === 'title') {
						$title_content = $region_content2;
						$found_title = true;
					}
					if(stripos($region_name, $region_name2) !== false || stripos($region_name2, $region_name) !== false) {
						//print('here3457493040304306<br>');
						//var_dump($region_name, $region_name2);
						//$this->code = str_replace('{' . $region_name2 . '}', $region_content, $this->code);
						$this->code = substr($this->code, 0, $offset) . $region_content2 . substr($this->code, $offset + strlen('{' . $region_name . '}'));
						//print('substr($this->code, 0, $offset), $region_content2, substr($this->code, $offset + strlen(\'{\' . $region_name . \'}\'))');var_dump(substr($this->code, 0, $offset), $region_content2, substr($this->code, $offset + strlen('{' . $region_name . '}')));
						//ReTidy::warning('Indirect template region match ' . $region_name2 . ' was used instead of ' . $region_name);
						$found_indexical_match_for_region = true;
						$region_replacements_done_array[$region_name]++;
						break;
					}
				}
				if(!$found_indexical_match_for_region) {
					if($region_name === 'date_modified') {
						//print('here3457493040304307<br>');
						ReTidy::warning('date_modified template region not found. Using current date instead.');
						$this->code = substr($this->code, 0, $offset) . date("Y-m-d") . substr($this->code, $offset + strlen('{' . $region_name . '}'));
						$region_replacements_done_array[$region_name]++;
					} elseif($region_name === 'title') {
						//print('here3457493040304308<br>');
						ReTidy::warning('title template region not found. Using h1 instead.');
						if(!$found_title) {
							$counter467 = $index2;
							while($counter467 < sizeof($replacement_array)) {
								$region_name3 = substr($replacement_array[$counter467][0], 1, strlen($replacement_array[$counter467][0]) - 2);
								if($region_name3 === 'title') {
									$title_content = $this->saved_code_parts[$region_name2];
									$found_title = true;
									break;
								}
								$counter467++;
							}
						}
						$this->code = substr($this->code, 0, $offset) . $title_content . substr($this->code, $offset + strlen('{' . $region_name . '}'));
						$region_replacements_done_array[$region_name]++;
					} else {
						//print('here3457493040304309<br>');
						print('<span style="color: red;">Not even an indirect template region match for ' . $region_name . ' was found.</span><br />');
						var_dump($region_content, $region_content2);exit(0);
					}
				}
			}
			$counter--;
		}
		//print('$this->code7: ' . $this->code);
		//var_dump($region_replacements_done_array);
		foreach($region_replacements_done_array as $index => $value) {
			if($value == 0) {
				ReTidy::warning('Could not find content for template region ' . $index);
			}
		}
			/*
			$this->code = str_replace('{' . $index . '}', $value, $this->code);
			$found_indexical_match_for_region = false;
			//if($saved_code_part_count < 1) {
			//	ReTidy::warning('No direct template region match found for ' . $index . '. It was applied ' . $saved_code_part_count . ' times.');
				
				if(!$found_indexical_match_for_region) {
					
				}
			//} else {
				$found_indexical_match_for_region = true;
			//}
			foreach($this->saved_code_parts as $index2 => $value2) {
				if($index === $index2) {
					continue;
				}
				//if(ReTidy::indexical_match($index, $index2)) { // not quite what we want since it is too literal
				
			}
			*/
		$doing_XHTML_to_HTML5 = false;
		foreach($this->config['macro'] as $method) {
			if($method === 'XHTML_to_HTML5') {
				$doing_XHTML_to_HTML5 = true;
				break;
			}
		}
			//var_dump($index, ReTidy::is_CLF(), $doing_XHTML_to_HTML5);
			// this hack *_*
		//	if(($index === 'keywords' || $index === 'Keywords') && ReTidy::is_CLF(file_get_contents($this->template)) && $doing_XHTML_to_HTML5) {
		//		continue;
		//	}
			//var_dump($index, $index2, strpos($index, $index2) || strpos($index2, $index));
			/*
			if($error_reporting && ($saved_code_part_count > 1 || ($saved_code_part_count !== 1 && !$found_indexical_match_for_region))) {
				ReTidy::warning('Error applying ' . $index . ' template region. It was applied ' . $saved_code_part_count . ' times.');
				var_dump($value);
			}
			if($error_reporting && ($value === false || strlen($value) === 0)) {
				ReTidy::warning('Error applying ' . $index . ' template region. It seems to be empty.');
				var_dump($value);
			}
			*/
		//}
		if(!$there_exists_embedded_style_information) {
			$this->code = str_replace('{embedded_stylesheet}', '', $this->code);
		}
		$there_exist_embedded_scripts = false; // hack
		if(!$there_exist_embedded_scripts) {
			$this->code = str_replace('{embedded_scripts}', '', $this->code);
		}
		//var_dump($this->saved_code_parts);
		//var_dump($replacement_array);
		//var_dump($template_code, $this->code);
		if($this->template !== false && $this->template !== null && $this->template !== 'unknown') {
			//print('herei74y9875609850968<br>');
			ReTidy::resolve_relative_paths($this->file);
		}
	}
	
	function detemplate() {
		//print('$this->template: ');var_dump($this->template);
		//templateCode($template_code, $save_template = true, $error_reporting = true, $find_metadata = false)
		ReTidy::templateCode(file_get_contents('Templates' . DS . 'XHTML-blank-css.html'), true, false, true);
		//ReTidy::templateCode(file_get_contents('Templates\XHTML-blank-css.html'), false, false, true); // until saving templates doesn't take an extra (exponentially longer) time
		ReTidy::tidy_code();
		return true;
	}
	
	function retemplate() {
		//print('$this->template: ');var_dump($this->template);
		//if(is_dir('not-swept\Templates')) {
			//print('Found templates directory.');exit(0);
			/*if($this->language = 'french') {
				$d = dir('not-swept\Templates');
				while(FALSE !== ($entry = $d->read())) {
					if($entry == '.' || $entry == '..') {
						continue;
					}
					if(strpos($entry, "-fra.") !== false) {
						$template = $source . DS . 'Templates' . DS . $entry;
						break;
					}				
				}
			} else {
				
			}*/
			//var_dump($this->template);
		//}
		if(isset($this->template)) {
			//print('here048058096<br>');
			//ReTidy::templateCode(file_get_contents($this->template), true, true, false);
			ReTidy::templateCode(file_get_contents($this->template), false, true, false);
			//ReTidy::templateCode(file_get_contents($this->template), false, true, true);
		} else {
			//print('here048058097<br>');
			ReTidy::templateCode($this->saved_template, false, true, false);
			//ReTidy::templateCode($this->saved_template, false, true, true);
		}
		return true;
	}
	
	function templateCode_old() {
		$found_title = true;
		$found_description = true;
		$found_keywords = true;
		$found_creator = true;
		$found_issued = true;
		$found_modified = true;
		$found_subject = true;
		$found_breadcrumb = true;
		$found_date_modified = true;
		
		if(preg_match('/<title>(.*?)<\/title>/is', $this->code, $title_matches) !== 1) { $found_title = false; /*print("Did not find a title for this page.");exit(0);*/ }
		if(preg_match('/<meta name="description"[^<>]*? content="([^"]*?)"/is', $this->code, $description_matches) !== 1) { $found_description = false; /*print("Did not find a description for this page.");exit(0);*/ }
		if(preg_match('/<meta name="keywords"[^<>]*? content="([^"]*?)"/is', $this->code, $keywords_matches) !== 1) { $found_keywords = false; /*print("Did not find a keywords for this page.");exit(0);*/ }
		if(preg_match('/<meta name="dcterms\.creator"[^<>]*? content="([^"]*?)"/is', $this->code, $creator_matches) !== 1) {
			if(preg_match('/<meta name="dc\.creator"[^<>]*? content="([^"]*?)"/is', $this->code, $creator_matches) !== 1) { $found_creator = false; /*print("Did not find a creator for this page.");exit(0);*/ }
		}
		if(preg_match('/<meta name="dcterms\.issued"[^<>]*? content="([^"]*?)"/is', $this->code, $issued_matches) !== 1) { 
			if(preg_match('/<meta name="dc\.date\.created"[^<>]*? content="([^"]*?)"/is', $this->code, $issued_matches) !== 1) { $found_issued = false; /*print("Did not find a issued for this page.");exit(0);*/ }
		}
		if(preg_match('/<meta name="dcterms\.modified"[^<>]*? content="([^"]*?)"/is', $this->code, $modified_matches) !== 1) { 
			if(preg_match('/<meta name="dc\.date\.modified"[^<>]*? content="([^"]*?)"/is', $this->code, $modified_matches) !== 1) { $found_modified = false; /*print("Did not find a modified for this page.");exit(0);*/ }
		}
		if(preg_match('/<meta name="dc\.subject"[^<>]*? content="([^"]*?)"/is', $this->code, $subject_matches) !== 1) { 
		$found_subject = false; /*print("Did not find a subject for this page.");exit(0);*/ 
		}
		if(preg_match('/<p class="breadcrumb">\s*(.*?)\s*<\/p>/is', $this->code, $breadcrumb_matches) !== 1) {
			if(preg_match('/<div id="cn-bcrumb">\s*<h2>\s*Breadcrumb\s*<\/h2>\s*(<ol>.*?<\/ol>)\s*<\/div>/is', $this->code, $breadcrumb_matches) !== 1) { $found_breadcrumb = false; /*print("Did not find a breadcrumb for this page.");exit(0);*/ }
		}
		// then do some more work since the content strlen may be greater than 64kb...
	//	if(preg_match('/<div class="center[^"]*?">\s*/is', $this->code, $h1_long_matches, PREG_OFFSET_CAPTURE) !== 1) {
	//		print("Did not find a content for this page2.");exit(0);
	//	}
	//	$begin_offset = $h1_long_matches[0][1] + strlen($h1_long_matches[0][0]);
	//	if(preg_match('/<\/div>\s*<!-- InstanceEndEditable -->\s*(<!-- CONTENT ENDS \| FIN DU CONTENU -->|<!-- FIN DU CONTENU \| CONTENT ENDS -->)/is', $this->code, $content_long_matches, PREG_OFFSET_CAPTURE) !== 1) {
	//		print("Did not find a content for this page3.");exit(0);
	//	}
	//	$end_offset = $content_long_matches[0][1];
	//	$content = substr($this->code, $begin_offset, $end_offset - $begin_offset);
		
		$contentArray = ReTidy::getContentArray($this->code, true);
		$content = $contentArray[0];
		
		// h1 inside the content
		preg_match('/<h1[^<>]*?>(.*?)<\/h1>/is', $content, $h1_matches);
		$h1 = $h1_matches[1];
		// remove anchors and comments from the h1; if they are required, then the new versions should exist in the template
		$h1 = preg_replace('/<a [^<>]*?>/is', '', $h1);
		$h1 = preg_replace('/<!--[^<>]*?-->/is', '', $h1);
		$h1 = str_replace('</a>', '', $h1);
		$content = str_replace($h1_matches[0], '', $content);

		$title = $title_matches[1];
		$description = $description_matches[1];
		$keywords = $keywords_matches[1];
		$creator = $creator_matches[1];
		$issued = $issued_matches[1];
		$modified = $modified_matches[1];
		$subject = $subject_matches[1];
		$breadcrumb = $breadcrumb_matches[1];
		
		//$date_modified_opening_tag = '<span class="date">';
		if(preg_match('/((Date Modified)|(Date de modification))/is', $this->code, $date_modified_text_matches, PREG_OFFSET_CAPTURE)) {
			//print('date_modified_text_matches: ');var_dump($date_modified_text_matches);
			$pos_date_modified_text = $date_modified_text_matches[0][1];
			preg_match('/<((dd)|(span)|(time))/is', $this->code, $date_modified_tag_matches, PREG_OFFSET_CAPTURE, $pos_date_modified_text);
			$pos_date_modified = $date_modified_tag_matches[0][1];
			$tagName = $date_modified_tag_matches[1][0];
			//$date_modified_text_position = 'Date Modified:';
			//$strlen_date_modified_opening_tag = strlen($date_modified_opening_tag);
			//$pos_date_modified = strpos($this->code, $date_modified_opening_tag);
			$opening_piece = '<' . $tagName;
			$closing_string = '</' . $tagName . '>';
			$strlen_closing_string = strlen($closing_string);
			$date_modified_tag = OM::getOString($this->code, $opening_piece, $closing_string, $pos_date_modified);
			//print('date_modified_tag: ');var_dump($date_modified_tag);
			$opening_string = substr($date_modified_tag, 0, strpos($date_modified_tag, '>') + 1);
			$strlen_opening_string = strlen($opening_string);
			$date_modified = substr($date_modified_tag, $strlen_opening_string, strlen($date_modified_tag) - $strlen_opening_string - $strlen_closing_string);
			$date_modified = ReTidy::tagless($date_modified);
			//print('date_modified: ');var_dump($date_modified);
		} else {
			$found_date_modified = false;
		}
		
		// fancy breadcrumb stuff disabled for generalized templater (2011-10-11)
		/*
		if(strpos($breadcrumb, "<li") !== false) {
			// do fancy breadcrumb stuff
			$new_breadcrumb = "<ol>
";
			//var_dump($breadcrumb);
			if(preg_match_all('/<li[^<>]*?>(.*?)<\/li>/is', $breadcrumb, $breadcrumb_items_matches) === 0) { $found_breadcrumb = false; }
			$size = sizeof($breadcrumb_items_matches[0]);
			$counter = $size - 1;
			foreach($breadcrumb_items_matches as $breadcrumb_index => $breadcrumb_value) {
				if($counter === 0) {
					$new_breadcrumb .= '<li>' . $breadcrumb_items_matches[1][$breadcrumb_index] . '</li>
';
				} else {
					if(preg_match('/<a[^<>]*?>(.*?)<\/a>/is', $breadcrumb_items_matches[1][$breadcrumb_index], $link_text_matches) === 0) { print("Did not find a link_text for this page.");exit(0); }
					if(preg_match('/ href="([^"]*?)"/is', $breadcrumb_items_matches[1][$breadcrumb_index], $href_matches) === 0) { print("Did not find a href for this page.");exit(0); }
					if(preg_match('/ title="([^"]*?)"/is', $breadcrumb_items_matches[1][$breadcrumb_index], $link_title_matches) === 0) { print("Did not find a link_title for this page.");exit(0); }
					$new_breadcrumb .= '<li><a rel="';
					$up_counter = $counter;
					$up_string = "";
					while($up_counter > 0) {
						$up_string .= 'up ';
						$up_counter--;
					}
					$up_string = substr($up_string, 0, strlen($up_string) - 1);
					$new_breadcrumb .= $up_string;
					$new_breadcrumb .= ' href="' . $href_matches[1] . '"';
					$new_breadcrumb .= ' title="' . $link_title_matches[1] . '">';
					$new_breadcrumb .= $link_text_matches[1] . '</a>&nbsp;&gt;</li>
';
				}
				$counter--;
			}
			
			$new_breadcrumb = "</ol>
";
		} else {
			// do fancy breadcrumb stuff
			$new_breadcrumb = "<ol>
";
			//var_dump($breadcrumb);
			$breadcrumb_items = explode('&gt;', $breadcrumb);
			$size = sizeof($breadcrumb_items);
			if($size === 1) {
				//print("Only one breadcrumb item found; this may be wrong.");exit(0);
			}
			$counter = $size - 1;
			//var_dump($breadcrumb_items);
			foreach($breadcrumb_items as $breadcrumb_index => $breadcrumb_value) {
				$is_linked = true;
				if(preg_match('/<a[^<>]*?>(.*?)<\/a>/is', $breadcrumb_items[$breadcrumb_index], $link_text_matches) === 0) { $is_linked = false; }
				if(!$is_linked) {
					if($counter === 0) {
						$new_breadcrumb .= '<li>' . ReTidy::trim_nbsp($breadcrumb_items[$breadcrumb_index]) . '</li>
';
					} else {
						$new_breadcrumb .= '<li>' . ReTidy::trim_nbsp($breadcrumb_items[$breadcrumb_index]) . '&nbsp;&gt;</li>
';
					}
					$counter--;
					continue;
				}
				if(preg_match('/ href="([^"]*?)"/is', $breadcrumb_items[$breadcrumb_index], $href_matches) === 0) { print("Did not find a href for this page.");exit(0); }
				$found_link_title = true;
				if(preg_match('/ title="([^"]*?)"/is', $breadcrumb_items[$breadcrumb_index], $link_title_matches) === 0) { $found_link_title = false; }
				if($counter > 0) {
					$new_breadcrumb .= '<li><a rel="';
					$up_counter = $counter;
					$up_string = "";
					while($up_counter > 0) {
						$up_string .= 'up ';
						$up_counter--;
					}
					$up_string = substr($up_string, 0, strlen($up_string) - 1);
					$new_breadcrumb .= $up_string;
					$new_breadcrumb .= '" href="' . $href_matches[1] . '"';
				} else {
					$new_breadcrumb .= '<li><a href="' . $href_matches[1] . '"';
				}
				if($found_link_title) {
					$new_breadcrumb .= ' title="' . $link_title_matches[1] . '">';
				} else {
					$new_breadcrumb .= '>';
				}
				if($counter === 0) {
					$new_breadcrumb .= ReTidy::trim_nbsp($link_text_matches[1]) . '</a></li>
';
				} else {
					$new_breadcrumb .= ReTidy::trim_nbsp($link_text_matches[1]) . '</a>&nbsp;&gt;</li>
';
				}
				$counter--;
			}
			$new_breadcrumb .= "</ol>
";		
		}
		*/
		//var_dump($new_breadcrumb);
		//print("this->template: ");var_dump($this->template);exit(0);
		//if($this->language === "french") {
		//	$this->code = file_get_contents('Templates' . DS . 'PPSC' . DS . 'wet-fra.html');
		//} else {
		//	$this->code = file_get_contents('Templates' . DS . 'PPSC' . DS . 'wet-eng.html');
		//}
		//var_dump($description);
		//var_dump($content);
		
		$this->code = file_get_contents($this->template);
		
		$this->code = str_replace('{title}', $title, $this->code, $title_count);
		$this->code = str_replace('{description}', $description, $this->code, $description_count);
		$this->code = str_replace('{keywords}', $keywords, $this->code, $keywords_count);
		$this->code = str_replace('{creator}', $creator, $this->code, $creator_count);
		$this->code = str_replace('{issued}', $issued, $this->code, $issued_count);
		$this->code = str_replace('{modified}', $modified, $this->code, $modified_count);
		$this->code = str_replace('{subject}', $subject, $this->code, $subject_count);
		$this->code = str_replace('{breadcrumb}', $breadcrumb, $this->code, $breadcrumb_count);
		// it is possible that the breadcrumb style of the template would need to be detected and converted to...
		$this->code = str_replace('{h1}', $h1, $this->code, $h1_count);
		$this->code = str_replace('{content}', $content, $this->code, $content_count);
		$this->code = str_replace('{date_modified}', $date_modified, $this->code, $date_modified_count);
		
		$this->logMsg("=== templateCode Begin ===");
		if($found_title) {
			if(strlen($title) === 0) {
				ReTidy::warning('Title of length 0!');
			}
			if($title_count === 0) {
				ReTidy::warning('Title conversion failed!');
			}
		}
		if($found_description) {
			if(strlen($description) === 0) {
				ReTidy::warning('Description of length 0!');
			}
			if($description_count === 0) {
				ReTidy::warning('Description conversion failed!');
			}
		}
		if($found_keywords) {
			if(strlen($keywords) === 0) {
				ReTidy::warning('Keywords of length 0!');
			}
			if($keywords_count === 0) {
				ReTidy::warning('Keywords conversion failed!');
			}
		}
		if($found_creator) {
			if(strlen($creator) === 0) {
				ReTidy::warning('Creator of length 0!');
			}
			if($creator_count === 0) {
				ReTidy::warning('Creator conversion failed!');
			}
		}
		if($found_issued) {
			if(strlen($issued) === 0) {
				ReTidy::warning('Issued of length 0!');
			}
			if($issued_count === 0) {
				ReTidy::warning('Issued conversion failed!');
			}
		}
		if($found_modified) {
			if(strlen($modified) === 0) {
				ReTidy::warning('Modified of length 0!');
			}
			if($modified_count === 0) {
				ReTidy::warning('Modified conversion failed!');
			}
		}
		if($found_subject) {
			if(strlen($subject) === 0) {
				ReTidy::warning('Subject of length 0!');
			}
			if($subject_count === 0) {
				ReTidy::warning('Subject conversion failed!');
			}
		}
		if($found_breadcrumb) {
			if(strlen($breadcrumb) === 0) {
				ReTidy::warning('Breadcrumb of length 0!');
			}
			if($breadcrumb_count === 0) {
				ReTidy::warning('Breadcrumb conversion failed!');
			}
		}
		if(strlen($h1) === 0) {
			ReTidy::warning('h1 of length 0!');
		}
		if($h1_count === 0) {
			ReTidy::warning('h1 conversion failed!');
		}
		if(strlen($content) === 0) {
			ReTidy::warning('Content of length 0!');
		}
		if($content_count === 0) {
			ReTidy::warning('Content conversion failed!');
		}
		if($found_date_modified) {
			if(strlen($date_modified) === 0) {
				$this->logMsg('<span style="color: orange;">Date modified of length 0!');
			}
			if($date_modified_count === 0) {
				ReTidy::warning('Date modified conversion failed!');
			}
		}
		$this->logMsg("=== templateCode End ===");
		
		return true;
	}
	
	function templatePPSC() {
		
		if(preg_match('/<title>(.*?)<\/title>/is', $this->code, $title_matches) !== 1) { print("Did not find a title for this page.");exit(0); }
		if(preg_match('/<meta name="description" content="([^"]*?)"/is', $this->code, $description_matches) !== 1) { print("Did not find a description for this page.");exit(0); }
		if(preg_match('/<meta name="keywords" content="([^"]*?)"/is', $this->code, $keywords_matches) !== 1) { print("Did not find a keywords for this page.");exit(0); }
		if(preg_match('/<meta name="dc\.creator" content="([^"]*?)"/is', $this->code, $creator_matches) !== 1) { print("Did not find a creator for this page.");exit(0); }
		
		//if(preg_match('/<meta name="dc\.date\.created" content="([^"]*?)"/is', $this->code, $issued_matches) === 0) { print("Did not find a issued for this page.");exit(0); }
		if(preg_match('/<meta name="dcterms\.issued" scheme="W3CDTF" content="([^"]*?)"/is', $this->code, $issued_matches) !== 1) { 
			if(preg_match('/<meta name="dc\.date\.created" content="([^"]*?)"/is', $this->code, $issued_matches) !== 1) { print("Did not find a issued for this page.");exit(0); }
		}
		if(preg_match('/<meta name="dcterms\.modified" scheme="W3CDTF" content="([^"]*?)"/is', $this->code, $modified_matches) !== 1) { 
			if(preg_match('/<meta name="dc\.date\.modified" content="([^"]*?)"/is', $this->code, $modified_matches) !== 1) { print("Did not find a modified for this page.");exit(0); }
		}
		if(preg_match('/<meta name="dc\.subject" scheme="[gccore]*?" content="([^"]*?)"/is', $this->code, $subject_matches) !== 1) { print("Did not find a subject for this page.");exit(0); }
		if(preg_match('/<p class="breadcrumb">\s*(.*?)\s*<\/p>/is', $this->code, $breadcrumb_matches) !== 1) { print("Did not find a breadcrumb for this page.");exit(0); }
		/*if(preg_match('/<[ph1-6]+[^<>]*?>\s*<a[^<>]*? id="cont"[^<>]*?>\s*(<!--[^<>]*?-->\s*){0,1}(.*?)\s*(<!--[^<>]*?-->\s*){0,1}<\/a>\s*<\/[ph1-6]+>/is', $this->code, $h1_matches) !== 1) { print("Did not find a h1 for this page.");exit(0); }*/
		//if(preg_match('/<div class="center">\s*(.*?)\s*<\/div>\s*<!-- InstanceEndEditable -->\s*(<!-- CONTENT ENDS \| FIN DU CONTENU -->|<!-- FIN DU CONTENU \| CONTENT ENDS -->)/is', $this->code, $content_matches) !== 1) {
			// then do some more work since the content strlen may be greater than 64kb...
			if(preg_match('/<div class="center[^"]*?">\s*/is', $this->code, $h1_long_matches, PREG_OFFSET_CAPTURE) !== 1) {
				print("Did not find a content for this page2.");exit(0);
			}
			$begin_offset = $h1_long_matches[0][1] + strlen($h1_long_matches[0][0]);
			if(preg_match('/<\/div>\s*<!-- InstanceEndEditable -->\s*(<!-- CONTENT ENDS \| FIN DU CONTENU -->|<!-- FIN DU CONTENU \| CONTENT ENDS -->)/is', $this->code, $content_long_matches, PREG_OFFSET_CAPTURE) !== 1) {
				print("Did not find a content for this page3.");exit(0);
			}
			$end_offset = $content_long_matches[0][1];
			$content = substr($this->code, $begin_offset, $end_offset - $begin_offset);
			if(preg_match('/<p class="hdg01"[^<>]*?>\s*(<[^<>]+?>\s*){0,}(<!--[^<>]*?-->\s*){0,1}(.*?)\s*(<!--[^<>]*?-->\s*){0,1}(<[^<>]+?>\s*){0,}<\/p>/is', $content, $h1_matches) !== 1) { 
				if(preg_match('/<h1[^<>]*?>\s*<a[^<>]*? id="cont"[^<>]*?>\s*(<!--[^<>]*?-->\s*){0,1}(.*?)\s*(<!--[^<>]*?-->\s*){0,1}<\/a>\s*<\/h1>/is', $content, $h1_matches) !== 1) {
					var_dump($content);
					var_dump($h1_matches);
					print("Did not find a h1 for this page.");exit(0); 
				} else {
					$h1 = $h1_matches[2];
				}
			} else {
				$h1 = $h1_matches[3];
			}
			$content = str_replace($h1_matches[0], '', $content);
		//} else {
		//	$content = $content_matches[4];
		//}
		if(preg_match('/<span class="date">(.*?)<\/span>/is', $this->code, $date_modified_matches) !== 1) { print("Did not find a date_modified for this page.");exit(0); }
		
		$title = $title_matches[1];
		$description = $description_matches[1];
		$keywords = $keywords_matches[1];
		$creator = $creator_matches[1];
		$issued = $issued_matches[1];
		$modified = $modified_matches[1];
		$subject = $subject_matches[1];
		$breadcrumb = $breadcrumb_matches[1];
		
		
		$date_modified = $date_modified_matches[1];
		
		if(strpos($breadcrumb, "<li") !== false) {
			// do fancy breadcrumb stuff
			$new_breadcrumb = "<ol>
";
			//var_dump($breadcrumb);
			if(preg_match_all('/<li[^<>]*?>(.*?)<\/li>/is', $breadcrumb, $breadcrumb_items_matches) === 0) { print("Did not find a breadcrumb_items for this page.");exit(0); }
			$size = sizeof($breadcrumb_items_matches[0]);
			$counter = $size - 1;
			foreach($breadcrumb_items_matches as $breadcrumb_index => $breadcrumb_value) {
				if($counter === 0) {
					$new_breadcrumb .= '<li>' . $breadcrumb_items_matches[1][$breadcrumb_index] . '</li>
';
				} else {
					if(preg_match('/<a[^<>]*?>(.*?)<\/a>/is', $breadcrumb_items_matches[1][$breadcrumb_index], $link_text_matches) === 0) { print("Did not find a link_text for this page.");exit(0); }
					if(preg_match('/ href="([^"]*?)"/is', $breadcrumb_items_matches[1][$breadcrumb_index], $href_matches) === 0) { print("Did not find a href for this page.");exit(0); }
					if(preg_match('/ title="([^"]*?)"/is', $breadcrumb_items_matches[1][$breadcrumb_index], $link_title_matches) === 0) { print("Did not find a link_title for this page.");exit(0); }
					$new_breadcrumb .= '<li><a rel="';
					$up_counter = $counter;
					$up_string = "";
					while($up_counter > 0) {
						$up_string .= 'up ';
						$up_counter--;
					}
					$up_string = substr($up_string, 0, strlen($up_string) - 1);
					$new_breadcrumb .= $up_string;
					$new_breadcrumb .= ' href="' . $href_matches[1] . '"';
					$new_breadcrumb .= ' title="' . $link_title_matches[1] . '">';
					$new_breadcrumb .= $link_text_matches[1] . '</a>&nbsp;&gt;</li>
';
				}
				$counter--;
			}
			
			$new_breadcrumb = "</ol>
";
		} else {
			// do fancy breadcrumb stuff
			$new_breadcrumb = "<ol>
";
			//var_dump($breadcrumb);
			$breadcrumb_items = explode('&gt;', $breadcrumb);
			$size = sizeof($breadcrumb_items);
			if($size === 1) {
				//print("Only one breadcrumb item found; this may be wrong.");exit(0);
			}
			$counter = $size - 1;
			//var_dump($breadcrumb_items);
			foreach($breadcrumb_items as $breadcrumb_index => $breadcrumb_value) {
				//var_dump($breadcrumb_value);
				/*if($counter === 0) {
					$new_breadcrumb .= '<li>' . $breadcrumb_items[$breadcrumb_index] . '</li>
';
				} else {*/
					$is_linked = true;
					if(preg_match('/<a[^<>]*?>(.*?)<\/a>/is', $breadcrumb_items[$breadcrumb_index], $link_text_matches) === 0) { $is_linked = false; }
					if(!$is_linked) {
						if($counter === 0) {
							$new_breadcrumb .= '<li>' . ReTidy::trim_nbsp($breadcrumb_items[$breadcrumb_index]) . '</li>
';
						} else {
							$new_breadcrumb .= '<li>' . ReTidy::trim_nbsp($breadcrumb_items[$breadcrumb_index]) . '&nbsp;&gt;</li>
';
						}
						$counter--;
						continue;
					}
					if(preg_match('/ href="([^"]*?)"/is', $breadcrumb_items[$breadcrumb_index], $href_matches) === 0) { print("Did not find a href for this page.");exit(0); }
					$found_link_title = true;
					if(preg_match('/ title="([^"]*?)"/is', $breadcrumb_items[$breadcrumb_index], $link_title_matches) === 0) { $found_link_title = false; }
					if($counter > 0) {
						$new_breadcrumb .= '<li><a rel="';
						$up_counter = $counter;
						$up_string = "";
						while($up_counter > 0) {
							$up_string .= 'up ';
							$up_counter--;
						}
						$up_string = substr($up_string, 0, strlen($up_string) - 1);
						$new_breadcrumb .= $up_string;
						$new_breadcrumb .= '" href="' . $href_matches[1] . '"';
					} else {
						$new_breadcrumb .= '<li><a href="' . $href_matches[1] . '"';
					}
					if($found_link_title) {
						$new_breadcrumb .= ' title="' . $link_title_matches[1] . '">';
					} else {
						$new_breadcrumb .= '>';
					}
					if($counter === 0) {
						$new_breadcrumb .= ReTidy::trim_nbsp($link_text_matches[1]) . '</a></li>
';
					} else {
						$new_breadcrumb .= ReTidy::trim_nbsp($link_text_matches[1]) . '</a>&nbsp;&gt;</li>
';
					}
				//}
				$counter--;
			}
			
			$new_breadcrumb .= "</ol>
";		
		}
		var_dump($new_breadcrumb);

		if($this->language === "french") {
			$this->code = file_get_contents('Templates' . DS . 'PPSC' . DS . 'wet-fra.html');
		} else {
			$this->code = file_get_contents('Templates' . DS . 'PPSC' . DS . 'wet-eng.html');
		}
		$this->code = str_replace('{title}', $title, $this->code);
		$this->code = str_replace('{description}', $description, $this->code);
		$this->code = str_replace('{keywords}', $keywords, $this->code);
		$this->code = str_replace('{creator}', $creator, $this->code);
		$this->code = str_replace('{issued}', $issued, $this->code);
		$this->code = str_replace('{modified}', $modified, $this->code);
		$this->code = str_replace('{subject}', $subject, $this->code);
		$this->code = str_replace('{breadcrumb}', $new_breadcrumb, $this->code);
		$this->code = str_replace('{h1}', $h1, $this->code);
		$this->code = str_replace('{content}', $content, $this->code);
		$this->code = str_replace('{date_modified}', $date_modified, $this->code);

	}
	
	function templateMPCC() {
		
		if(preg_match('/<title>(.*?)<\/title>/is', $this->code, $title_matches) === 0) { print("Did not find a title for this page.");exit(0); }
		if(preg_match('/<meta name="description" content="([^"]*?)"/is', $this->code, $description_matches) === 0) { print("Did not find a description for this page.");exit(0); }
		if(preg_match('/<meta name="keywords" content="([^"]*?)"/is', $this->code, $keywords_matches) === 0) { print("Did not find a keywords for this page.");exit(0); }
		if(preg_match('/<meta name="dc\.creator" content="([^"]*?)"/is', $this->code, $creator_matches) === 0) { print("Did not find a creator for this page.");exit(0); }
		
		//if(preg_match('/<meta name="dc\.date\.created" content="([^"]*?)"/is', $this->code, $issued_matches) === 0) { print("Did not find a issued for this page.");exit(0); }
		if(preg_match('/<meta name="dcterms\.issued" scheme="W3CDTF" content="([^"]*?)"/is', $this->code, $issued_matches) === 0) { 
			if(preg_match('/<meta name="dc\.date\.created" content="([^"]*?)"/is', $this->code, $issued_matches) === 0) { print("Did not find a issued for this page.");exit(0); }
		}
		
		
		if(preg_match('/<meta name="dcterms\.modified" scheme="W3CDTF" content="([^"]*?)"/is', $this->code, $modified_matches) === 0) { 
			if(preg_match('/<meta name="dc\.date\.modified" content="([^"]*?)"/is', $this->code, $modified_matches) === 0) { print("Did not find a modified for this page.");exit(0); }
		}
		if(preg_match('/<meta name="dc\.subject" scheme="[gcmpcc]*?" content="([^"]*?)"/is', $this->code, $subject_matches) === 0) { print("Did not find a subject for this page.");exit(0); }
		if(preg_match('/<p class="breadcrumb">\s*(.*?)\s*<\/p>/is', $this->code, $breadcrumb_matches) === 0) { print("Did not find a breadcrumb for this page.");exit(0); }
		if(preg_match('/<h1>\s*<a name="cont" id="cont">\s*<!--[^<>]*?-->\s*(.*?)\s*<!--[^<>]*?-->\s*<\/a>\s*<\/h1>/is', $this->code, $h1_matches) === 0) { print("Did not find a h1 for this page.");exit(0); }
		if(preg_match('/<\/a>\s*<\/h1>(.*?)\s*<\/div>\s*<\/div>\s*<!--[^<>]*?-->/is', $this->code, $content_matches) === 0) { print("Did not find a content for this page.");exit(0); }
		if(preg_match('/<span class="date">(.*?)<\/span>/is', $this->code, $date_modified_matches) === 0) { print("Did not find a date_modified for this page.");exit(0); }
		
		$title = $title_matches[1];
		$description = $description_matches[1];
		$keywords = $keywords_matches[1];
		$creator = $creator_matches[1];
		$issued = $issued_matches[1];
		$modified = $modified_matches[1];
		$subject = $subject_matches[1];
		$breadcrumb = $breadcrumb_matches[1];
		$h1 = $h1_matches[1];
		$content = $content_matches[1];
		$date_modified = $date_modified_matches[1];
		
		if(strpos($breadcrumb, "<li") !== false) {
			// do fancy breadcrumb stuff
			$new_breadcrumb = "<ol>
";
			//var_dump($breadcrumb);
			if(preg_match_all('/<li[^<>]*?>(.*?)<\/li>/is', $breadcrumb, $breadcrumb_items_matches) === 0) { print("Did not find a breadcrumb_items for this page.");exit(0); }
			$size = sizeof($breadcrumb_items_matches[0]);
			$counter = $size - 1;
			foreach($breadcrumb_items_matches as $breadcrumb_index => $breadcrumb_value) {
				if($counter === 0) {
					$new_breadcrumb .= '<li>' . $breadcrumb_items_matches[1][$breadcrumb_index] . '</li>
';
				} else {
					if(preg_match('/<a[^<>]*?>(.*?)<\/a>/is', $breadcrumb_items_matches[1][$breadcrumb_index], $link_text_matches) === 0) { print("Did not find a link_text for this page.");exit(0); }
					if(preg_match('/ href="([^"]*?)"/is', $breadcrumb_items_matches[1][$breadcrumb_index], $href_matches) === 0) { print("Did not find a href for this page.");exit(0); }
					if(preg_match('/ title="([^"]*?)"/is', $breadcrumb_items_matches[1][$breadcrumb_index], $link_title_matches) === 0) { print("Did not find a link_title for this page.");exit(0); }
					$new_breadcrumb .= '<li><a rel="';
					$up_counter = $counter;
					$up_string = "";
					while($up_counter > 0) {
						$up_string .= 'up ';
						$up_counter--;
					}
					$up_string = substr($up_string, 0, strlen($up_string) - 1);
					$new_breadcrumb .= $up_string;
					$new_breadcrumb .= ' href="' . $href_matches[1] . '"';
					$new_breadcrumb .= ' title="' . $link_title_matches[1] . '">';
					$new_breadcrumb .= $link_text_matches[1] . '</a>&nbsp;&gt;</li>
';
				}
				$counter--;
			}
			
			$new_breadcrumb = "</ol>
";
		} else {
			// do fancy breadcrumb stuff
			$new_breadcrumb = "<ol>
";
			//var_dump($breadcrumb);
			$breadcrumb_items = explode('&gt;', $breadcrumb);
			$size = sizeof($breadcrumb_items);
			if($size === 1) {
				print("Only one breadcrumb item found; this may be wrong.");exit(0);
			}
			$counter = $size - 1;
			//var_dump($breadcrumb_items);
			foreach($breadcrumb_items as $breadcrumb_index => $breadcrumb_value) {
				//var_dump($breadcrumb_value);
				/*if($counter === 0) {
					$new_breadcrumb .= '<li>' . $breadcrumb_items[$breadcrumb_index] . '</li>
';
				} else {*/
					$is_linked = true;
					if(preg_match('/<a[^<>]*?>(.*?)<\/a>/is', $breadcrumb_items[$breadcrumb_index], $link_text_matches) === 0) { $is_linked = false; }
					if(!$is_linked) {
						if($counter === 0) {
							$new_breadcrumb .= '<li>' . ReTidy::trim_nbsp($breadcrumb_items[$breadcrumb_index]) . '</li>
';
						} else {
							$new_breadcrumb .= '<li>' . ReTidy::trim_nbsp($breadcrumb_items[$breadcrumb_index]) . '&nbsp;&gt;</li>
';
						}
						$counter--;
						continue;
					}
					if(preg_match('/ href="([^"]*?)"/is', $breadcrumb_items[$breadcrumb_index], $href_matches) === 0) { print("Did not find a href for this page.");exit(0); }
					$found_link_title = true;
					if(preg_match('/ title="([^"]*?)"/is', $breadcrumb_items[$breadcrumb_index], $link_title_matches) === 0) { $found_link_title = false; }
					if($counter > 0) {
						$new_breadcrumb .= '<li><a rel="';
						$up_counter = $counter;
						$up_string = "";
						while($up_counter > 0) {
							$up_string .= 'up ';
							$up_counter--;
						}
						$up_string = substr($up_string, 0, strlen($up_string) - 1);
						$new_breadcrumb .= $up_string;
						$new_breadcrumb .= '" href="' . $href_matches[1] . '"';
					} else {
						$new_breadcrumb .= '<li><a href="' . $href_matches[1] . '"';
					}
					if($found_link_title) {
						$new_breadcrumb .= ' title="' . $link_title_matches[1] . '">';
					} else {
						$new_breadcrumb .= '>';
					}
					if($counter === 0) {
						$new_breadcrumb .= ReTidy::trim_nbsp($link_text_matches[1]) . '</a></li>
';
					} else {
						$new_breadcrumb .= ReTidy::trim_nbsp($link_text_matches[1]) . '</a>&nbsp;&gt;</li>
';
					}
				//}
				$counter--;
			}
			
			$new_breadcrumb .= "</ol>
";		
		}
		var_dump($new_breadcrumb);

		if($this->language === "french") {
			$this->code = file_get_contents('Templates' . DS . 'MPCC' . DS . 'wet-2col-fra.dwt');
		} else {
			$this->code = file_get_contents('Templates' . DS . 'MPCC' . DS . 'wet-2col-eng.dwt');
		}
		$this->code = str_replace('{title}', $title, $this->code);
		$this->code = str_replace('{description}', $description, $this->code);
		$this->code = str_replace('{keywords}', $keywords, $this->code);
		$this->code = str_replace('{creator}', $creator, $this->code);
		$this->code = str_replace('{issued}', $issued, $this->code);
		$this->code = str_replace('{modified}', $modified, $this->code);
		$this->code = str_replace('{subject}', $subject, $this->code);
		$this->code = str_replace('{breadcrumb}', $new_breadcrumb, $this->code);
		$this->code = str_replace('{h1}', $h1, $this->code);
		$this->code = str_replace('{content}', $content, $this->code);
		$this->code = str_replace('{date_modified}', $date_modified, $this->code);

	}
	
	function getBodyCode($code) {
		//print('code');var_dump($code);
		//if($code === false) {
		//	$pos_open_body = strpos($this->code, '<body');
		//	$pos_close_body = strpos($this->code, '</body>');
		//	$pos_end_open_body = strpos($this->code, '>', $pos_open_body);
		//	$bodyCode = substr($this->code, $pos_end_open_body + 1, $pos_close_body - ($pos_end_open_body + 1));
		//} else {
			$pos_open_body = strpos($code, '<body');
			$pos_close_body = strpos($code, '</body>');
			$pos_end_open_body = strpos($code, '>', $pos_open_body);
			//print('$pos_open_body');var_dump($pos_open_body);
			//print('$pos_close_body');var_dump($pos_close_body);
			//print('$pos_end_open_body');var_dump($pos_end_open_body);
			$bodyCode = substr($code, $pos_end_open_body + 1, $pos_close_body - ($pos_end_open_body + 1));
		//}
		return $bodyCode;
	}
	
	function detectCharset() {
		// simplistic function that should serve well enough; at least as well as many of the other unofficial functions
		//print('ascii strlen: ');var_dump(mb_strlen($this->code, 'ascii'));
		//print('utf-8 strlen: ');var_dump(mb_strlen($this->code, 'utf-8'));
		//exit(0);
		if(mb_strlen($this->code, 'ascii') !== mb_strlen($this->code, 'utf-8')) {
			return 'utf-8';
		} else {
			//return 'ascii';
			return 'iso-8859-1';
		}
	}
	
	function updateEncoding($encoding = false) {
		if($encoding === false) {
			$encoding = ReTidy::find_charset();
		}
		if($encoding === false) {
			if(ReTidy::detectCharset() === 'utf-8') {
				//$this->config['htmltidy']['input-encoding'] = "utf8";
				//$this->config['htmltidy']['output-encoding'] = "utf8";
				//$this->config['encoding'] = "utf-8";
				mb_internal_encoding("utf-8");
			} else {
				//$this->config['htmltidy']['input-encoding'] = "latin1";
				//$this->config['htmltidy']['output-encoding'] = "latin1";
				//$this->config['encoding'] = "iso-8859-1";
				mb_internal_encoding("iso-8859-1");
			}
		} else {
			include("charsets.php");
			$encoding = strtolower($encoding);
			$tidy_charset = $tidy_charsets_lower[$encoding];
			if(strlen($tidy_charset) > 0) {
				//$this->config['htmltidy']['input-encoding'] = $tidy_charset;
				//$this->config['htmltidy']['output-encoding'] = $tidy_charset;
				//$this->config['encoding'] = $encoding;
				mb_internal_encoding($encoding);
			} else {
				print("Unable to determine the mapping from the character encoding '$encoding' to a tidy character encoding... Error number 38990297980");
				return false;
			}
		}
		return true;
	}

	function cleanCode() {
		if(!$this->code || !$this->config) {
			$this->logMsg(self::$lang['cleanCode_noinit']);
			return false;
		}
		$this->timer_start = self::getmicrotime();
		$this->logMsg((string)$this);

		if(is_callable('mb_internal_encoding')) {
			/*$old_iencoding = mb_internal_encoding();
			// get the encoding from the file allowing overrides from the config file
			$result = preg_match('/<meta http\-equiv=[\'"]{0,1}Content\-Type[\'"]{0,1} content="text\/html;\s*charset=\s*([^"]*)\s*"/is', $this->code, $encoding_matches);
			$encoding = strtolower($encoding_matches[1]);
			if(isset($this->config['encoding'])) {
				mb_internal_encoding($this->config['encoding']);
			} else {
				if($result === 1) {
					$this->config['encoding'] = $encoding;
					mb_internal_encoding($encoding);
				} else {
					$this->config['encoding'] = "iso-8859-1";
					mb_internal_encoding("iso-8859-1");
				}
			}*/
			mb_internal_encoding("utf-8");
		}

		if(isset($this->config['strip_tags']) && (count($this->config['strip_tags']) > 1 || (count($this->config['strip_tags']) == 1 && !isset($this->config['strip_tags']['*']))))
			$this->config['strip_child_tags'] = true;
		else
			$this->config['strip_child_tags'] = false;

		if(isset($this->config['add_toc']) && $this->config['add_toc'])
			$this->config['fix_headings'] = true;
			
		// properties
		$qtext = '[^\\x0d\\x22\\x5c\\x80-\\xff]';
		$dtext = '[^\\x0d\\x5b-\\x5d\\x80-\\xff]';
		$atom = '[^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+';
		$quoted_pair = '\\x5c[\\x00-\\x7f]';
		$domain_literal = "\\x5b($dtext|$quoted_pair)*\\x5d";
		$quoted_string = "\\x22($qtext|$quoted_pair)*\\x22";
		$domain_ref = $atom;
		$sub_domain = "($domain_ref|$domain_literal)";
		$word = "($atom|$quoted_string)";
		$domain = "$sub_domain(\\x2e$sub_domain)*";
		$local_part = "$word(\\x2e$word)*";
		$addr_spec = "$local_part\\x40$domain";

		$this->an_email = $addr_spec;
		// also consider: \b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b
		// although there probably is no need to.
		//print("an email:" . $this->an_email . "<br>\r\n");
		
		$this->a_postal_code = "[A-Z][0-9][A-Z] [0-9][A-Z][0-9]";
		$this->a_phone_number = "1*(([\(\-\. ]{0,2})([0-9]{3})([\)\-\. ]{1,2}))*([0-9]{3})([\-\. ]{1})([0-9]{4})";
		
		$this->anchor_text_array = array('section', 'chp', 'chapter');
		
		// not tested
		//$this->a_uri = "(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?";
		// I say we need a better one, like that we have for email.
		
		// (RFC2396)
		
		//$this->order_indicator_regex = '((&[\w#0-9]+;)|([0-9]{1,8}[\.\)\,]+)|([0-9]{1,8}[\.\)\,]([0-9]{1,8}[\.\)\,]?)*)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^aiy©\*]))(\s|&nbsp;|&#160;)';
		//$this->order_indicator_regex_without_exceptions = '((&[\w#0-9]+;)|([0-9]{1,8}[\.\)\,]+)|([0-9]{1,8}[\.\)\,]([0-9]{1,8}[\.\)\,]?)*)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^aiy]))(\s|&nbsp;|&#160;)';
		//$this->order_indicator_regex = '((&[\w#0-9]+;)|([0-9]{1,8}[\.\)\,]+)|(([0-9]{1,2}[\.\)\,])+([0-9]{1,2}[\.\)\,]?)?)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^\w©\*\$\s]{1}))(\s|&nbsp;|&#160;)';
		//$this->order_indicator_regex_without_exceptions = '((&[\w#0-9]+;)|([0-9]{1,8}[\.\)\,]+)|(([0-9]{1,2}[\.\)\,])+([0-9]{1,2}[\.\)\,]?)?)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^aiy\s]{1}))(\s|&nbsp;|&#160;)';
		//$this->order_indicator_regex = '((&[\w#0-9]+;)|([0-9]{1,8}[\.\)\,]+)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^\w©\*\$\s]{1}))(\s|&nbsp;|&#160;)';
		$this->order_indicator_regex = '((&[\w#0-9]+;)|([0-9]{1,8}[\.\)\,]+)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^\w©\*\$\s&]{1,2}))(\s|&nbsp;|&#160;)';
		$this->order_indicator_regex_without_exceptions = '((&[\w#0-9]+;)|([0-9]{1,8}[\.\)\,]+)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^aiy\s&]{1,2}))(\s|&nbsp;|&#160;)';
		$this->order_indicator_regex_with_complex_number = '((&[\w#0-9]+;)|(([0-9]{1,8}[\.\)\,]+){1,}[0-9]{0,8})|([0-9]{1,8}[\.\)\,]+)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^\w©\*\$\s&]{1,2}))(\s|&nbsp;|&#160;)';
		$this->order_indicator_regex_with_complex_number_without_space = '((&[\w#0-9]+;)|(([0-9]{1,8}[\.\)\,]+){1,}[0-9]{0,8})|([0-9]{1,8}[\.\)\,]+)|([ivxlc]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([^\w©\*\$\s&]{1,2}))';
		// this without space one was changed to accomodate order indicators with brackets on both sides of the order indicator; maybe the others should be as well...
		// on the last bullet type in this one we are allowing letters whereas on the others we are not; I am not sure if this is optimal
		$this->order_indicator_regex_with_complex_number_case_sensitive = '((&[\w#0-9]+;)|(([0-9]{1,8}[\.\)\,]+){1,}[0-9]{0,8})|([0-9]{1,8}[\.\)\,]+)|([ivxlc]{1,8}[\.\)\,]+)|([IVXLC]{1,8}[\.\)\,]+)|([a-z]{1,3}[\.\)\,]+)|([A-Z]{1,3}[\.\)\,]+)|([^©\*\$\s]{1}))(\s|&nbsp;|&#160;)';
		
		$this->array_order_indicator_types = array(
		2 => "bullet",
		3 => "number",
		//4 => "complex number",
		4 => "roman_numeral",
		5 => "letter",
		6 => "bullet",
		);
		
		$this->array_order_indicator_types_with_complex_number = array(
		2 => "bullet",
		3 => "complex number",
		5 => "number",
		6 => "roman_numeral",
		7 => "letter",
		8 => "bullet",
		);
		
		$this->array_order_indicator_types_with_complex_number_case_sensitive = array(
		2 => "bullet",
		3 => "complex number",
		5 => "number",
		6 => "lower roman",
		7 => "upper roman",
		8 => "lower letter",
		9 => "upper letter",
		10 => "bullet",
		);
		
		$this->styleAgnosticCharacters = '\s,~`!\(\)\-=\+\{\}\[\]\\\|:;"\'<>,\.\?\/'; // see 'combine_inline_chars' in the awebitor profile.
		
		$this->spaceRegex = '\s|' . chr(32) . '|&nbsp;|&#160;|&#xa0;|&#xA0;';
		$this->nonBreakingSpaceRegex = '&nbsp;|&#160;|&#xa0;|&#xA0;';
		$this->spaceOrTag = '((<[^<>]+>)|(' . $this->spaceRegex . '))+';
		$this->tagname_regex = '[\w\-:]+';
		$this->attributename_regex = '[\w\-:]+';
		
		//$this->a_word = utf8_decode('[\wéàçêèô]{1,}');
		//$this->a_letter = utf8_decode('[\wéàçêèô]');
		
		$this->a_word = '[\wéàçêèô]{1,}';
		$this->a_letter = '[\wéàçêèô]';
		
		$this->dashes_array = array(
		'-',
		'‐',	'&#8208;',	'&#x2010;',
		'‑',	'&#8209;',	'&#x2011;',
		'‒',	'&#8210;',	'&#x2012;',
		'–',	'&#8211;',	'&#x2013;',	'&ndash;',
		'—',	'&#8212;',	'&#x2014;',	'&mdash;',
		'―',	'&#8213;',	'&#x2015;',
		);
		
		/*
		" 	" 	&#34; 	&#x22; 	&quot;
		« 	« 	&#171; 	&#xab; 	&laquo;
		» 	» 	&#187; 	&#xbb; 	&raquo;
		‘ 	‘ 	&#8216; 	&#x2018; 	&lsquo;
		’ 	’ 	&#8217; 	&#x2019; 	&rsquo;
		‚ 	‚ 	&#8218; 	&#x201a; 	&sbquo;
		“ 	“ 	&#8220; 	&#x201c; 	&ldquo;
		” 	” 	&#8221; 	&#x201d; 	&rdquo;
		„ 	„ 	&#8222; 	&#x201e; 	&bdquo;
		‹ 	‹ 	&#8249; 	&#x2039; 	&lsaquo;
		› 	› 	&#8250; 	&#x203a; 	&rsaquo;
		*/
		
		//$this->leftSingleQuotes = '‘|&#8216;|&#x2018;|&lsquo;|‹|&#8249;|&#x2039;|&lsaquo;';
		//$this->rightSingleQuotes = '’|&#8217;|&#x2019;|&rsquo;|‚|&#8218;|&#x201a;|&sbquo;|›|&#8250;|&#x203a;|&rsaquo;';
		//$this->leftDoubleQuotes = '"|&#34;|&#x22;|&quot;|«|&#171;|&#xab;|&laquo;|“|&#8220;|&#x201c;|&ldquo;';
		//$this->rightDoubleQuotes = '"|&#34;|&#x22;|&quot;|»|&#187;|&#xbb;|&raquo;|”|&#8221;|&#x201d;|&rdquo;|„|&#8222;|&#x201e;|&bdquo;';
		
		$this->leftDoubleQuotes = '"|&#34;|&#x22;|&quot;|&#171;|&#xab;|&laquo;|&#8220;|&#x201c;|&#x201C;|&ldquo;|XXX9o9NewQuotesEntityXXX#349o9XXX|XXX9o9NewQuotesEntityXXX#x229o9XXX|XXX9o9NewQuotesEntityXXXquot9o9XXX|XXX9o9NewQuotesEntityXXX#1719o9XXX|XXX9o9NewQuotesEntityXXX#xab9o9XXX|XXX9o9NewQuotesEntityXXXlaquo9o9XXX|XXX9o9NewQuotesEntityXXX#82209o9XXX|XXX9o9NewQuotesEntityXXX#x201c9o9XXX|XXX9o9NewQuotesEntityXXXldquo9o9XXX|«|“';
		$this->rightDoubleQuotes = '"|&#34;|&#x22;|&quot;|&#187;|&#xbb;|&raquo;|&#8221;|&#x201d;|&#x201D;|&rdquo;|&#8222;|&#x201e;|&#x201E;|&bdquo;|XXX9o9NewQuotesEntityXXX#349o9XXX|XXX9o9NewQuotesEntityXXX#x229o9XXX|XXX9o9NewQuotesEntityXXXquot9o9XXX|XXX9o9NewQuotesEntityXXX#1879o9XXX|XXX9o9NewQuotesEntityXXX#xbb9o9XXX|XXX9o9NewQuotesEntityXXXraquo9o9XXX|XXX9o9NewQuotesEntityXXX#82219o9XXX|XXX9o9NewQuotesEntityXXX#x201d9o9XXX|XXX9o9NewQuotesEntityXXXrdquo9o9XXX|XXX9o9NewQuotesEntityXXX#82229o9XXX|XXX9o9NewQuotesEntityXXX#x201e9o9XXX|XXX9o9NewQuotesEntityXXXbdquo9o9XXX|»|”|„';
		
		//$this->frenchLeftDoubleQuotes = '"|&#34;|&#x22;|&quot;|«|&#171;|&#xab;|&laquo;';
		//$this->frenchRightDoubleQuotes = '"|&#34;|&#x22;|&quot;|»|&#187;|&#xbb;|&raquo;';
		//$this->englishLeftDoubleQuotes = '"|&#34;|&#x22;|&quot;|“|&#8220;|&#x201c;|&ldquo;';
		//$this->englishRightDoubleQuotes = '"|&#34;|&#x22;|&quot;|”|&#8221;|&#x201d;|&rdquo;|„|&#8222;|&#x201e;|&bdquo;';
		
		$this->leftSingleQuotes = "'|&#39;|&#x27;|&apos;|&#8216;|&#x2018;|&lsquo;|&#8249;|&#x2039;|&lsaquo;|XXX9o9NewQuotesEntityXXX#39;|XXX9o9NewQuotesEntityXXX#x27;|XXX9o9NewQuotesEntityXXXapos;|XXX9o9NewQuotesEntityXXX#8216;|XXX9o9NewQuotesEntityXXX#x2018;|XXX9o9NewQuotesEntityXXXlsquo;|XXX9o9NewQuotesEntityXXX#8249;|XXX9o9NewQuotesEntityXXX#x2039;|XXX9o9NewQuotesEntityXXXlsaquo;|‘|‹";
		$this->rightSingleQuotes = "'|&#39;|&#x27;|&apos;|&#8217;|&#x2019;|&rsquo;|&#8218;|&#x201a;|&#x201A;|&sbquo;|&#8250;|&#x203a;|&#x203A;|&rsaquo;|XXX9o9NewQuotesEntityXXX#399o9XXX|XXX9o9NewQuotesEntityXXX#x279o9XXX|XXX9o9NewQuotesEntityXXXapos9o9XXX|XXX9o9NewQuotesEntityXXX#82179o9XXX|XXX9o9NewQuotesEntityXXX#x20199o9XXX|XXX9o9NewQuotesEntityXXXrsquo9o9XXX|XXX9o9NewQuotesEntityXXX#82189o9XXX|XXX9o9NewQuotesEntityXXX#x201a9o9XXX|XXX9o9NewQuotesEntityXXXsbquo9o9XXX|XXX9o9NewQuotesEntityXXX#82509o9XXX|XXX9o9NewQuotesEntityXXX#x203a9o9XXX|XXX9o9NewQuotesEntityXXXrsaquo9o9XXX|’|‚|›";
		
		$this->singleQuotes = "'|&#39;|&#x27;|&apos;|&#8216;|&#x2018;|&lsquo;|&#8249;|&#x2039;|&lsaquo;|&#8217;|&#x2019;|&rsquo;|&#8218;|&#x201a;|&#x201A;|&sbquo;|&#8250;|&#x203a;|&#x203A;|&rsaquo;|XXX9o9NewQuotesEntityXXX#399o9XXX|XXX9o9NewQuotesEntityXXX#x279o9XXX|XXX9o9NewQuotesEntityXXXapos9o9XXX|XXX9o9NewQuotesEntityXXX#82169o9XXX|XXX9o9NewQuotesEntityXXX#x20189o9XXX|XXX9o9NewQuotesEntityXXXlsquo9o9XXX|XXX9o9NewQuotesEntityXXX#82499o9XXX|XXX9o9NewQuotesEntityXXX#x20399o9XXX|XXX9o9NewQuotesEntityXXXlsaquo9o9XXX|XXX9o9NewQuotesEntityXXX#82179o9XXX|XXX9o9NewQuotesEntityXXX#x20199o9XXX|XXX9o9NewQuotesEntityXXXrsquo9o9XXX|XXX9o9NewQuotesEntityXXX#82189o9XXX|XXX9o9NewQuotesEntityXXX#x201a9o9XXX|XXX9o9NewQuotesEntityXXXsbquo9o9XXX|XXX9o9NewQuotesEntityXXX#82509o9XXX|XXX9o9NewQuotesEntityXXX#x203a9o9XXX|XXX9o9NewQuotesEntityXXXrsaquo9o9XXX|‘|‹|’|‚|›";
		
		//$this->frenchLeftSingleQuotes = "'|&#39;|&#x27;|&apos;|‘|&#8216;|&#x2018;|&lsquo;";
		//$this->frenchRightSingleQuotes = "'|&#39;|&#x27;|&apos;|’|&#8217;|&#x2019;|&rsquo;|‚|&#8218;|&#x201a;|&sbquo;";
		//$this->englishLeftSingleQuotes = "'|&#39;|&#x27;|&apos;|‘|&#8216;|&#x2018;|&lsquo;";
		//$this->englishRightSingleQuotes = "'|&#39;|&#x27;|&apos;|’|&#8217;|&#x2019;|&rsquo;|‚|&#8218;|&#x201a;|&sbquo;";
		
		$this->leftQuotes = $this->leftDoubleQuotes . "|" . $this->leftSingleQuotes;
		$this->rightQuotes = $this->rightDoubleQuotes . "|" . $this->rightSingleQuotes;

		if(isset($this->config['pre_internal_templating_macro'])) {
			foreach($this->config['pre_internal_templating_macro'] as $index => $method) {
				$this->method = $method;
				$l = 0; // method loop count
				if(!isset($this->config['loop_max'])) {
					$this->config['loop_max'] = 10;
				}
				if(!isset($this->config['loop_methods'])) {
					$this->config['loop_methods'] = array();
				}
				if(!isset($this->config['important_methods'])) {
					$this->config['important_methods'] = array('tidy_code', 'dom_init', 'dom_save');
				}
				// if it is a DOM function but the DOM is not loaded, then load it before running the function.
				if(stripos($method, "dom_init") !== 0 && strlen($method) !== 8) {
					if(stripos($method, "dom_") === 0 && $this->dom === false) {
						ReTidy::dom_init();
					}
				}
				// likewise, if it is a non-DOM function and the DOM is still loaded, then unload it.
				if(stripos($method, "dom_save") !== 0 && strlen($method) !== 8) {
					if(stripos($method, "dom_") !== 0 && $this->dom !== false) {
						ReTidy::dom_save();
					} elseif($index === sizeof($this->config['macro'])-1 && $this->dom !== false) {
						ReTidy::dom_save();
					}
				}
				while($l < $this->config['loop_max']) {
					$res = call_user_func(array($this, $method));
					if(!$res && in_array($method, $this->config['important_methods'])) {
						return false;
					}
					if($res && in_array($method, $this->config['loop_methods'])) {
						$l++;
					} else {
						break;
					}
				}
			}
		}
		//var_dump(ReTidy::getmicrotime());
		//print('$this->code after pre_internal_templating_macro: ');ReTidy::var_dump_full($this->code);exit(0);
		if(isset($this->config['macro'])) {
			//print('here384506060<br>');
			ReTidy::detemplate();
			//print('here384506061<br>');
			
			//var_dump(ReTidy::getmicrotime());
			foreach($this->config['macro'] as $index => $method) {
				$this->method = $method;
				$l = 0; // method loop count
				if(!isset($this->config['loop_max'])) {
					$this->config['loop_max'] = 10;
				}
				if(!isset($this->config['loop_methods'])) {
					$this->config['loop_methods'] = array();
				}
				if(!isset($this->config['important_methods'])) {
					$this->config['important_methods'] = array('tidy_code', 'dom_init', 'dom_save');
				}
				// if it is a DOM function but the DOM is not loaded, then load it before running the function.
				if(stripos($method, "dom_init") !== 0 && strlen($method) !== 8) {
					if(stripos($method, "dom_") === 0 && $this->dom === false) {
						ReTidy::dom_init();
					}
				}
				// likewise, if it is a non-DOM function and the DOM is still loaded, then unload it.
				if(stripos($method, "dom_save") !== 0 && strlen($method) !== 8) {
					if(stripos($method, "dom_") !== 0 && $this->dom !== false) {
						ReTidy::dom_save();
					} elseif($index === sizeof($this->config['macro'])-1 && $this->dom !== false) {
						ReTidy::dom_save();
					}
				}
				while($l < $this->config['loop_max']) {
					$res = call_user_func(array($this, $method));
					if(!$res && in_array($method, $this->config['important_methods'])) {
						print('<span style="color: red;">important_method "' . $method . '" returned false</span><br>');
						return false;
					}
					if($res && in_array($method, $this->config['loop_methods'])) {
						$l++;
					} else {
						break;
					}
				}
			}
			//var_dump(ReTidy::getmicrotime());
			/*if(isset($old_iencoding) && is_callable('mb_internal_encoding'))
				mb_internal_encoding($old_iencoding);
			*/
			//print($this->code);
			//print('here384506062<br>');
			ReTidy::retemplate();
			//print('here384506063<br>');
		}
		if(isset($this->config['post_internal_templating_macro'])) {
			foreach($this->config['post_internal_templating_macro'] as $index => $method) {
				$this->method = $method;
				$l = 0; // method loop count
				if(!isset($this->config['loop_max'])) {
					$this->config['loop_max'] = 10;
				}
				if(!isset($this->config['loop_methods'])) {
					$this->config['loop_methods'] = array();
				}
				if(!isset($this->config['important_methods'])) {
					$this->config['important_methods'] = array('tidy_code', 'dom_init', 'dom_save');
				}
				// if it is a DOM function but the DOM is not loaded, then load it before running the function.
				if(stripos($method, "dom_init") !== 0 && strlen($method) !== 8) {
					if(stripos($method, "dom_") === 0 && $this->dom === false) {
						ReTidy::dom_init();
					}
				}
				// likewise, if it is a non-DOM function and the DOM is still loaded, then unload it.
				if(stripos($method, "dom_save") !== 0 && strlen($method) !== 8) {
					if(stripos($method, "dom_") !== 0 && $this->dom !== false) {
						ReTidy::dom_save();
					} elseif($index === sizeof($this->config['macro'])-1 && $this->dom !== false) {
						ReTidy::dom_save();
					}
				}
				while($l < $this->config['loop_max']) {
					$res = call_user_func(array($this, $method));
					if(!$res && in_array($method, $this->config['important_methods'])) {
						return false;
					}
					if($res && in_array($method, $this->config['loop_methods'])) {
						$l++;
					} else {
						break;
					}
				}
			}
		}
		//exit(0);
		if($this->config['retidy_mark']) {
			$this->code = str_replace('</head>', '<meta name="generator" content="' . (string)$this . "\" />\n</head>", $this->code);
		}
		//var_dump(ReTidy::getmicrotime());
		//exit(0);
		$this->timer_end = self::getmicrotime();
		$this->timer_total = $this->timer_end - $this->timer_start;
		return true;
	}

	protected function roundDigits($value, $precision = 0) {
		// force the same number of digits after the decimal (for consistency)
		$value = (string)round($value, $precision);
		$strpos = strpos($value, ".");
		$decimal_part = "";
		if($strpos !== false) {
			$decimal_part = substr($value, $strpos+1);
		}
		if(strlen($decimal_part) === 0) {
			if($precision > 0) {
				$value .= ".";
				$count4040 = 0;
				while($count4040 < $precision) {
					$value .= "0";
					$count4040++;
				}
			}
		} else {
			while(strlen($decimal_part) < $precision) {
				$decimal_part .= "0";
				$value .= "0";
			}
		}
		return $value;
	}
	
	protected function logMsg($msg) {
		$prefix = '';
		if($this->timer_start) {
			//$time = round(self::getmicrotime() - $this->timer_start, 2);
			$time = ReTidy::roundDigits(self::getmicrotime() - $this->timer_start, 2);
			$prefix = "[$time] ";
		}
		$msg = $prefix . $msg . "<br>\r\n";
		//$msg = iconv($this->config['encoding'], "UTF-8", $msg);
		//$msg = iconv($this->config['encoding'], "iso-8859-1", $msg);
		//$msg = utf8_encode($msg);
		print($msg);
		flush();
		return $msg;
	}
	
	protected function logWarningMsg($msg) {
		$prefix = '';
		if($this->timer_start) {
			$time = ReTidy::roundDigits(self::getmicrotime() - $this->timer_start, 2);
			$prefix = "[$time] ";
		}
		$msg = $prefix . '<span style="color: orange">' . $msg . '</span>' . "<br>\r\n";
		print($msg);
		flush();
		return $msg;
	}
	
	protected function logErrorMsg($msg) {
		$prefix = '';
		if($this->timer_start) {
			$time = ReTidy::roundDigits(self::getmicrotime() - $this->timer_start, 2);
			$prefix = "[$time] ";
		}
		$msg = $prefix . '<span style="color: red">' . $msg . '</span>' . "<br>\r\n";
		print($msg);
		flush();
		return $msg;
	}
	
	protected function logMsgIf($msg, $ct) {
		if($ct > 0) {
			$this->total_changes += $ct;
			$this->logMsg($msg . " " . $ct);
		}
	}	

	public static function getmicrotime() {
		list($usec, $sec) = explode(' ', microtime());
		return ((float)$usec + (float)$sec);
	}
	
	protected function dom_init() {
		
		/*
		print "PHP_VERSION:      ".PHP_VERSION."\n";
		print "LIBXML_VERSION:   ".LIBXML_VERSION."\n";
		print "LIBXML_NOXMLDECL: ".LIBXML_NOXMLDECL."\n";

		$dom = new DomDocument();
		$dom->loadXML("<foo />");

		# This should work but doesn't.

		print "DOMDocument doesn't honor LIBXML_NOXMLDECL:\n";
		print $dom->saveXML(null,LIBXML_NOXMLDECL);

		# This works, and will still work after the above is fixed.

		print "Forwards compatible workaround:\n";
		$lines = explode("\n", $dom->saveXML(null, LIBXML_NOXMLDECL), 2);
		if(!preg_match('/^\<\?xml/', $lines[0]))
			print $lines[0];
		print $lines[1];
		*/
		
		// severe hack!
		//$this->code = preg_replace(' xmlns="[^"]*?"', '', $this->code);
		/*print('XXX9o9beep19o9XXX
');
		print('$this->code in dom_init: ' . $this->code);
		print('
XXX9o9beep29o9XXX
');*/
		if($this->dom) {
			return $this->xpath_init();
		}
		if($this->xpath) {
			$this->xpath = false;
		}
		// HTML5?
		if($this->config['use_local_DTD']) {
			preg_match('/(<!DOCTYPE\s*html\s*PUBLIC\s*"[^"]*"\s*")([^"]*)(">)/is', $this->code, $matches);
			$this->temp_DTD_file = $matches[2];
			$this->code = str_replace($matches[1] . $matches[2] . $matches[3], $matches[1] . DTD::getDTDfile() . $matches[3], $this->code);
		}
		//print('this->config[\'encoding\'] 1: ');var_dump($this->config['encoding']);
		//ReTidy::updateEncoding();
		//ReTidy::convert_to($this->config['encoding']);
		//print('this->config[\'encoding\'] 2: ');var_dump($this->config['encoding']);
		//$this->dom = new DOMDocument('1.0', $this->config['encoding']);
		//$this->dom = new DOMDocument('1.0', $this->config['encoding']);
		$this->dom = new DOMDocument('1.0', 'utf-8');
		if(!$this->dom) {
			$this->logMsg(self::$lang['dom_init_error']);
			return false;
		}
		$this->dom->resolveExternals = true;
		
		//$this->dom->preserveWhiteSpace = false;
		if(!$this->dom->loadXML($this->code)) {
			$this->dom->loadHTML($this->code);
		}
		//$this->dom->formatOutput = true;
		//if(isset($this->config['encoding'])) {
		//	// this should be set by cleanCode
		//	$this->dom->encoding = $this->config['encoding'];
		//} else {
		//	$this->dom->encoding = 'iso-8859-1';
		//}

		$this->logMsg('dom_init = true');
		return $this->xpath_init();
	}

	protected function xpath_init() {
		if(!$this->dom) {
			return false;
		}
		if($this->xpath) {
			return true;
		}
		$this->xpath = new DOMXPath($this->dom);
		if(!$this->xpath) {
			$this->logMsg(self::$lang['dom_xpath_warning']);
			return false;
		} else {
			$this->xpath->registerNamespace('h', self::$xhtmlns);
		}
		$this->logMsg('xpath_init = true');
		return true;
	}

	protected function dom_save() {
		if(!$this->dom) {
			$this->logMsg(self::$lang['dom_save_error']);
			return false;
		}
		$this->code = $this->dom->saveXML();
		$this->dom = false;
		$this->logMsg("=== DOM saved === ");
		//$this->post_dom_strip_xmlns();
		if($this->config['use_local_DTD']) {
			$this->code = preg_replace('/(<!DOCTYPE\s*html\s*PUBLIC\s*"[^"]*"\s*")' . ReTidy::preg_escape(DTD::getDTDfile()) . '(">)/is', '$1' . $this->temp_DTD_file . '$2', $this->code);
		}
		if(strpos($this->code, '<?xml') !== false) {
			preg_match('/<?xml[^<>]*?>/is', $this->code, $xml_matches, PREG_OFFSET_CAPTURE);
			$xml_declaration_position_end = $xml_matches[0][1] + strlen($xml_matches[0][0]);
			$this->code = substr($this->code, $xml_declaration_position_end + 1);
		}
		//var_dump($this->code);exit(0);
		return true;
	}

	protected function post_dom_strip_xmlns () {
		$c = 0;
		$this->code = preg_replace('/\s(xmlns|xmlns:default)\s*=\s*("|\')(.*?)\2/i', ' ', $this->code, -1, $c);
		$this->logMsgIf("post_dom_strip_xmlns", $c);
		return true;
	}	

	protected function post_dom() {
		ReTidy::post_dom_div_me();
		ReTidy::post_dom_brme();
		ReTidy::post_dom_stripme();
		ReTidy::post_dom_newtag();  // could take over for post_dom_div_me (at least)
		ReTidy::non_styled_spans();
		ReTidy::encode_for_DOM_all();
	}
	
	protected function post_dom_newtag() {
		if(strpos($this->code, 'newtag="') !== false) {
			$H = 0;
			$array_replacesH = array();
			preg_match_all('/<(\w*)([^<>]*) newtag="([^"]*)"([^<>]*)>/is', $this->code, $matchesH, PREG_OFFSET_CAPTURE);
			if(sizeof($matchesH[0]) > 0) {
				foreach($matchesH[0] as $index => $value) {
					$match = $value[0];
					$offset = $value[1];
					$old_tag = $matchesH[1][$index][0];
					$new_tag = $matchesH[3][$index][0];
					if($old_tag === $new_tag) {
						$array_replacesH[] = array($match, '<' . $old_tag . $matchesH[2][$index][0] . $matchesH[4][$index][0] . '>');
						continue;
					}
					$object_string = OM::getOString($this->code, "<" . $old_tag, "</" . $old_tag . ">", $offset);
					$replace_string = ReTidy::str_replace_first("<" . $old_tag, "<" . $new_tag, $object_string); // only the first one
					$replace_string = ReTidy::str_replace_last('</' . $old_tag . '>', '</' . $new_tag . '>', $replace_string); // only the last one
					$replace_string = ReTidy::str_replace_first(' newtag="' . $new_tag . '"', '', $replace_string); // only the first one
					$array_replacesH[] = array($object_string, $replace_string);
				}
				usort($array_replacesH, "sortByLengthOfFirst");
				foreach($array_replacesH as $index => $value) {
					$search = $value[0];
					$replace = $value[1];	
					$this->code = str_replace($search, $replace, $this->code, $h);
					$H += $h;
				}
				$this->logMsgIf("post_dom_newtag", $H);
			}
		}
		if(strpos($this->code, "XXX9o9NewTag") !== false) {
			$this->code = preg_replace('/XXX9o9NewTagBeginXXX(.*?)9o9XXX/is', '<$1>', $this->code, -1, $g1);
			$this->code = preg_replace('/XXX9o9NewTagEndXXX(.*?)9o9XXX/is', '</$1>', $this->code, -1, $g2);
			$this->logMsgIf("post_dom_newtag", $g1 + $g2);
		}
		if(strpos($this->code, "XXX9o9NewEntityXXX") !== false) {
			$this->code = preg_replace('/XXX9o9NewEntityXXX(.*?)9o9XXX/is', '&$1;', $this->code, -1, $i1);
			$this->logMsgIf("post_dom_newtag", $i1);
		}
	}
	
	function DOM_strip_node($node) {
		$firstChild = $node->firstChild;
		$lastChild = $node->lastChild;
		if($firstChild->nodeName === "#text") {
			$firstChild->nodeValue = "XXX9o9StripOpeningTag9o9XXX" . $firstChild->nodeValue;
		} else {
			$node->insertBefore(new DOMText("XXX9o9StripOpeningTag9o9XXX"), $firstChild);
		}
		if($lastChild->nodeName === "#text") {
			$lastChild->nodeValue = $lastChild->nodeValue . "XXX9o9StripClosingTag9o9XXX";
		} else {
			$node->appendChild(new DOMText("XXX9o9StripClosingTag9o9XXX"));
		}
	}
	
	protected function post_dom_stripme() {
		$arrayDOMCleanup = array(
		' class="XXX9o9stripme9o9XXX"' => '',
		' style="XXX9o9stripme9o9XXX"' => '',
		' class="stripme"' => '',
		' style="stripme"' => '',		
		' class=""' => '',
		' style=""' => '',
		);
		foreach($arrayDOMCleanup as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $e);
			$this->logMsgIf("post_dom_stripme [" . $search . "]", $e);
		}
		$arrayRegxDOMCleanup = array(
		'<th([^<>]*) tdme="y"([^<>]*)>(.*?)<\/th>' => '<td$1$2>$3</td>',
		' [\w]*="XXX9o9stripme9o9XXX"' => '',
		' [\w]*="stripme"' => '',		
		' style="[;\s]*"' => '',
		' style="(([;\s])|(XXX9o9stripme9o9XXX)|(stripme))*"' => '',
		' class="XXX9o9stripme9o9XXX[^"]*XXX9o9stripme9o9XXX"' => '',
		' style="XXX9o9stripme9o9XXX[^"]*XXX9o9stripme9o9XXX"' => '',
		'<\w*[^<>]*deleteme="y"[^<>]*\/>' => '',
		'<\w*[^<>]*stripme="y"[^<>]*\/>' => '',		
		);
		foreach($arrayRegxDOMCleanup as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $d);
			$this->logMsgIf("post_dom_stripme [" . $search . "]", $d);
		}
		// improved stripme processing to (hopefully) save a lot of time (2011-09-06)
		$open_count = -1;
		$close_count = -1;
		$better_stripme_changes_count = 0;
		while($open_count != 0 || $close_count != 0) {
			$this->code = preg_replace('/XXX9o9StripOpeningTag9o9XXX([^<>]*?)XXX9o9StripOpeningTag9o9XXX/is', 'XXX9o9StripOpeningTag9o9XXX$1', $this->code, -1, $open_count);
			$this->code = preg_replace('/XXX9o9StripClosingTag9o9XXX([^<>]*?)XXX9o9StripClosingTag9o9XXX/is', '$1XXX9o9StripClosingTag9o9XXX', $this->code, -1, $close_count);
			$better_stripme_changes_count += $open_count;
			$better_stripme_changes_count += $close_count;
		}
		$this->code = preg_replace('/<[^<>]+>[^<>]*?XXX9o9StripOpeningTag9o9XXX/is', '', $this->code, -1, $open_count2);
		$this->code = preg_replace('/XXX9o9StripClosingTag9o9XXX[^<>]*?<[^<>]+>/is', '', $this->code, -1, $close_count2);
		$better_stripme_changes_count += $open_count2;
		$better_stripme_changes_count += $close_count2;
		$this->logMsgIf("post_dom_stripme (better stripme)", $better_stripme_changes_count);
		if(strpos($this->code, 'deleteme="y"') !== false) {
			$H = 0;
			$array_replacesH = array();
			preg_match_all('/<(\w*)[^<>]*deleteme="y"[^<>]*>/is', $this->code, $matchesH, PREG_OFFSET_CAPTURE);
			foreach($matchesH[0] as $index => $value) {
				$match = $value[0];
				$offset = $value[1];
				$object_string = OM::getOString($this->code, "<" . $matchesH[1][$index][0], "</" . $matchesH[1][$index][0] . ">", $offset);
				$array_replacesH[] = array($object_string, '');
			}
			usort($array_replacesH, "sortByLengthOfFirst");
			foreach($array_replacesH as $index => $value) {
				$search = $value[0];
				$replace = $value[1];	
				$this->code = str_replace($search, $replace, $this->code, $h);
				$H += $h;
			}
			$this->logMsgIf("post_dom_stripme (deleteme)", $H);
		}
		if(strpos($this->code, 'stripme="y"') !== false) {
			$I = 0;
			$array_replacesI = array();
			preg_match_all('/<(\w*)[^<>]*stripme="y"[^<>]*>/is', $this->code, $matchesI, PREG_OFFSET_CAPTURE);
			foreach($matchesI[0] as $index => $value) {
				$match = $value[0];
				$offset = $value[1];
				$object_string = OM::getOString($this->code, "<" . $matchesI[1][$index][0], "</" . $matchesI[1][$index][0] . ">", $offset);
				$array_replacesI[] = array($object_string, substr($object_string, strlen($match), strlen($object_string)-strlen($match)-strlen("</" . $matchesI[1][$index][0] . ">")));
			}
			usort($array_replacesI, "sortByLengthOfFirst");
			foreach($array_replacesI as $index => $value) {
				$search = $value[0];
				$replace = $value[1];	
				$this->code = str_replace($search, $replace, $this->code, $i);
				$I += $i;
			}
			$this->logMsgIf("post_dom_stripme (stripme)", $I);
		}
		if(strpos($this->code, "XXX9o9DeleteNonTagsBegin9o9XXX") !== false) {
			$J = 0;
			$arrayOStrings = OM::getAllOStrings($this->code, "XXX9o9DeleteNonTagsBegin9o9XXX", "XXX9o9DeleteNonTagsEnd9o9XXX");
			foreach($arrayOStrings as $index => $value) {
				$tag_string = "";
				$Ostring = $value[0];
				preg_match_all('/<[^<>]*>/is', $Ostring, $tag_matches);
				foreach($tag_matches[0] as $tag) {
					$tag_string .= $tag;
				}
				$this->code = str_replace($Ostring, $tag_string, $this->code, $j);
				$J += $j;
			}
			$this->logMsgIf("post_dom_stripme (delete non tags)", $J);
		}
		if(strpos($this->code, "XXX9o9DeleteMeBegin9o9XXX") !== false) {
			$F = 0;
			$arrayOStrings = OM::getAllOStrings($this->code, "XXX9o9DeleteMeBegin9o9XXX", "XXX9o9DeleteMeEnd9o9XXX");
			foreach($arrayOStrings as $index => $value) {
				$Ostring = $value[0];
				$this->code = str_replace($Ostring, '', $this->code, $f);
				$F += $f;
			}
			$this->logMsgIf("post_dom_stripme (deleteme)", $F);
		}
		if(strpos($this->code, "XXX9o9StripMeBegin9o9XXX") !== false) {
			$G = 0;
			$arrayOStrings = OM::getAllOStrings($this->code, "XXX9o9StripMeBegin9o9XXX", "XXX9o9StripMeEnd9o9XXX");
			foreach($arrayOStrings as $index => $value) {
				$Ostring = $value[0];
				$this->code = preg_replace('/<(\w*)[^<>]*>' . ReTidy::preg_escape($Ostring) . '<\/\1>/is', substr($OString, 24, strlen($OString)-24-22), $this->code, -1, $g);
				$G += $g;
			}
			$this->logMsgIf("post_dom_stripme (stripme)", $G);
		}
		return true;
	}	
	
	protected function post_dom_brme() {
		$c = 0;
		if($this->config["brme"]) {
			$br_string = "";
			$br_count = $this->config["brme"];
			while($br_count > 0) {
				$br_string .= "<br />";
				$br_count--;
			}
		} else {
			$br_string = "<br /><br />";
		}
		$this->code = str_replace("XXX9o9br_me9o9XXX", $br_string, $this->code, $c);
		$this->logMsgIf("post_dom_brme", $c);
		return true;
	}
	
	protected function post_dom_div_me() {
		$c = $e = 0;
		if(strpos($this->code, 'divme="y"') !== false) {
			$I = 0;
			$array_replacesI = array();
			preg_match_all('/<(\w*)[^<>]*divme="y"[^<>]*>/is', $this->code, $matchesI, PREG_OFFSET_CAPTURE);
			foreach($matchesI[0] as $index => $value) {
				$match = $value[0];
				$offset = $value[1];
				$tag_name = $matchesI[1][$index][0];
				$object_string = OM::getOString($this->code, "<" . $matchesI[1][$index][0], "</" . $matchesI[1][$index][0] . ">", $offset);
				$replace = ReTidy::str_replace_first('<' . $tag_name, '<div', $object_string);
				$replace = ReTidy::str_replace_last('</' . $tag_name . '>', '</div>', $replace);
				$replace = ReTidy::str_replace_first(' divme="y"', '', $replace);
				$array_replacesI[] = array($object_string, $replace);
			}
			usort($array_replacesI, "sortByLengthOfFirst");
			foreach($array_replacesI as $index => $value) {
				$search = $value[0];
				$replace = $value[1];	
				//print('post_dom_div_me $search: ' . $search);
				//print('post_dom_div_me $replace: ' . $replace);
				$this->code = str_replace($search, $replace, $this->code, $i);
				$I += $i;
			}
			$this->logMsgIf('post_dom_divme (divme="y")', $I);
		}
		
		
		$LayoutTableArray = array(

		'<div([^>]*) colspan="[^"]*"([^>]*)>' => '<div$1$2>',
		'<div([^>]*) rowspan="[^"]*"([^>]*)>' => '<div$1$2>',
		'<div([^>]*) scope="[^"]*"([^>]*)>' => '<div$1$2>',
		//'<div([^>]*) width="600"([^>]*)>' => '<div$1 style="width:100%;"$2>',
		'<div([^>]*) width="600"([^>]*)>' => '<div$1$2>',		
		'<div([^>]*) border="0"([^>]*)>' => '<div$1$2>',
		'<div([^>]*) cellspacing="[^"]*"([^>]*)>' => '<div$1$2>',
		'<div([^>]*) cellpadding="[^"]*"([^>]*)>' => '<div$1$2>',
		  
		);
		
			
		$this->code = preg_replace('/<[\w]*([^>]*)>XXX9o9DivMeBegin9o9XXX/', '<div$1>', $this->code, -1, $c);
		/*
		$this->code = preg_replace('/<table([^>]*)>XXX9o9DivMeBegin9o9XXX/', '<div$1>', $this->code, -1, $c);
		$this->code = preg_replace('/<tr([^>]*)>XXX9o9DivMeBegin9o9XXX/', '<div$1 style="clear:both;">', $this->code, -1, $c);
		$this->code = preg_replace('/<td([^>]*)>XXX9o9DivMeBegin9o9XXX/', '<div$1 style="float:left;">', $this->code, -1, $c);
		$this->code = preg_replace('/<th([^>]*)>XXX9o9DivMeBegin9o9XXX/', '<div$1>', $this->code, -1, $c);
		$this->code = preg_replace('/<[\w]*([^>]*)>XXX9o9DivMeBegin9o9XXX/', '<div$1>', $this->code, -1, $c);
		*/
		$this->code = preg_replace('/XXX9o9DivMeEnd9o9XXX<\/([^>]*)>/', '</div>', $this->code, -1, $e);
		foreach($LayoutTableArray as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code);
		}
		//$this->logMsg("post_dom_div_me [" . $c + $e . "]");
		
		// sweep out class="layouttable"
		$this->code = str_replace(' class="layouttable"', '', $this->code);
		$this->code = preg_replace('/class="([^"]*)( *)layouttable([^"]*)"/', 'class="$1$3"', $this->code);
		$this->code = preg_replace('/ class="table_dimensionality_[123]"/', '', $this->code);
		$this->code = preg_replace('/class="([^"]*)( *)table_dimensionality_[123]([^"]*)"/', 'class="$1$3"', $this->code);		
		// sweep out class="alignTop" on <div>s
		$this->code = preg_replace('/<div([^<>]*) class="alignTop ([^"]*)"/is', '<div$1 class="$2"', $this->code);
		$this->code = preg_replace('/<div([^<>]*) class="([^"]*) alignTop([^"]*)"/is', '<div$1 class="$2$3"', $this->code);		
		$this->code = str_replace(' class=""', '', $this->code);
		return true;
	}	

	protected function post_dom_renametag ()
	{
		// this will not find the corresponding end tag in the case of nested tags.
		$c = 0;
		$regex = '/<([a-z0-9]+)([^>]*)\srenametag\s*=\s*("|\')([a-z0-9]+)\3([^>]*)>(.*?)<\/\1>/is';
		$this->code = preg_replace($regex, '<$4 $2 $5>$6</$4>', $this->code, -1, $c);
		$this->logMsgIf("post_dom_renametag", $c);

		return true;
	}
	
	protected function tidy_code() {
		/*ReTidy::updateEncoding();
		if(!isset($this->config['htmltidy_app']) // default
		|| $this->config['htmltidy_app'] == 'php') {
			return $this->htmltidy_php();
		} else {
			return $this->htmltidy_app();
		}
		*/
		//var_dump($this->code);
		//$this->code = ReTidy::tidyer_code($this->code);
		ReTidy::tidyer_code();
		//var_dump($this->code);
		return true; // since it's an "important method"
	}
	
	protected function pre_internal_templating_arbitrary_sweep() {
		// your code here...
		
		$total_count = 0;
		preg_match_all('/<(\w+) class="redacted">(.*?)<\/\1>/is', $this->code, $matches);
		foreach($matches[0] as $index => $value) {
			$text = ReTidy::tagless($matches[2][$index]);
			$replaced_text = preg_replace('/[^\s]/is', '&nbsp;', $text);
			$this->code = str_replace($value, '<' . $matches[1][$index] . ' class="redacted">' . $replaced_text . '</' . $matches[1][$index] . '>', $this->code, $count);
			$total_count += $count;
		}
		$this->logMsgIf('redactions non-breaking spaceified', $total_count);
		
		// french redacted text
		/*if($this->language === 'french') {
			$this->code = str_replace('<span class="redacted">[redacted&nbsp;text]</span>', '<span class="redacted">[texte&nbsp;rédigée]</span>', $this->code);
		}*/
		/*$this->code = preg_replace('/:<\/p>\s*<div class="indent-large">(.*?)<\/div>/is', ':</p>
<blockquote>
<p>$1</p>
</blockquote>', $this->code);*/

		// contracts over 10k <h1>s
		/*preg_match('/<h1 id="wb-cont">(.*?)<\/h1>/is', $this->code, $h1_matches);
		if($h1_matches[1] === 'Proactive Disclosure') {
			preg_match('/<h2>(.*?)<\/h2>/is', $this->code, $h2_matches, PREG_OFFSET_CAPTURE);
			if($h2_matches[1][0] === 'Contract over 10K Disclosure Report' || $h2_matches[1][0] === 'Contract over $10,000 Disclosure Report') {
				if(preg_match('/<strong>Reference number\s*:?\s*<\/strong>\s*:?\s*(.*?)<br \/>/is', $this->code, $reference_number_matches) &&
				preg_match('/<strong>Contract date\s*:?\s*<\/strong>\s*:?\s*(.*?)<br \/>/is', $this->code, $contract_date_matches)) {
					$this->code = substr($this->code, 0, $h2_matches[0][1]) . substr($this->code, $h2_matches[0][1] + strlen($h2_matches[0][0]));
					$this->code = preg_replace('/<h1 id="wb-cont">(.*?)<\/h1>/is', '<h1 id="wb-cont">' . $reference_number_matches[1] . ' &ndash; ' . $contract_date_matches[1] . '</h1>', $this->code);
					$this->logMsg('Fixed the heading on this "Contract over 10K Disclosure Report"');
				} else {
					ReTidy::warning('Failed to fix the heading on this "Contract over 10K Disclosure Report"');
				}
			}
		}
		if($h1_matches[1] === 'Divulgation proactive' || $h1_matches[1] === 'Proactive Disclosure') {
			preg_match('/<h2>(.*?)<\/h2>/is', $this->code, $h2_matches, PREG_OFFSET_CAPTURE);
			if($h2_matches[1][0] === 'Rapport sur la divulgation des marchés de plus de 10&nbsp;000&nbsp;$') {
				if(preg_match('/<strong>Numéro de référence\s*:?\s*<\/strong>\s*:?\s*(.*?)<br \/>/is', $this->code, $reference_number_matches) &&
				preg_match('/<strong>Date du contrat\s*:?\s*<\/strong>\s*:?\s*(.*?)<br \/>/is', $this->code, $contract_date_matches)) {
					$this->code = substr($this->code, 0, $h2_matches[0][1]) . substr($this->code, $h2_matches[0][1] + strlen($h2_matches[0][0]));
					$this->code = preg_replace('/<h1 id="wb-cont">(.*?)<\/h1>/is', '<h1 id="wb-cont">' . $reference_number_matches[1] . ' &ndash; ' . $contract_date_matches[1] . '</h1>', $this->code);
					$this->logMsg('Fixed the heading on this "Rapport sur la divulgation des marchés de plus de 10&nbsp;000&nbsp;$"');
				} else {
					ReTidy::warning('Failed to fix the heading on this "Rapport sur la divulgation des marchés de plus de 10&nbsp;000&nbsp;$"');
				}
			}
		}*/
		
		/*
		ReTidy::fix_supporting_file_references();
		*/
		
		// PPSC proactive disclosure <h1>s
		/*$this->code = preg_replace('/<h1 id="wb-cont">Position reclassifications<\/h1>\s*<h2>(.*?)<br \/>(.*?)<\/h2>\s*<h3>(.*?)<\/h3>/is', '<h1 id="wb-cont">$3 &ndash; $1</h1>
<h2>$2</h2>
', $this->code);
		$this->code = preg_replace('/<h1 id="wb-cont">Position reclassifications<\/h1>\s*<h2>(.*?)<\/h2>\s*<h3>(.*?)<\/h3>/is', '<h1 id="wb-cont">$2 &ndash; $1</h1>
', $this->code);*/
		/*$this->code = preg_replace('/<h1 id="wb-cont">Divulgation des reclassifications des postes<\/h1>\s*<h2>(.*?)<br \/>(.*?)<\/h2>\s*<h3>(.*?)<\/h3>/is', '<h1 id="wb-cont">$3 &ndash; $1</h1>
<h2>$2</h2>
', $this->code);
		$this->code = preg_replace('/<h1 id="wb-cont">Divulgation des reclassifications des postes<\/h1>\s*<h2>(.*?)<\/h2>\s*<h3>(.*?)<\/h3>/is', '<h1 id="wb-cont">$2 &ndash; $1</h1>
', $this->code);*/
		/*$this->code = preg_replace('/<h1 id="wb-cont">Travel and Hospitality Expenses<\/h1>\s*<h2>(.*?)<\/h2>\s*<h3>Travel Expenses – (.*?)<\/h3>/is', '<h1 id="wb-cont">$2</h1>
<h2>$1</h2>
<h3>Travel Expenses</h3>
', $this->code);
		$this->code = preg_replace('/<h1 id="wb-cont">Travel and Hospitality Expenses<\/h1>\s*<h2>(.*?)<\/h2>\s*<table>\s*<caption([^<>]*?)><strong>Travel Expenses – (.*?)<\/strong><\/caption>/is', '<h1 id="wb-cont">$3</h1>
<h2>$1</h2>
<table>
<caption$2><strong>Travel Expenses</strong></caption>
', $this->code);*/
		/*$this->code = preg_replace('/<h1 id="wb-cont">Rapports des frais de voyage et d\'acceuil<\/h1>\s*<h2>(.*?)<\/h2>\s*<h3>Dépenses de voyage - (.*?)<\/h3>/is', '<h1 id="wb-cont">$2</h1>
<h2>$1</h2>
<h3>Dépenses de voyage</h3>
', $this->code);
		$this->code = preg_replace('/<h1 id="wb-cont">Rapports des frais de voyage et d\'acceuil<\/h1>\s*<h2>(.*?)<\/h2>\s*<table>\s*<caption([^<>]*?)><strong>Dépenses de voyage - (.*?)<\/strong><\/caption>/is', '<h1 id="wb-cont">$3</h1>
<h2>$1</h2>
<table>
<caption$2><strong>Dépenses de voyage</strong></caption>
', $this->code);*/
		
		/*
		// reverse data cell column order
		preg_match_all('/<table[^<>]*?>(.*?)<\/table>/is', $this->code, $table_matches, PREG_OFFSET_CAPTURE);
		$counter = sizeof($table_matches[0]) - 1;
		while($counter > -1) {
			$initial_table_code = $table_code = $table_matches[0][$counter][0];
			$table_offset = $table_matches[0][$counter][1];
			preg_match_all('/<tr[^<>]*?>(.*?)<\/tr>/is', $table_code, $tr_matches, PREG_OFFSET_CAPTURE);
			$counter2 = sizeof($tr_matches[0]) - 1;
			while($counter2 > -1) {
				$initial_tr_code = $tr_code = $tr_matches[0][$counter2][0];
				$tr_offset = $tr_matches[0][$counter2][1];
				preg_match_all('/<td[^<>]*?>(.*?)<\/td>/is', $tr_code, $td_matches, PREG_OFFSET_CAPTURE);
				$counter3 = sizeof($td_matches[0]) - 1;
				while($counter3 > -1) {
					$td_code = $td_matches[0][$counter3][0];
					$td_offset = $td_matches[0][$counter3][1];
					$tr_code = substr($tr_code, 0, $td_offset) . $td_matches[0][sizeof($td_matches[0]) - 1 - $counter3][0] . substr($tr_code, $td_offset + strlen($td_code));
					$counter3--;
				}
				$counter2--;
				$this->code = str_replace($initial_tr_code, $tr_code, $this->code);
			}
			$counter--;
		}*/
		
		/*
		ReTidy::XHTML_to_HTML5();
		*/
		
		// convert intradocumental page navigation links to MPCC button style
		// too complicated
		/*<ul class="button-group">
<li>&lt;&nbsp;<a href="/01/1400/3700/2008-18/index-fra.aspx" class="button">Page précédente</a></li>
<li><a href="/01/1400/3700/2008-18/index-fra.aspx#toc" class="button">Table des matières</a></li>
<li><a href="/01/1400/3700/2008-18/part2-fra.aspx" class="button">Page suivante</a>&nbsp;&gt;</li>
</ul>*/
		//$array_containers = array('p', 'div');
		
		
	}
	
	protected function arbitrary_sweep() {
		// your code here...
	}
	
	protected function fix_supporting_file_references() {
		// this function could be made more generalized, but for now just worry about stuff like <link rel="stylesheet" href="../../../dist/grids/css/util-min.css" />
		preg_match_all('/<link([^<>]*?) href="([^"]*?)"([^<>]*?)\/>/is', $this->code, $link_matches);
		/*$counter = sizeof($link_matches[0]) - 1;
		while($counter > -1) {
			
			$counter--;
		}*/
		$array_replaces = array();
		foreach($link_matches[0] as $index => $value) {
			$href_content = $link_matches[2][$index];
			if($href_content[0] === '/' || strpos($href_content, 'http://') !== false) { // avoid root references and URLs
			
			} else {
				$relative_path = ReTidy::resolve_relative_path($href_content, $this->file);
				if(file_exists($relative_path)) {
					
				} else {
					$initial_href_content = $href_content;
					// first try looking closer
					$proper_reference = false;
					while(!$proper_reference && substr($href_content, 0, 3) === '../') {
						$href_content = substr($href_content, 3);
						$relative_path = ReTidy::resolve_relative_path($href_content, $this->file);
						if(file_exists($relative_path)) {
							$proper_reference = true;
							$array_replaces['href="' . $initial_href_content . '"'] = 'href="' . $href_content . '"';
							break;
						}
					}
					if(!$proper_reference) { // try looking farther
						$counter = 0;
						while(!$proper_reference && $counter < 10) {
							$href_content = '../' . $href_content;
							$relative_path = ReTidy::resolve_relative_path($href_content, $this->file);
							if(file_exists($relative_path)) {
								$proper_reference = true;
								$array_replaces['href="' . $initial_href_content . '"'] = 'href="' . $href_content . '"';
								break;
							}
							$counter++;
						}
					}
					if(!$proper_reference) { // give up or finish
						var_dump($this->file, $href_content, $relative_path);exit(0);
						print('<span style="color: red;">Could not fix broken reference in &lt;link&gt;: ' . $value . '</span>');exit(0);
					} else {
						$this->logMsg('Reference ' . htmlentities($value) . ' was fixed.');
					}
				}
			}
		}
		foreach($array_replaces as $index => $value) {
			$this->code = str_replace($index, $value, $this->code);
		}
	}
	
	protected function set_html_namespace() {
		if(ReTidy::is_HTML5()) {
			//print('here34859697807<br>');
			$this->html_namespace = '';
		} else {
			//print('here34859697808<br>');
			$this->html_namespace = 'h:'; // default
		}
	}
	
	protected function get_html_namespace() {
		if(!isset($this->html_namespace)) {
			ReTidy::set_html_namespace();
		}
		return $this->html_namespace;
	}
	
	protected function generate_tidyer_DOM() {
		$this->code = str_replace('&#10;', ' ', $this->code); // line feed
		$this->code = str_replace('&#13;', ' ', $this->code); // carriage return
		$this->code = str_replace('&#xa;', ' ', $this->code); // line feed
		$this->code = str_replace('&#xd;', ' ', $this->code); // carriage return
		$this->code = str_replace('&#xA;', ' ', $this->code); // line feed
		$this->code = str_replace('&#xD;', ' ', $this->code); // carriage return
		//0xC2 . 0xA0 multibyte non-breaking space?
		ReTidy::convert_to('utf-8');
		// simplest HTML parsing step; and a necessary one to be able to preserve idosyncrasies and not "overtidy"
		$offset = 0;
		$this->tidyer_DOM = array();
		$parsing_tag = false;
		$code_piece = '';
		//print('5054<br>');exit(0);
		while($offset < strlen($this->code)) {
			//print('5055<br>');
			if($parsing_tag) {
				//print('5056<br>');
				if($this->code[$offset] === '<') {
					ReTidy::warning('Tidy alert: invalid syntax; <code>' . htmlentities($code_piece) . '</code> will be treated as text (unexpected &lt;).');
					$this->tidyer_DOM[] = array(0, $code_piece);
					$code_piece = '';
				} elseif($this->code[$offset] === '>') {
					$this->tidyer_DOM[] = array(1, $code_piece . '>');
					$code_piece = '';
					$parsing_tag = false;
				} else {
					$code_piece .= $this->code[$offset];
				}
			} else {
				//print('5057<br>');
				if($this->code[$offset] === '<') {
					$this->tidyer_DOM[] = array(0, $code_piece);
					$offset++;
					if(substr($this->code, $offset, 8) === '![CDATA[') { // non-parsed character data
						//print('5058<br>');
						$offset += 8;
						$code_piece = '<![CDATA[';
						while($offset < strlen($this->code)) {
							//print('5059<br>');
							if(substr($this->code, $offset, 3) === ']]>') {
								//print('her3287394560845069<br>');
								$this->tidyer_DOM[] = array(1, array($code_piece . ']]>', false, 4, false));
								$code_piece = '';
								$offset += 3;
								continue 2;
							} else {
								$code_piece .= $this->code[$offset];
							}
							$offset++;
						}
						//print('###########' . $this->code . '#################');
						$this->logMsg('<span style="color: red;">Non-parsed character data was not properly terminated; <code>' . htmlentities($code_piece) . '</code>.</span>');exit(0);
					} elseif(substr($this->code, $offset, 3) === '!--') { // comment
						//print('5060<br>');
						//print(substr($this->code, $offset));
						$offset += 3;
						$code_piece = '<!--';
						while($offset < strlen($this->code)) {
							//print('5061<br>');
							if(substr($this->code, $offset, 3) === '-->') {
								//print('her3287394560845070<br>');
								//var_dump(array(1, array($code_piece, '', 5)));
								$this->tidyer_DOM[] = array(1, array($code_piece . '-->', false, 5, false));
								$code_piece = '';
								$offset += 3;
								continue 2;
							} else {
								$code_piece .= $this->code[$offset];
							}
							$offset++;
						}
						$this->logMsg('<span style="color: red;">Comment was not properly terminated; <code>' . htmlentities($code_piece) . '</code>.</span>');exit(0);
					} elseif($this->code[$offset] === '?') { // programming instruction
						//print('5062<br>');
						$offset++;
						$code_piece = '<?';
						while($offset < strlen($this->code)) {
							//print('5063<br>');
							if(substr($this->code, $offset, 2) === '?>') {
								//print('her3287394560845071<br>');
								$this->tidyer_DOM[] = array(1, array($code_piece . '?>', false, 6, false));
								$code_piece = '';
								$offset += 2;
								continue 2;
							} else {
								$code_piece .= $this->code[$offset];
							}
							$offset++;
						}
						$this->logMsg('<span style="color: red;">Programming instruction was not properly terminated; <code>' . htmlentities($code_piece) . '</code>.</span>');exit(0);
					} elseif($this->code[$offset] === '%') { // ASP
						//print('5064<br>');//exit(0);
						print(substr($this->code, $offset));
						$offset++;
						$code_piece = '<%';
						while($offset < strlen($this->code)) {
							//print('5065<br>');
							if(substr($this->code, $offset, 2) === '%>') {
								//print('her3287394560845072<br>');
								//var_dump(array(1, array($code_piece, '', 7)));
								$this->tidyer_DOM[] = array(1, array($code_piece . '%>', false, 7, false));
								$code_piece = '';
								$offset += 2;
								continue 2;
							} else {
								$code_piece .= $this->code[$offset];
							}
							$offset++;
						}
						$this->logMsg('<span style="color: red;">ASP code was not properly terminated; <code>' . htmlentities($code_piece) . '</code>.</span>');exit(0);
					} else {
						//print('5066<br>');
						//var_dump($this->tidyer_DOM);
						$code_piece = '<';
						$parsing_tag = true;
						continue;
					}
				} elseif($this->code[$offset] === '>') {
					ReTidy::warning('Tidy alert: invalid syntax; <code>' . htmlentities($code_piece) . '</code> will be treated as text (unexpected &gt;).');
					$this->tidyer_DOM[] = array(0, $code_piece . '>');
					$code_piece = '';
				} else {
					$code_piece .= $this->code[$offset];
				}
			}
			$offset++;
		}
		// 2017-09-26
		if(strlen($code_piece) > 0) {
			$this->tidyer_DOM[] = array(0, $code_piece);	
		}
		//var_dump($this->tidyer_DOM);exit(0);
		// this is where we could have a tidyer_DOM without any changes to the code; although I don't know what purpose that would serve...
		
		//print('5067<br>');//exit(0);
		//print($this->code);
		//return;
		//var_dump($this->tidyer_DOM);exit(0);
		foreach($this->tidyer_DOM as $index => $value) {
			if($value[0] === 1) { // tag
				if($value[1][2] === 4) { // non-parsed character data
					continue;
				} elseif($value[1][2] === 5) { // comment
					continue;
				} elseif($value[1][2] === 6) { // programming instruction
					continue;
				} elseif($value[1][2] === 7) { // ASP
					continue;
				}
				$tag_array = array();
				$attributes_array = array();
				$tag_array[2] = 0; // default to an opening tag
				$offset = 1;
				$tag = $value[1];
				//var_dump($tag);
				$strlen_tag = strlen($tag);
				$parsed_tag_name = false;
				while($offset < $strlen_tag) {
					//print('here4068950697-80<br>');
					if($parsed_tag_name) {
						//print('here4068950697-81<br>');
						if($tag[$offset] === '>') {
							break;
						} elseif(substr($tag, $offset, 2) === '/>') {
							$tag_array[2] = 2;
							break;
						} else {
							preg_match('/\s*/is', $tag, $space_matches, PREG_OFFSET_CAPTURE, $offset);
							$space = $space_matches[0][0];
							$space_offset = $space_matches[0][1];
							$strlen_space = strlen($space);
							if($space_offset === $offset && $strlen_space > 0) {
								$offset += $strlen_space;
							}
							preg_match('/[\w\-:]+/is', $tag, $attribute_name_matches, PREG_OFFSET_CAPTURE, $offset); // notice that by including ':' we are confounding namespaces
							// here would be where to make attribute names lowercase
							$attribute_name = strtolower($attribute_name_matches[0][0]);
							$strlen_attribute_name = strlen($attribute_name);
							if($strlen_attribute_name > 0) { // to guard against space at the ends of tags
								$offset += $strlen_attribute_name;
								//var_dump($tag[$offset]);
								if($tag[$offset] === '=') {
									$offset++;
									if($tag[$offset] === '"') {
										$offset++;
										preg_match('/[^"]*/is', $tag, $attribute_value_matches, PREG_OFFSET_CAPTURE, $offset);
										$attribute_value = $attribute_value_matches[0][0];
										$strlen_attribute_value = strlen($attribute_value);
										if(strlen(trim($attribute_value)) > 0) { // only keep it if it's non-empty
											//$new_tag .= $attribute_name . '="' . ReTidy::clean_attribute_value_according_to_attribute_name_for_tidyer($attribute_value, $attribute_name) . '"';
											$attributes_array[] = array($attribute_name, ReTidy::clean_attribute_value_according_to_attribute_name_for_tidyer($attribute_value, $attribute_name));
										}
										$offset += $strlen_attribute_value;
										$offset++;
									} elseif($tag[$offset] === "'") {
										$offset++;
										preg_match("/[^']*/is", $tag, $attribute_value_matches, PREG_OFFSET_CAPTURE, $offset);
										$attribute_value = $attribute_value_matches[0][0];
										$strlen_attribute_value = strlen($attribute_value);
										if(strlen(trim($attribute_value)) > 0) { // only keep it if it's non-empty
											//$new_tag .= $attribute_name . '="' . ReTidy::clean_attribute_value_according_to_attribute_name_for_tidyer($attribute_value, $attribute_name) . '"';
											$attributes_array[] = array($attribute_name, ReTidy::clean_attribute_value_according_to_attribute_name_for_tidyer($attribute_value, $attribute_name));
										}
										$offset += $strlen_attribute_value;
										$offset++;
									} else { // undelimited attribute value
										preg_match("/[^\s<>]*/is", $tag, $attribute_value_matches, PREG_OFFSET_CAPTURE, $offset);
										$attribute_value = $attribute_value_matches[0][0];
										$strlen_attribute_value = strlen($attribute_value);
										if($strlen_attribute_value > 0) { // only keep it if it's non-empty
											//$new_tag .= $attribute_name . '="' . ReTidy::clean_attribute_value_according_to_attribute_name_for_tidyer($attribute_value, $attribute_name) . '"';
											$attributes_array[] = array($attribute_name, ReTidy::clean_attribute_value_according_to_attribute_name_for_tidyer($attribute_value, $attribute_name));
										}
										$offset += $strlen_attribute_value;
									}
								} else { // attribute with no attribute value
									if($attribute_name === 'nowrap') {
										//$new_tag .= 'nowrap="nowrap"';
										$attributes_array[] = array('nowrap', 'nowrap');
									} else {
										//$attributes_array[] = array($attribute_name, '');
										ReTidy::warning('found attribute with no attribute value: ' . $attribute_name . ' in tag ' . $tag . ' but how to handle it is not specified 2897497592');
									}
								}
							}
							//preg_match('/\s*/is', $tag, $space_after_attribute_matches, PREG_OFFSET_CAPTURE, $offset);
							//$space_after_attribute = $space_after_attribute_matches[0][0];
							//$strlen_space_after_attribute = strlen($space_after_attribute);
							//$offset += $strlen_space_after_attribute;
							//if($strlen_space_after_attribute > 0) {
							//	$new_tag .= ' ';
							//}
							continue;
						}
					} else {
						//print('here4068950697-82<br>');
						$parsed_tag_name = true;
						/*
						'!doctype' => 'parse_doctype',
						'?' => 'parse_php',
						'?php' => 'parse_php',
						'%' => 'parse_asp',
						'style' => 'parse_style',
						'script' => 'parse_script'
						*/
						
						// concerning these partial (very limited) parsings of special stuff like programming instructions and scripts from different language than HTML; it shouldn't be a problem as long as they do not 
						// contain reflexive code (for example a PHP string like ...... '[question-mark]>' (I can't actually write it because notepad++'s parser busts into comments to find ends of programming instructions apparently...)
						if(substr($tag, $offset, 8) === '!doctype' || substr($tag, $offset, 8) === '!DOCTYPE') {
							//print('here4068950697-83<br>');
							// could handle doctype; for now just keep it
							$tag_array = array($tag, '', 3);
							break;
						}/* elseif(substr($tag, $offset, 3) === '!--') { // comment
							// could handle comments; for now just keep them
							$tag_array = array($tag, '', 4);
							break;
						} elseif($tag[$offset] === '?') { // programming instruction
							// could handle programming instructions; for now just keep them
							$tag_array = array($tag, '', 5);
							break;
						} elseif($tag[$offset] === '%') { // ASP
							// could handle ASP; for now just keep it
							$tag_array = array($tag, '', 6);
							break;
						}*/ elseif($tag[$offset] === '/') { // end tag
							$offset++;
							$tag_array[2] = 1;
						}
						preg_match('/[\w\-]+/is', $tag, $tag_name_matches, PREG_OFFSET_CAPTURE, $offset);
						// here would be where to make tag names lowercase
						$tag_name = strtolower($tag_name_matches[0][0]);
						$strlen_tag_name = strlen($tag_name);
						$tag_array[0] = $tag_name;
						if(ReTidy::is_block_for_tidyer($tag_name)) {
							// mark it as block for future reference
							$tag_array[3] = true;
						}
						//$tag_name_offset = $tag_name_matches[0][1];
						//$new_tag .= $tag_name;
						/*if($strlen_tag_name == 0 || (!$parsing_end_tag && $tag_name_offset !== 1) || ($parsing_end_tag && $tag_name_offset !== 2)) {
							var_dump($strlen_tag_name, $parsing_end_tag, $tag_name_offset, $tag_name_offset);
							print('tag_name: ' . $tag_name . ' was problematically identified from tag: ' . $tag . ' 2897497591');exit(0);
						} else {*/
							$offset += $strlen_tag_name;
							continue;
						//}
						//print('here4068950697-84<br>');
					}
					$offset++;
				}
				// I suppose we could sort attributes as desired here
				//print('here4068950697-85<br>');
				$tag_array[1] = $attributes_array;
				$this->tidyer_DOM[$index] = array(1, $tag_array);
			}
		}
		return true;
	}
	
	protected function tidyer_code_named_entities() {
		$saved_character_entity_encoding_type = $this->config['character_entity_encoding_type'];
		$this->config['character_entity_encoding_type'] = 'named';
		ReTidy::tidyer_code();
		$this->config['character_entity_encoding_type'] = $saved_character_entity_encoding_type;
	}
	
	function repair_broken_character_encoding() {
		// for now this is a dumb function that just does striaght replaces. the mappings are not exhaustive.
		$array_replaces = array(
		// multibyte
		'&acirc;&amp;#x80;&amp;#x99;' => '&rsquo;',
		'&acirc;&amp;#x80;&amp;#x91;' => '-',
		'&acirc;&amp;#x80;&amp;#x93;' => '&ndash;',
		'&Acirc;<q>&laquo;' => '<q>&laquo;',
		'&Acirc;&nbsp;&raquo;</q>' => '&nbsp;&raquo;</q>',
		// single byte
		'&Atilde;&copy;' => 'é',
		'&Atilde;&amp;#x89;' => 'É',
		'&Atilde;&reg;' => 'î',
		'&Atilde;&sect;' => 'ç',
		'&Atilde;&amp;#x98;' => '&bull;',
		'&Atilde;&uml;' => 'è',
		'&Atilde;&acute;' => 'ô',
		'&Atilde;&nbsp;&raquo;' => 'û',
		'&Atilde;&ordf;' => 'ê',
		'&Atilde;&amp;#x87;' => '&Ccedil;',
		'&Atilde;&sup1;' => '&ugrave;',
		'&Atilde;&amp;#x80;' => '&Agrave;',
		'&Atilde;&cent;' => '&acirc;',
		'&Atilde;&amp;#x88;' => '&Egrave;',
		'&Atilde;<q>&laquo;&nbsp;' => 'ë',
		'&Aring;&amp;#x93;' => '&oelig;',
		'&thinsp;&acirc;&brvbar;' => '&hellip;',
		'.&Acirc; ' => '.&nbsp; ',
		'&amp;#x9C;&acirc;&amp;#x80;&brvbar;' => '&hellip;',
		'&acirc;&amp;#x80;&amp;#x9D;' => '&rdquo;',
		'&acirc;&amp;#x80;' => '&ldquo;',
		'&acirc;' => '&rsquo;',
		'&nbsp;? ' => ' à ',
		'&Aring;' => '&oelig;',
		);
		$total_count = 0;
		foreach($array_replaces as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $count);
			$total_count += $count;
		}
		$this->code = str_replace('&Atilde;', 'à', $this->code, $count); // have to be careful with this last step since what's being used to identify character encodinbg problems itself has to also be repaired
		$total_count += $count;
		ReTidy::warning_if($total_count . ' instances of broken character encoding repaired.', $total_count);
		if(strpos($this->code, '&Atilde;') !== false || strpos($this->code, 'Ã') !== false) {
			ReTidy::warning('&Atilde; was found so character encoding problems likely remain.');
		}
	}
	
	protected function tidyer_code() {
		//print('$this->code-1: ' . htmlentities($this->code) . '<br>');
		// before generating tidyer_DOM since this function shouldn't interact with HTML special characters and thus we don't need tidyer_DOM to be set up yet
		if($this->config['character_entity_encoding_type'] === 'decimal') {
			ReTidy::encode_character_entities();
		} elseif($this->config['character_entity_encoding_type'] === 'hexadecimal') {
			ReTidy::encode_character_entities();
		}
		//print('$this->code0: ' . htmlentities($this->code) . '<br>');
		//print('$this->tidyer_DOM0: ');var_dump($this->tidyer_DOM);
		ReTidy::generate_tidyer_DOM();
		//print('$this->code1: ' . htmlentities($this->code) . '<br>');
		//print('$this->tidyer_DOM1: ');var_dump($this->tidyer_DOM);
		// character entities
		if($this->config['character_entity_encoding_type'] === 'named') {
			foreach($this->tidyer_DOM as $index => $value) {
				if($value[0] === 0) { // text
					$new_text = html_entity_decode($value[1], ENT_QUOTES);
					$new_text = htmlentities($new_text, ENT_QUOTES);
					$this->tidyer_DOM[$index] = array(0, $new_text);
				}
			}
		} elseif($this->config['character_entity_encoding_type'] === 'decimal') {
			//foreach($this->tidyer_DOM as $index => $value) {
			//	if($value[0] === 0) { // text
			//		$new_text = htmlspecialchars_decode($value[1], ENT_QUOTES);
			//		$new_text = htmlspecialchars($new_text, ENT_QUOTES);
			//		$this->tidyer_DOM[$index] = array(0, $new_text);
			//	}
			//} // the intention was good but this should be unnecessary
		} elseif($this->config['character_entity_encoding_type'] === 'hexadecimal') {
			//foreach($this->tidyer_DOM as $index => $value) {
			//	if($value[0] === 0) { // text
			//		$new_text = $value[1];
			//	//	$new_text = htmlspecialchars_decode($value[1], ENT_QUOTES);
			//	//	$new_text = htmlspecialchars($new_text, ENT_QUOTES);
			//	//	$new_text = str_replace(0xC2 . 0xA0, '&#xa0;', $new_text); // non-breaking space character
			//	//	$new_text = str_replace(0xd, '', $new_text); // carriage return maybe
			//		$new_text = str_replace(0xC2, '', $new_text); // carriage return maybe
			//		$new_text = str_replace(0xA0, '', $new_text); // carriage return maybe
			//		$this->tidyer_DOM[$index] = array(0, $new_text);
			//	}
			//}
		} else { // default to raw characters
			//$charset = ReTidy::find_charset();
			if(ReTidy::is_HTML5()) {
				//print('her349650650605<br>');
				foreach($this->tidyer_DOM as $index => $value) {
					if($value[0] === 0) { // text
						$new_text = html_entity_decode($value[1], ENT_QUOTES);
						//$new_text = htmlspecialchars($new_text, ENT_QUOTES & ENT_HTML5, $charset);
						$new_text = htmlspecialchars($new_text, ENT_QUOTES & ENT_HTML5);
						$new_text = str_replace(' ', '&#160;', $new_text); // non-breaking space character
						$this->tidyer_DOM[$index] = array(0, $new_text);
					}
				}
			} elseif(ReTidy::is_XHTML()) {
				//print('her349650650606<br>');
				foreach($this->tidyer_DOM as $index => $value) {
					if($value[0] === 0) { // text
						$new_text = html_entity_decode($value[1], ENT_QUOTES);
						//$new_text = htmlspecialchars($new_text, ENT_QUOTES & ENT_XHTML, $charset);
						$new_text = htmlspecialchars($new_text, ENT_QUOTES & ENT_XHTML);
						$new_text = str_replace(' ', '&#160;', $new_text); // non-breaking space character
						$this->tidyer_DOM[$index] = array(0, $new_text);
					}
				}
			} elseif(ReTidy::is_XML()) {
				//print('her349650650607<br>');
				foreach($this->tidyer_DOM as $index => $value) {
					if($value[0] === 0) { // text
						$new_text = html_entity_decode($value[1], ENT_QUOTES);
						//$new_text = htmlspecialchars($new_text, ENT_QUOTES & ENT_XML1, $charset);
						$new_text = htmlspecialchars($new_text, ENT_QUOTES & ENT_XML1);
						$new_text = str_replace(' ', '&#160;', $new_text); // non-breaking space character
						$this->tidyer_DOM[$index] = array(0, $new_text);
					}
				}
			} else { // default to HTML4
				//print('her349650650608<br>');
				//var_dump($charset);
				foreach($this->tidyer_DOM as $index => $value) {
					if($value[0] === 0) { // text
						//var_dump($value[1]);
						$new_text = html_entity_decode($value[1], ENT_QUOTES);
						//var_dump($new_text);
						//$new_text = htmlspecialchars($new_text, ENT_QUOTES, $charset);
						$new_text = htmlspecialchars($new_text, ENT_QUOTES);
						//$new_text = htmlspecialchars($new_text);
						//var_dump($new_text);
						$new_text = str_replace(' ', '&#160;', $new_text); // non-breaking space character
						//var_dump($new_text);
						//print('---<br>');
						$this->tidyer_DOM[$index] = array(0, $new_text);
					}
				}
			}
		}
		//print('$this->code2: ' . htmlentities($this->code) . '<br>');
		//print('$this->tidyer_DOM2: ');var_dump($this->tidyer_DOM);
		// character entities in attributes
		if($this->config['character_entity_encoding_type'] === 'named') {
			foreach($this->tidyer_DOM as $index => $value) {
				if($value[0] === 1 && $value[1][2] < 3) { // normal tag
					//print('$value: ');var_dump($value);
					$tag_array = $value[1];
					$attributes_array = $tag_array[1];
					if(sizeof($attributes_array) > 0) {
						$changed_an_attribute_value = false;
						$new_attributes_array = array();
						foreach($attributes_array as $index3 => $value3) {
							$attribute_value = $value3[1];
							$new_attribute_value = html_entity_decode($attribute_value, ENT_QUOTES);
							$new_attribute_value = htmlentities($new_attribute_value, ENT_QUOTES);
							$new_attributes_array[] = array($value3[0], $new_attribute_value);
							//print('$attribute_value, $new_attribute_value: ');var_dump($attribute_value, $new_attribute_value);
							if($attribute_value !== $new_attribute_value) {
								$changed_an_attribute_value = true;
							}
						}
						if($changed_an_attribute_value) {
							$new_tag_array = array();
							foreach($tag_array as $index2 => $value2) {
								if($index2 === 1) {
									$new_tag_array[1] = $new_attributes_array;
								} else {
									$new_tag_array[$index2] = $value2;
								}
							}
							$this->tidyer_DOM[$index] = array(1, $new_tag_array);
						}
					}
				}
			}
		} elseif($this->config['character_entity_encoding_type'] === 'decimal') {
			// should already have been taken care of
		} elseif($this->config['character_entity_encoding_type'] === 'hexadecimal') {
			// should already have been taken care of
		} else { // default to raw characters
			if(ReTidy::is_HTML5()) {
				foreach($this->tidyer_DOM as $index => $value) {
					if($value[0] === 1 && $value[1][2] < 3) { // normal tag
						$tag_array = $value[1];
						$attributes_array = $tag_array[1];
						if(sizeof($attributes_array) > 0) {
							$changed_an_attribute_value = false;
							$new_attributes_array = array();
							foreach($attributes_array as $index3 => $value3) {
								$attribute_value = $value3[1];
								// we must preserve double quote character entities in attributes
								$new_attribute_value = str_replace('&quot;', '&amp;quot;', $new_attribute_value);
								$new_attribute_value = str_replace('&#34;', '&amp;#34;', $new_attribute_value);
								$new_attribute_value = str_replace('&#x22;', '&amp;#x22;', $new_attribute_value);
								$new_attribute_value = html_entity_decode($attribute_value, ENT_QUOTES);
								$new_attribute_value = htmlspecialchars($new_attribute_value, ENT_QUOTES & ENT_HTML5);
								$new_attribute_value = str_replace(' ', '&#160;', $new_attribute_value); // non-breaking space character
								$new_attribute_value = str_replace('"', '&quot;', $new_attribute_value);
								$new_attributes_array[] = array($value3[0], $new_attribute_value);
								//print('$attribute_value, $new_attribute_value2: ');var_dump($attribute_value, $new_attribute_value);
								if($attribute_value !== $new_attribute_value) {
									$changed_an_attribute_value = true;
								}
							}
							if($changed_an_attribute_value) {
								$new_tag_array = array();
								foreach($tag_array as $index2 => $value2) {
									if($index2 === 1) {
										$new_tag_array[1] = $new_attributes_array;
									} else {
										$new_tag_array[$index2] = $value2;
									}
								}
								$this->tidyer_DOM[$index] = array(1, $new_tag_array);
							}
						}
					}
				}
			} elseif(ReTidy::is_XHTML()) {
				foreach($this->tidyer_DOM as $index => $value) {
					if($value[0] === 1 && $value[1][2] < 3) { // normal tag
						$tag_array = $value[1];
						$attributes_array = $tag_array[1];
						//var_dump($tag_array);
						//var_dump($attributes_array);
						if(sizeof($attributes_array) > 0) {
							//var_dump($value);
							//var_dump(sizeof($tag_array));
							//var_dump(sizeof($tag_array) > 0);
							$changed_an_attribute_value = false;
							$new_attributes_array = array();
							foreach($attributes_array as $index3 => $value3) {
								$attribute_value = $value3[1];
								$new_attribute_value = html_entity_decode($attribute_value, ENT_QUOTES);
								$new_attribute_value = htmlspecialchars($new_attribute_value, ENT_QUOTES & ENT_XHTML);
								$new_attribute_value = str_replace(' ', '&#160;', $new_attribute_value); // non-breaking space character
								$new_attribute_value = str_replace('"', '&quot;', $new_attribute_value);
								$new_attributes_array[] = array($value3[0], $new_attribute_value);
								//print('$attribute_value, $new_attribute_value3: ');var_dump($attribute_value, $new_attribute_value);
								if($attribute_value !== $new_attribute_value) {
									$changed_an_attribute_value = true;
								}
							}
							if($changed_an_attribute_value) {
								$new_tag_array = array();
								foreach($tag_array as $index2 => $value2) {
									if($index2 === 1) {
										$new_tag_array[1] = $new_attributes_array;
									} else {
										$new_tag_array[$index2] = $value2;
									}
								}
								$this->tidyer_DOM[$index] = array(1, $new_tag_array);
							}
						}
					}
				}
			} elseif(ReTidy::is_XML()) {
				foreach($this->tidyer_DOM as $index => $value) {
					if($value[0] === 1 && $value[1][2] < 3) { // normal tag
						$tag_array = $value[1];
						$attributes_array = $tag_array[1];
						if(sizeof($attributes_array) > 0) {
							$changed_an_attribute_value = false;
							$new_attributes_array = array();
							foreach($attributes_array as $index3 => $value3) {
								$attribute_value = $value3[1];
								$new_attribute_value = html_entity_decode($attribute_value, ENT_QUOTES);
								$new_attribute_value = htmlspecialchars($new_attribute_value, ENT_QUOTES & ENT_XML1);
								$new_attribute_value = str_replace(' ', '&#160;', $new_attribute_value); // non-breaking space character
								$new_attribute_value = str_replace('"', '&quot;', $new_attribute_value);
								$new_attributes_array[] = array($value3[0], $new_attribute_value);
								//print('$attribute_value, $new_attribute_value4: ');var_dump($attribute_value, $new_attribute_value);
								if($attribute_value !== $new_attribute_value) {
									$changed_an_attribute_value = true;
								}
							}
							if($changed_an_attribute_value) {
								$new_tag_array = array();
								foreach($tag_array as $index2 => $value2) {
									if($index2 === 1) {
										$new_tag_array[1] = $new_attributes_array;
									} else {
										$new_tag_array[$index2] = $value2;
									}
								}
								$this->tidyer_DOM[$index] = array(1, $new_tag_array);
							}
						}
					}
				}
			} else { // default to HTML4
				foreach($this->tidyer_DOM as $index => $value) {
					if($value[0] === 1 && $value[1][2] < 3) { // normal tag
						$tag_array = $value[1];
						$attributes_array = $tag_array[1];
						if(sizeof($attributes_array) > 0) {
							$changed_an_attribute_value = false;
							$new_attributes_array = array();
							foreach($attributes_array as $index3 => $value3) {
								$attribute_value = $value3[1];
								//$new_attribute_value = str_replace('&apos;', '&amp;quot;', $new_attribute_value);
								//$new_attribute_value = str_replace('&#39;', '&amp;#34;', $new_attribute_value);
								//$new_attribute_value = str_replace('&#x27;', '&amp;#x22;', $new_attribute_value);
								$new_attribute_value = html_entity_decode($attribute_value, ENT_QUOTES);
								$new_attribute_value = htmlspecialchars($new_attribute_value, ENT_QUOTES);
								$new_attribute_value = str_replace(' ', '&#160;', $new_attribute_value); // non-breaking space character
								$new_attribute_value = str_replace('"', '&quot;', $new_attribute_value);
								$new_attributes_array[] = array($value3[0], $new_attribute_value);
								//print('$attribute_value, $new_attribute_value5: ');var_dump($attribute_value, $new_attribute_value);
								if($attribute_value !== $new_attribute_value) {
									$changed_an_attribute_value = true;
								}
							}
							if($changed_an_attribute_value) {
								$new_tag_array = array();
								foreach($tag_array as $index2 => $value2) {
									if($index2 === 1) {
										$new_tag_array[1] = $new_attributes_array;
									} else {
										$new_tag_array[$index2] = $value2;
									}
								}
								$this->tidyer_DOM[$index] = array(1, $new_tag_array);
							}
						}
					}
				}
			}
		}
		//print('$this->code3: ' . htmlentities($this->code) . '<br>');
		//print('$this->tidyer_DOM3: ');var_dump($this->tidyer_DOM);
		// make closing tags that are implicit explicit
		$array_indices_to_add_closing_li = array();
		$latest_new_closing_li_index = -2;
		foreach($this->tidyer_DOM as $index => $value) {
			if($value[0] === 1 && $value[1][2] === 0 && $value[1][0] === 'li') { // opening li
				//var_dump($value[1]);exit(0);
				$counter = $initial_counter = $index - 1;
				$nesting_counter = 0;
				while($counter > $latest_new_closing_li_index && $counter > -1 && $nesting_counter > -1) {
					if($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][2] === 0 && $this->tidyer_DOM[$counter][1][0] === 'li') { // opening li
						$array_indices_to_add_closing_li[] = $initial_counter;
						$latest_new_closing_li_index = $initial_counter;
					} elseif($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][2] === 1 && $this->tidyer_DOM[$counter][1][0] === 'li') { // closing li
						break;
					} elseif($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][2] === 0 && $this->tidyer_DOM[$counter][1][0] === 'ol') { // opening ol
						$nesting_counter--;
					} elseif($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][2] === 0 && $this->tidyer_DOM[$counter][1][0] === 'ul') { // opening ul
						$nesting_counter--;
					} elseif($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][2] === 0 && $this->tidyer_DOM[$counter][1][0] === 'ol') { // closing ol
						$nesting_counter++;
					} elseif($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][2] === 0 && $this->tidyer_DOM[$counter][1][0] === 'ul') { // closing ul
						$nesting_counter++;
					}
					$counter--;
				}
			}
		}
		//$array_indices_to_add_closing_li = array_reverse($array_indices_to_add_closing_li);
		$new_array = array();
		foreach($this->tidyer_DOM as $index => $value) {
			foreach($array_indices_to_add_closing_li as $index_index => $index_value) {
				if($index_value === $index) {
					$new_array[] = array(1, array('li', array(), 1, true));
				}
			}
			$new_array[] = $value;
		}
		$this->tidyer_DOM = $new_array;
		
		// enforce self-closing tags
		foreach($this->tidyer_DOM as $index => $value) {
			if($value[0] === 1 && $value[1][2] === 0) { // opening tag
				foreach($this->array_tidyer_self_closing as $self_closing_index => $self_closing_tag) {
					if($value[1][0] === $self_closing_tag) {
						// turn it into a self-closing tag
						$new_tag_array = array($value[1][0], $value[1][1], 2, $value[1][3]);
						$this->tidyer_DOM[$index] = array(1, $new_tag_array);
					}
				}
			}
		}
		//print('here37548960<br>');
		//var_dump($this->tidyer_DOM);
		//var_dump($this->tidyer_DOM[7][1]);
		//var_dump($this->tidyer_DOM);return true;
		//$this->code = preg_replace('/<(.*?)>/is', '', $this->code);
		$tidyer_changes = 0;
		// we could, of course, do more sophisticated error reporting
		//$tidyer_changes += ReTidy::exhaustive_preg_replace('/<(.*?)>/is', '', $this->code);
		// now for some cleanup
		//print('$this->tidyer_DOM (1): ');var_dump($this->tidyer_DOM);
		
		//print('here37548961<br>');
		// eliminate whitespace
		// this is wasteful; no need to create array_tidyer_DOM_entries_to_eliminate
		$array_tidyer_DOM_entries_to_eliminate = array();
		foreach($this->tidyer_DOM as $index => $value) {
			if($value[0] === 0) { // text
				$keep_text = true;
				$text = $value[1];
				preg_match('/[^\s]/is', $text, $non_space_matches);
				if(sizeof($non_space_matches[0]) > 0) {
					
				} else {
					if($this->tidyer_DOM[$index + 1][1][3]) { // next tag is a block
						$keep_text = false;
					}
				}
				if($keep_text) {
					
				} else {
					$array_tidyer_DOM_entries_to_eliminate[] = $index;
				}
			}
		}
		//print('sizeof($array_tidyer_DOM_entries_to_eliminate): ');var_dump(sizeof($array_tidyer_DOM_entries_to_eliminate));
		//print('$array_tidyer_DOM_entries_to_eliminate: ');var_dump($array_tidyer_DOM_entries_to_eliminate);
		$new_tidyer_DOM = array();
		foreach($this->tidyer_DOM as $index => $value) {
			$keep_it = true;
			foreach($array_tidyer_DOM_entries_to_eliminate as $index2 => $value2) {
				if($index === $value2) {
					$keep_it = false;
					break;
				}
			}
			if($keep_it) {
				$new_tidyer_DOM[] = $value;
			}
		}
		$this->tidyer_DOM = $new_tidyer_DOM;
		//print('$this->tidyer_DOM (2): ');var_dump($this->tidyer_DOM);
		//print('here37548962<br>');
		// regulate spaces in text (remove raw line breaks, and redundant lengths of space)
		foreach($this->tidyer_DOM as $index => $value) {
			if($value[0] === 0) { // text
				//var_dump($value);
				$new_text = $value[1];
				$new_text = str_replace('
', ' ', $new_text);
				$new_text = preg_replace('/\s{2,}/is', ' ', $new_text);
				$this->tidyer_DOM[$index] = array($value[0], $new_text);
			}
		}
		//var_dump($this->tidyer_DOM);
		//print('here37548963<br>');
		// paragraphize "orphaned" text
		// if this takes a long time we could, of course, use the reversely processed array to apply all the changes at once instead of relooping the array every time a change is made
		// disabled 2018-07-29. does anything depend on this code?
		/*$process = true;
		//$closing_paragraph_pending = false;
		while($process) {
			$process = false;
			foreach($this->tidyer_DOM as $index => $value) {
				// block in p; undesireable
				if(($this->tidyer_DOM[$index][1][0] === 'p' && $this->tidyer_DOM[$index][1][3] && ($this->tidyer_DOM[$index][1][2] === 0 || $this->tidyer_DOM[$index][1][2] === 2)) && 
				($this->tidyer_DOM[$index + 1][1][0] !== 'div' && $this->tidyer_DOM[$index + 1][1][0] !== 'ul' && $this->tidyer_DOM[$index + 1][1][0] !== 'ol' && $this->tidyer_DOM[$index + 1][1][3] && ($this->tidyer_DOM[$index + 1][1][2] === 0 || $this->tidyer_DOM[$index + 1][1][2] === 2))) {
					//print('here2049590605<br>');
					// this assumes there is a closing tag...
					$depth = 2;
					// notice that this is similar to OM::getOString and could potentially be generalized to have tidyer fix tag nesting
					$nesting_index = $index + 2;
					$last_closing_index = false;
					while($depth > 0) {
						if($this->tidyer_DOM[$nesting_index][1][3] && ($this->tidyer_DOM[$nesting_index][1][2] === 0 || $this->tidyer_DOM[$nesting_index][1][2] === 2)) {
							$depth++;
						} elseif($this->tidyer_DOM[$nesting_index][1][3] && ($this->tidyer_DOM[$nesting_index][1][2] === 1 || $this->tidyer_DOM[$nesting_index][1][2] === 2)) {
							$second_last_closing_index = $last_closing_index;
							$last_closing_index = $nesting_index;
							$depth--;
						}
						$nesting_index++;
					}
					//print('$nesting_index, $second_last_closing_index: ');var_dump($nesting_index, $second_last_closing_index);
					$new_tidyer_DOM = array();
					if($this->tidyer_DOM[$nesting_index - 1][1][0] === 'p') { // then we found the closing p around the block
						//print('here2049590605.1<br>');
						foreach($this->tidyer_DOM as $index2 => $value2) {
							if($index === $index2) {

							} elseif($second_last_closing_index === $index2) {
								$new_tidyer_DOM[] = $value2;
								$new_tidyer_DOM[] = $value; // move the existing opening p
							} else {
								$new_tidyer_DOM[] = $value2;
							}
						}
					} else { // then there is no closing p around the block
						//print('here2049590605.2<br>');
						foreach($this->tidyer_DOM as $index2 => $value2) {
							if($index === $index2) {
								$new_tidyer_DOM[] = $value2;
								$new_tidyer_DOM[] = array(1, array('p', array(), 1, true)); // new closing p tag
							} else {
								$new_tidyer_DOM[] = $value2;
							}
						}
					}
					$this->tidyer_DOM = $new_tidyer_DOM;

					$process = true;
					//$closing_paragraph_pending = false;
					break;
				}
				// instead of this we would like to keep track of whether we are in a <p>...
				//elseif($value[0] === 1 && $value[1][2] === 1) { // closing tag
				//	if($value[1][3] !== true) { // non-block
				//		if(($this->tidyer_DOM[$index + 1][1][0] === 'p' && ($this->tidyer_DOM[$index + 1][1][2] === 0 || $this->tidyer_DOM[$index + 1][1][2] === 2)) ||  // next tag is an opening paragraph
				//		($this->tidyer_DOM[$index + 1][1][0] === 'blockquote' && ($this->tidyer_DOM[$index + 1][1][2] === 1 || $this->tidyer_DOM[$index + 1][1][2] === 2))) { // next tag is a closing blockquote
				//			//print('here2049590608<br>');
				//			$new_tidyer_DOM = array();
				//			foreach($this->tidyer_DOM as $index2 => $value2) {
				//				if($index === $index2) {
				//					$new_tidyer_DOM[] = $value2;
				//					$new_tidyer_DOM[] = array(1, array('p', array(), 1, true)); // new closing paragraph tag
				//				} else {
				//					$new_tidyer_DOM[] = $value2;
				//				}
				//			}
				//			$this->tidyer_DOM = $new_tidyer_DOM;
				//			$process = true;
				//			//$closing_paragraph_pending = false;
				//			break;
				//		}
				//	} else { // block
				//
				//	}
				//}
				
				elseif($value[0] === 0) { // text
					// I'd prefer not to do this hack as it probably adds processing time while this problem could be avoided in the generate_tidyer_DOM function
					if(strlen(trim($value[1])) > 0) {
						
					} else {
						continue;
					}
					//$backwards_counter = 1;
					//print('$this->tidyer_DOM[$index - $backwards_counter][0]: ');var_dump($this->tidyer_DOM[$index - $backwards_counter][0]);
					//while($this->tidyer_DOM[$index - $backwards_counter][0] !== 1) {
					//	$backwards_counter++;
					//}
					//print('$index, $backwards_counter: ');var_dump($index, $backwards_counter);
					//if(($this->tidyer_DOM[$index - 1][1][0] === 'p' && $this->tidyer_DOM[$index - 1][1][3] && ($this->tidyer_DOM[$index - 1][1][2] === 1 || $this->tidyer_DOM[$index - 1][1][2] === 2)) || // previous tag is a closing non-div block
					if(($this->tidyer_DOM[$index - 1][1][0] !== 'div' && $this->tidyer_DOM[$index - 1][1][3] && ($this->tidyer_DOM[$index - 1][1][2] === 1 || $this->tidyer_DOM[$index - 1][1][2] === 2)) || // previous tag is a closing non-div block					
					($this->tidyer_DOM[$index - 1][1][0] === 'blockquote' && ($this->tidyer_DOM[$index - 1][1][2] === 0 || $this->tidyer_DOM[$index - 1][1][2] === 2))) { // previous tag is an opening blockquote
						//print('here2049590606<br>');
						// we have to try to check that the newly opened paragraph will close correctly
						$counter = $index + 1;
						while($counter < sizeof($this->tidyer_DOM)) {
							//print('here2049590649<br>');
							//var_dump($this->tidyer_DOM[$counter][0], $this->tidyer_DOM[$counter][1][3]);
							if($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][3]) { // is block tag
								//var_dump($this->tidyer_DOM[$counter][1][0], $this->tidyer_DOM[$counter][1][2], $this->tidyer_DOM[$counter][1][2]);
								if($this->tidyer_DOM[$counter][1][0] === 'p' && ($this->tidyer_DOM[$counter][1][2] === 1 || $this->tidyer_DOM[$counter][1][2] === 2)) { // closing paragraph
									
								} else {
									//print('here2049590650<br>');
									//var_dump(sizeof($this->tidyer_DOM), $counter);
									$new_tidyer_DOM = array();
									foreach($this->tidyer_DOM as $index2 => $value2) {
										if($counter === $index2) {
											//print('here2049590651<br>');
											$new_tidyer_DOM[] = array(1, array('p', array(), 1, true)); // new closing paragraph tag
											$new_tidyer_DOM[] = $value2;
										} else {
											$new_tidyer_DOM[] = $value2;
										}
									}
									$this->tidyer_DOM = $new_tidyer_DOM;
								}
								break;
							}
							$counter++;
						}
						$new_tidyer_DOM = array();
						foreach($this->tidyer_DOM as $index2 => $value2) {
							if($index === $index2) {
								$new_tidyer_DOM[] = array(1, array('p', array(), 0, true)); // new opening paragraph tag
								$new_tidyer_DOM[] = $value2;
							} else {
								$new_tidyer_DOM[] = $value2;
							}
						}
						$this->tidyer_DOM = $new_tidyer_DOM;
						$process = true;
						//$closing_paragraph_pending = true;
						break;
					}
					//if($closing_paragraph_pending && $this->tidyer_DOM[$index + 1][1][3]) { // next tag is a block
					//	print('here2049590610<br>');
					//	$new_tidyer_DOM = array();
					//	foreach($this->tidyer_DOM as $index2 => $value2) {
					//		if($index === $index2) {
					//			$new_tidyer_DOM[] = $value2;
					//			$new_tidyer_DOM[] = array(1, array('p', array(), 1, true)); // new closing paragraph tag
					//		} else {
					//			$new_tidyer_DOM[] = $value2;
					//		}
					//	}
					//	$this->tidyer_DOM = $new_tidyer_DOM;
					//	$process = true;
					//	//$closing_paragraph_pending = false;
					//	break;
					//}
					//$forwards_counter = 1;
					//while($this->tidyer_DOM[$index + $forwards_counter][0] !== 1) {
					//	$forwards_counter++;
					//}
					if(($this->tidyer_DOM[$index + 1][1][0] !== 'div' && $this->tidyer_DOM[$index + 1][1][0] !== 'ul' && $this->tidyer_DOM[$index + 1][1][0] !== 'ol' && $this->tidyer_DOM[$index + 1][1][3] && ($this->tidyer_DOM[$index + 1][1][2] === 0 || $this->tidyer_DOM[$index + 1][1][2] === 2)) || // next tag is an opening non-div, non-ul, non-ol block
					($this->tidyer_DOM[$index + 1][1][0] === 'blockquote' && ($this->tidyer_DOM[$index + 1][1][2] === 1 || $this->tidyer_DOM[$index + 1][1][2] === 2))) { // next tag is a closing blockquote
						//print('here2049590607<br>');
						$new_tidyer_DOM = array();
						foreach($this->tidyer_DOM as $index2 => $value2) {
							if($index === $index2) {
								$new_tidyer_DOM[] = $value2;
								$new_tidyer_DOM[] = array(1, array('p', array(), 1, true)); // new closing paragraph tag
							} else {
								$new_tidyer_DOM[] = $value2;
							}
						}
						$this->tidyer_DOM = $new_tidyer_DOM;
						$process = true;
						//$closing_paragraph_pending = false;
						break;
					}
				}
			}
		}*/
		//print('here37548964<br>');
		//print('$this->code4: ' . htmlentities($this->code) . '<br>');
		ReTidy::generate_code_from_tidyer_DOM();
		//print('$this->code5: ' . htmlentities($this->code) . '<br>');
		//print('$this->tidyer_DOM5: ');var_dump($this->tidyer_DOM);
		return true; // since tidy_code is an "important method" and this is an alias
	}
	
	protected function generate_code_from_tidyer_DOM() {
		$this->code = ReTidy::generate_code_from_tidyer_DOM_like_array($this->tidyer_DOM);
	}
	
	protected function generate_code_from_tidyer_DOM_like_array($array) {
		//print('$array (3): ');var_dump($array);
		if(!isset($this->config['indentation_string'])) {
			//$this->config['indentation_string'] = '	'; // tab; I don't like it :)
			$this->config['indentation_string'] = '';
		}
		$block_depth = 0;
		$code = '';
		foreach($array as $index => $value) {
			if($value[0] === 0) { // text
				$text = $value[1];
				// intelligently trim unnecessary space on text
				preg_match('/[\s]+/is', $text, $space_matches, PREG_OFFSET_CAPTURE);
				if($space_matches[0][1] === 0 && $array[$index - 1][1][3]) {
					//var_dump($space_matches);exit(0);
					$text = substr($text, strlen($space_matches[0][0]));
				}
				$rev_text = strrev($text);
				preg_match('/[\s]+/is', $rev_text, $space_matches, PREG_OFFSET_CAPTURE);
				if($space_matches[0][1] === 0 && $array[$index + 1][1][3]) {
					//var_dump($space_matches);exit(0);
					$text = substr($text, 0, strlen($text) - strlen($space_matches[0][0]));
				}
				$code .= $text;
			} elseif($value[0] === 1) { // tag
				$tag_array = $value[1];
				//var_dump($tag_array);
				$tag_name = $tag_array[0];
				$attributes_array = $tag_array[1];
				$tag_type = $tag_array[2];
				//var_dump($tag_type);
				if($tag_type > 2) {
					$tag = $tag_name;
				} elseif($tag_type === 0 || $tag_type === 2) {
					$tag = '<' . $tag_name;
				} elseif($tag_type === 1) {
					$tag = '</' . $tag_name;
				} else {
					print($tag_type);var_dump($tag_type);
					print('$value: ');var_dump($value);
					print('Tidyer thinks this is a tag that is neither opening, closing or self-closing...?');exit(0);
				}
				if($attributes_array !== false) {
					foreach($attributes_array as $attribute_index => $attribute_array) {
						// here is where we could put attributes on their own lines, if desired
						$tag .= ' ' . $attribute_array[0] . '="' . $attribute_array[1] . '"';
					}
				}
				if($tag_type > 2) {
					
				} elseif($tag_type === 0 || $tag_type === 1) {
					$tag .= '>';
				} elseif($tag_type === 2) {
					$tag .= ' />';
				} else {
					print($tag_type);var_dump($tag_type);
					print('$value: ');var_dump($value);
					print('Tidyer thinks this is a tag that is neither opening, closing or self-closing(2)...?');exit(0);
				}
				$indentation_string = '';
				if($tag_array[3]) { // is block
					if($tag_type === 1) {
						$block_depth--;
					}
					$indentation_counter = $block_depth;
					while($indentation_counter > 0) {
						$indentation_string .= $this->config['indentation_string'];
						$indentation_counter--;
					}
					if($tag_type === 0) {
						$block_depth++;
					}
				}
				if(($tag_type >= 2 || $tag_type === 0) && $tag_array[3]) {
					$code .= '
' . $indentation_string . $tag;
				} elseif($tag_type === 1) {
					$found_previous_tag = false;
					$counter = $index - 1;
					while($counter > -1 && !$found_previous_tag) {
						if($array[$counter][0] === 1) { // tag
							$found_previous_tag = true;
						} else {
							$counter--;
						}
					}
					if($found_previous_tag && $array[$counter][1][3] && ($array[$counter][1][2] === 1 || $array[$counter][1][2] === 2)) { // previous tag is a closing block
						$code .= '
' . $indentation_string . $tag;
					} else {
						$code .= $tag;
					}
				} else {
					$code .= $tag;
				}
				//var_dump($tag);
			} else {
				print('Tidyer thinks there is content that is neither text or a tag in this code...?');
				var_dump($value);
				exit(0);
			}
		}
		return $code;
	}
	
	protected function set_arrays_of_tidyer_tag_types() {
		//var_dump(DTD::getBlock());exit(0);
		// DTD::getBlock will return something like "p|h1|h2|h3|h4|h5|h6|div|ul|ol|dl|pre|hr|blockquote|address|fieldset|table" which is not useful for the purposes of pretty printing
		//print(DTD::getAllElements());exit(0);
		// html|head|title|base|meta|link|style|script|noscript|body|div|p|h1|h2|h3|h4|h5|h6|ul|ol|li|dl|dt|dd|address|hr|pre|blockquote|ins|del|a|span|bdo|br|em|strong|dfn|code|samp|kbd|var|cite|abbr|acronym|q|sub|sup|tt|i|b|big|small|object|param|img|map|area|form|label|input|select|optgroup|option|textarea|fieldset|legend|button|table|caption|thead|tfoot|tbody|colgroup|col|tr|th|td
		// html|body|a|abbr|area|audio|source|b|bdo|br|button|canvas|cite|code|command|datalist|option|del|dfn|em|embed|i|iframe|img|input|ins|kbd|keygen|label|link|map|mark|math|meta|meter|noscript|address|article|aside|blockquote|details|legend|dialog|dd|div|dl|dt|object|param|output|progress|q|ruby|rt|samp|script|select|optgroup|small|span|strong|sub|sup|svg|textarea|time|var|video|rp|fieldset|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|menu|li|nav|ol|p|pre|section|style|table|caption|ul|colgroup|col|thead|tr|th|td|tfoot|tbody|head|base|title|mathml
		// if these arrays are too cumbersome, we could cache useful portions as needed instead
		$this->array_tidyer_blocks = array(
		'html',
		'head',
		'title',
		'base',
		'meta',
		'link',
		'style',
		'script',
		'noscript',
		'body',
		'div',
		'p',
		'h1',
		'h2',
		'h3',
		'h4',
		'h5',
		'h6',
		'ul',
		'ol',
		'li',
		'dl',
		'dt',
		'dd',
		'address',
		'hr',
		'pre',
		'blockquote',
		'bdo',
		'object',
		'param',
		'map',
		'area',
		'form',
		'label',
		'input',
		'select',
		'optgroup',
		'option',
		'textarea',
		'fieldset',
		'legend',
		'button',
		'table',
		'thead',
		'tfoot',
		'tbody',
		'colgroup',
		'col',
		'tr',
		'th',
		'td',
		'audio',
		'source',
		'canvas',
		'command',
		'datalist',
		'embed',
		'iframe',
		'keygen',
		'mark',
		'math',
		'meter',
		'address',
		'article',
		'aside',
		'details',
		'dialog',
		'output',
		'progress',
		'ruby',
		'rt',
		'svg',
		'video',
		'rp',
		'figure',
		'figcaption', // added (2013-09-24)
		'footer',
		'form',
		'header',
		'hgroup',
		'menu',
		'nav',
		'section',
		'mathml',
		'caption', // moved (2014-03-04)
		);
		$this->array_tidyer_in_between = array(
		'br',
		);
		$this->array_tidyer_inline = array(
		'ins',
		'del',
		'a',
		'span',
		'em',
		'strong',
		'dfn',
		'code',
		'samp',
		'kbd',
		'var',
		'cite',
		'abbr',
		'acronym',
		'q',
		'sub',
		'sup',
		'tt',
		'i',
		'b',
		'big',
		'small',
		'img', // moved (2013-09-24)
		'time', // moved (2014-03-04)
		);
		// not for pretty printing; for syntax
		$this->array_tidyer_self_closing = array(
		'br',
		'meta',
		'img',
		'hr',
		'col',
		);
	}
	
	function is_self_closing_for_tidyer($tag_name) {
		if(!isset($this->array_tidyer_self_closing)) {
			ReTidy::set_arrays_of_tidyer_tag_types();
		}
		foreach($this->array_tidyer_self_closing as $index => $tidyer_self_closing) {
			if($tidyer_self_closing === $tag_name) {
				return true;
			}
		}
		return false;
	}
	
	function is_block_for_tidyer($tag_name) {
		if(!isset($this->array_tidyer_blocks)) {
			ReTidy::set_arrays_of_tidyer_tag_types();
		}
		foreach($this->array_tidyer_blocks as $index => $tidyer_block) {
			if($tidyer_block === $tag_name) {
				return true;
			}
		}
		return false;
	}
	
	function tag_name_from_tag_string($tag_string) {
		preg_match('/<\/?(\w+)/is', $tag_string, $tag_name_matches);
		return $tag_name_matches[1];
	}
	
	protected function exhaustive_preg_replace($pattern, $replace, $variable) {
		$counter = 0;
		$changes_count = -1;
		while($counter < 10 && $changes_count != 0) {
			$variable = preg_replace($pattern, $replace, $variable, -1, $changes_count);
		}
		return $variable;
	}
	
	protected function relativize_absolute_links() {
		$domains_array = array(
		//'sppc.gc.ca', // includes ppsc-sppc.gc.ca
		//'ppsc.gc.ca',
		'mpcc-cppm.gc.ca',
		);
		preg_match_all('/<a[^<>]*? href="([^"]*?)"[^<>]*?>(.*?)<\/a>/is', $this->code, $link_matches, PREG_OFFSET_CAPTURE);
		$counter = sizeof($link_matches[0]) - 1;
		//print('here34957495879485<br>');
		while($counter > -1) {
			//print('here34957495879486<br>');
			$link_text = $link_matches[2][$counter][0];
			//var_dump($link_text);
			if(strpos($link_text, '.gc.ca') !== false) {
				//print('here34957495879487<br>');
			} else {
				//print('here34957495879488<br>');
				$initial_link_href = $link_href = $link_matches[1][$counter][0];
				//var_dump($link_href, strpos($link_href, '.gc.ca'));
				$link_href = str_replace('http://', '', $link_href);
				if(strpos($link_href, '.gc.ca') !== false && strpos($link_href, '@') === false && strpos($link_href, '/') !== false) {
					//print('here34957495879489<br>');
					//$link_href = ReTidy::preg_replace_last('/\/[^\.]*?\.[^\.]*?/is', '/', $link_href);
					//$link_href = substr($link_href, 0, ReTidy::strpos_last($link_href, '/') + 1);
					foreach($domains_array as $index => $domain) {
						//print('here34957495879490<br>');
						if(strpos($link_href, $domain) !== false) {
							//print('here34957495879491<br>');
							//var_dump($this->file, $link_href);
							$file_array = explode('/', $this->file);
							$href_array = explode('/', $link_href);
							$counter2 = sizeof($file_array) - 1;
							while($counter2 > 0) {
								$counter5 = 0;
								//foreach($href_array as $index => $href_folder) {
								while($counter5 < sizeof($href_array) - 1) {
									$href_folder = $href_array[$counter5];
									//var_dump($href_folder, $file_array[$counter2], '#########');
									if($href_folder === $file_array[$counter2]) {
										//$counter3 = $counter4 = $index + 1;
										$counter3 = sizeof($file_array) - 2 - $counter2;
										$counter4 = $counter5 + 1;
										$relativized_link = '';
										//if($href_folder === 'eng' || $href_folder === 'fra') {
											while($counter3 > 0) {
												$relativized_link .= '../';
												$counter3--;
											}
										//}
										while($counter4 < sizeof($href_array)) {
											$relativized_link .= $href_array[$counter4] . '/';
											$counter4++;
										}
										break 2;
									}
									$counter5++;
								}
								$counter2--;
							}
							$relativized_link = substr($relativized_link, 0, strlen($relativized_link) - 1);
							//var_dump($relativized_link);exit(0);
							//$this->code = substr($this->code, 0, $link_matches[1][$counter][1]) . $relativized_link . substr($this->code, $link_matches[1][$counter][1] + strlen($link_href));
							$this->code = str_replace('href="' . $initial_link_href . '"', 'href="' . $relativized_link . '"', $this->code);
							//$this->code = str_replace('href="' . $initial_link_href . '"', 'href="hihi"', $this->code);
							$this->logMsg($initial_link_href . ' link was relativized to ' . $relativized_link);
							break;
						}
					}
				}
			}
			$counter--;
		}
	}

	private $htmltidy_config_file = false;

	private function htmltidy_gen_config ()
	{
		// cache the result
		if($this->htmltidy_config_file)
			return $this->htmltidy_config_file;

		$this->logMsg('htmltidy_gen_config() started');

		$tmp = tempnam($this->htmltidy_config_dir, 'retidy-htmltidy-config-');
		if(!$tmp)
		{
			$this->logMsg('tempnam() failed!');
			return false;
		}

		$config = '# ' . (string)$this . "\r\n# Profile: " . $this->config_profile . "\r\n# " . date('c') . "\r\n\r\n";

		foreach($this->config['htmltidy'] as $k => $v)
		{
			$config .= "$k: $v\r\n";
		}

		$handle = fopen($tmp, 'wb');
		if(!$handle)
		{
			$this->logMsg('fopen(' . $tmp .') failed!');
			return false;
		}

		if(!fwrite($handle, $config))
		{
			$this->logMsg('fwrite(' . $tmp . ') failed!');
			return false;
		}

		fclose($handle);
		unset($config);

		$this->htmltidy_config_file = $tmp;

		return $tmp;
	}

	private function htmltidy_app ()
	{
		$this->logMsg('=== htmltidy_app ===');

		$descriptorspec = array(
			0 => array('pipe', 'r'), // stdin
			1 => array('pipe', 'w'), // stdout
			2 => array('pipe', 'w')  // stderr
		);

		$pipes = array();

		$cmd = $this->config['htmltidy_app'];
		$config = $this->htmltidy_gen_config();
		if($config)
			$cmd .= ' -config ' . escapeshellarg($config);
		else
			return false;

		$this->logMsg('Will execute: ' . $cmd);

		$process = proc_open($cmd, $descriptorspec, $pipes);

		if(!is_resource($process))
		{
			$this->logMsg('Error when trying to open the process!');
			return false;
		}

		if(!fwrite($pipes[0], $this->code))
		{
			$this->logMsg('Error when trying to fwrite() the code to HTML Tidy!');
			return false;
		}
		fclose($pipes[0]);

		$this->code = stream_get_contents($pipes[1]);
		if(!$this->code)
		{
			$this->logMsg('Warning! HTML Tidy output is empty.');

			fclose($pipes[1]);
			fclose($pipes[2]);
			proc_close($process);

			return false;
		}

		fclose($pipes[1]);

		$errors = stream_get_contents($pipes[2]);
		fclose($pipes[2]);

		$ret_val = proc_close($process);

		$this->logMsg('Status: ' . $ret_val);

		if($this->config['show_tidy_errors'])
			$this->logMsg("--- Error buffer --- \n" . $errors . "\n--- Error buffer end ---");
		else
		{
			$matches = array();
			if(preg_match('/\n(\d+)\s+warnings?\,\s+(\d+)\s+errors?/i', $errors, $matches))
				$this->logMsg('Errors ' . $matches[2] . "\nWarnings: " . $matches[1]);
		}

		return true;
	}

	private function encode_character_entities_in_comments() {
		if($this->config['htmltidy']['input-encoding'] === "utf8") {
			// don't worry about it
		} else {
			$comment_opener = '<!--';
			$comment_closer = '-->';
			$strlen_comment_opener = strlen($comment_opener);
			$strlen_comment_closer = strlen($comment_closer);
			print('here5549<br>');
			$comments = OM::getAllOStrings($this->code, $comment_opener, $comment_closer);
			$size_minus_one = sizeof($comments) - 1;
			while($size_minus_one > -1) {
				$comment = $comments[$size_minus_one][0];
				$strlen_comment = strlen($comment);
				$offset = $comments[$size_minus_one][1];
				$comment_code = substr($this->code, $offset + $strlen_comment_opener, $strlen_comment - $strlen_comment_opener - $strlen_comment_closer);
				$comment_code = htmlentities($comment_code);
				$comment_code = htmlspecialchars_decode($comment_code);
				$this->code = substr($this->code, 0, $offset) . $comment_opener . $comment_code . $comment_closer . substr($this->code, $offset + $strlen_comment);
				$size_minus_one--;
			}
		}
		return true;
	}
	
	private function tidy_comments() {
		print('<span style="color: red;">This function (tidy_comments) is probably obsolete.</span>');return false;
		// it should be noted that this function is not perfect to the character; specifically, space can be changed around according to tidy's whims.
		
		// if there is a comment with special characters, then tidy will not convert these special characters to what they need to be
		// (either character entities or otherwise converted; depending on the declared character set) since it does not do any work 
		// on HTML comments. This will only be a problem when using a small character set (such as windows-1252, when coming from word)
		if($this->config['htmltidy']['input-encoding'] === "utf8") {
			// don't worry about it
		} else {
			// ideally we would just use a function specifically for converting characters...
			// ... such as iconv with HTML support? ...
			// instead of tidying the string then removing the tags it adds...
			// first, get all comments in the document
			$comment_opener = '<!--';
			$comment_closer = '-->';
			$strlen_comment_opener = strlen($comment_opener);
			$strlen_comment_closer = strlen($comment_closer);
			print('here5500<br>');
			$comments = OM::getAllOStrings($this->code, $comment_opener, $comment_closer);
			$size_minus_one = sizeof($comments) - 1;
			while($size_minus_one > -1) {
				$comment = $comments[$size_minus_one][0];
				$strlen_comment = strlen($comment);
				$offset = $comments[$size_minus_one][1];
				$comment_code = substr($this->code, $offset + $strlen_comment_opener, $strlen_comment - $strlen_comment_opener - $strlen_comment_closer);
				// preserve spaces at the start of the comment...
				preg_match('/(\s*)[^\s]/is', $comment_code, $matches66);
				$opening_space = $matches66[1];
				preg_match('/(\s*)/is', strrev($comment_code), $matches67);
				$closing_space = strrev($matches67[1]);
				// hide line breaks from tidy...
				$comment_code = str_replace('
', 'XXX9o9linebreak9o9XXX', $comment_code);
				$comment_code = htmlentities($comment_code);
				$tidied_comment_code = tidy_parse_string($comment_code, $this->config['htmltidy'], $this->config['htmltidy']['input-encoding']);
				// now take off the unwanted tags tidy adds
				$tidied_comment_code = preg_replace('/<html>\s*<head>\s*<title>\s*<\/title>\s*<\/head>\s*<body>\s*/is', '', $tidied_comment_code);
				$tidied_comment_code = preg_replace('/\s*<\/body>\s*<\/html>/is', '', $tidied_comment_code);
				$tidied_comment = $comment_opener . $opening_space . $tidied_comment_code . $closing_space . $comment_closer;
				$tidied_comment = html_entity_decode($tidied_comment);
				// put line breaks back in...
				$tidied_comment = str_replace('XXX9o9linebreak9o9XXX', '
', $tidied_comment);
				$this->code = substr($this->code, 0, $offset) . $tidied_comment . substr($this->code, $offset + $strlen_comment);
				$size_minus_one--;
			}
		}
		return true;
	}
	
	private function htmltidy_php() {
		// this function may have innacuracies or stuff out of date but it shouldn't be usd anyway
		$this->logMsg("=== htmltidy_php ===");
		if(!is_callable('tidy_parse_string')) {
			$this->logMsg('tidy_parse_string() is not callable! Maybe the tidy extension is not installed.');
			return false;
		}
		// added (2011-06-29)
		if($this->WET === "WET" || $this->config['WET'] === "WET") {
			$this->config['htmltidy']['anchor-as-name'] = 0;
		}
		ReTidy::set_HTML5();
		//ReTidy::tidy_comments();
		ReTidy::encode_character_entities_in_comments();
		$tidy = tidy_parse_string($this->code, $this->config['htmltidy'], $this->config['htmltidy']['input-encoding']);
		//var_dump($tidy); // tidy error reporting
		if(!$tidy) {
			$this->logMsg('tidy_parse_string() failed!');
			return false;
		}
		if(!$tidy->cleanRepair()) {
			$this->logMsg('$tidy->cleanRepair() failed!');
			return false;
		}
		$this->logMsg('Status: '. $tidy->getStatus() . "\nErrors: " . tidy_error_count($tidy) . "\nWarnings: " . tidy_warning_count($tidy));
		if($this->config['show_tidy_errors']) {
			$this->logMsg("--- Error buffer --- \n" . $tidy->errorBuffer . "\n --- Error buffer end ---");
		}
		$this->code = tidy_get_output($tidy);
		if(!$this->code) {
			$this->logMsg('Warning! HTML Tidy output is empty.');
		}
		// perhaps we should just say if not utf8?
		if(($this->config['encoding'] === "iso-8859-1" ||
		$this->config['encoding'] === "us-ascii" ||
		$this->config['encoding'] === "windows-1252") && $this->config['do_not_encode_character_entities'] !== true) {
			ReTidy::encode_character_entities();
		}
		// HTML5 specific fix (tidy and basically everything else do not support HTML5)
		//var_dump($this->config['HTML5']);
		//var_dump($this->config);
		//var_dump(ReTidy::get_HTML5());
		if(ReTidy::get_HTML5()) {
			//print("here--4300--2");
			$this->code = ReTidy::str_replace_first('<meta />', '<meta charset="' . $this->config['encoding'] . '" />', $this->code);
		}
		return true;
	}
	
	// these functions must account for the eventual template rather than the current state of the code. this is, of course, merely paradigmatic but a paradigm must be adopted to avoid confusion
	
	protected function set_HTML5() {
		$this->HTML5 = false;
		//var_dump($this->code);
		//if(strpos($this->code, '<!DOCTYPE html>') !== false) { // assuming good practices this is sufficient but we can't make this assumption
		//	$this->HTML5 = true;
		//}
		$array_tags_identifying_HTML5 = array(
		'section',
		'header',
		'footer',
		'figure',
		);
		foreach($array_tags_identifying_HTML5 as $index => $tag_name) {
			if(strpos($this->code, '<' . tag_name) !== false) {
				$this->HTML5 = true;
				return;
			}
		}
	}
	
	protected function get_HTML5() {
		//print('isset HTML5: ');var_dump(isset($this->HTML5));
		if(!isset($this->HTML5)) {
			ReTidy::set_HTML5();
		}
		return $this->HTML5;
	}
	
	protected function is_HTML5() { return ReTidy::get_HTML5(); }
	
	protected function set_XHTML() {
		$this->XHTML = false;
		if(strpos($this->code, '//W3C//DTD XHTML') !== false) {
			$this->XHTML = true;
		}
	}
	
	protected function get_XHTML() {
		if(!isset($this->XHTML)) {
			ReTidy::set_XHTML();
		}
		return $this->XHTML;
	}
	
	protected function is_XHTML() { return ReTidy::get_XHTML(); }
	
	protected function set_XML() {
		$this->XML = false;
		if(strpos($this->code, '<?xml version') !== false) {
			$this->XML = true;
		}
	}
	
	protected function get_XML() {
		if(!isset($this->XML)) {
			ReTidy::set_XML();
		}
		return $this->XML;
	}
	
	protected function is_XML() { return ReTidy::get_XML(); }
	
	protected function pre_tidy_regex () {
		if(!is_array($this->config['pre_tidy_regex'])) return false;
		$c = $ct = 0;
		foreach($this->config['pre_tidy_regex'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("pre_tidy_regex[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("pre_tidy_regex", $ct);
		return true;
	}

	protected function remove_nodes ()
	{
		if(!is_array($this->config['remove_nodes']))
			return false;

		$c = 0;
		$regex = '(' . implode('|', $this->config['remove_nodes']) . ')';
		$regex = '/<' . $regex . '[\s>].*?<\/\1>/is';
		$this->code = preg_replace($regex, ' ', $this->code, -1, $c);
		$this->logMsgIf("remove_nodes", $c);

		return true;
	}

	protected function my_strip_tags ()
	{
		if(!is_array($this->config['strip_tags']) || !isset($this->config['strip_tags']['*']))
			return false;

		$c = 0;
		$regex = '/<\/?(' . implode('|', $this->config['strip_tags']['*']) . ')[^>]*>/i';
		$this->code = preg_replace($regex, ' ', $this->code, -1, $c);
		$this->logMsg("strip_tags[*] $c ");

		return true;
	}

	protected function strip_lang ()
	{
		if ($this->config['strip_lang'])
		{
			$c = 0;
			$this->code = preg_replace('/\slang\s*=\s*("|\')(.*?)\1/is', '', $this->code, -1, $c);
			$this->logMsgIf("strip_lang", $c);
		}

		if ($this->config['strip_xmllang'])
		{
			$c = 0;
			$this->code = preg_replace('/\sxml:lang\s*=\s*("|\')(.*?)\1/is', '', $this->code, -1, $c);
			$this->logMsgIf("strip_xmllang", $c);
		}

		return true;
	}

	protected function strip_br_dupes ()
	{
		if (!$this->config['strip_br_dupes'])
			return false;

		$c = 0;
		$this->code = preg_replace('/(\s*<br\s*\/?>\s*)+/i', ' <br /> ', $this->code, -1, $c);
		$this->logMsgIf("strip_br_dupes", $c);

		return true;
	}

	protected function trim_br_tags ()
	{
		if(!is_array($this->config['trim_br_tags']))
			return false;

		$ct = $c = 0;
		$regex = '(' . implode('|', $this->config['trim_br_tags']) . ')';

		$this->code = preg_replace('/(\s*<br\s*\/?>\s*)+<(\/?)' . $regex . '([^>]*)>/is', '<\2\3\4> ', $this->code, -1, $c);
		$ct += $c;

		$this->code = preg_replace('/<(\/?)' . $regex . '([^>]*)>(\s*<br\s*\/?>\s*)+/is', '<\1\2\3> ', $this->code, -1, $c);
		$ct += $c;

		$this->logMsgIf("trim_br_tags", $c);

		return true;
	}

	protected function replace_tags ()
	{
		if(!is_array($this->config['replace_tags']))
			return false;

		$this->logMsg("=== replace_tags === ");

		$c = $ct = 0;
		foreach($this->config['replace_tags'] as $from => $to)
		{
			$this->code = preg_replace('/<(\/?)' . $from . '([\s>])/i', '<\1' . $to . '\2', $this->code, -1, $c);
			$ct += $c;
			$this->logMsg("$from = $to : $c ");
		}
		$this->logMsg("Changes made: $ct ");

		return true;
	}

	protected function dom_regenerate_tables ()
	{
		if (!$this->config['regenerate_tables'] || !$this->dom)
			return false;

		$tables = $this->dom->getElementsByTagName('table');
		$nrtbl = $tables->length;
		$this->logMsg("=== regenerate_tables === \nDOM tables: $nrtbl ");

		$remtables = array();
		for($i=0; $i < $nrtbl; $i++)
			$remtables[] = $tables->item($i);

		foreach($remtables as $i => $tbl)
		{
			$trs = $tbl->getElementsByTagName('tr');
			$nrtrs = $trs->length;
			$restable = array();
			$row = 0;
			for($z=0; $z<$nrtrs; $z++)
			{
				$tr = $trs->item($z);
				$tds = $tr->getElementsByTagName('td');
				$nrtds = $tds->length;
				$maxrow = 0;
				for($y=0; $y<$nrtds; $y++)
				{
					$td = $tds->item($y);
					$currow = 0;
					foreach($td->childNodes as $elem)
					{
						$clone = $elem->cloneNode(true);
						if($elem->nodeType == XML_ELEMENT_NODE && in_array($elem->nodeName, $this->config['regenerate_tables_tr']))
							$currow++;
						$r = $currow+$row;
						if(!isset($restable[$r]))
							$restable[$r] = array();
						if(!isset($restable[$r][$y]))
							$restable[$r][$y] = array();
						$restable[$r][$y][] = $clone;
					}
					if($currow > $maxrow)
						$maxrow = $currow;
				}
				$row += $maxrow;
			}

			$newtable = $this->dom->createElementNS(self::$xhtmlns, 'table');
			foreach($restable as $row)
			{
				$newtr = $this->dom->createElementNS(self::$xhtmlns, 'tr');
				foreach($row as $cell)
				{
					$newtd = $this->dom->createElementNS(self::$xhtmlns, 'td');
					foreach($cell as $elem)
					{
						$newtd->appendChild($elem);
					}
					$newtr->appendChild($newtd);
				}
				$newtable->appendChild($newtr);
			}
			$tbl->parentNode->insertBefore($newtable, $tbl);
		}
		reset($remtables);
		foreach($remtables as $i => $tbl)
			$tbl->parentNode->removeChild($tbl);

		return true;
	}

	protected function dom_fix_text_tags ()
	{
		if (!$this->dom || !$this->xpath || !is_array($this->config['fix_text_tags']))
			return false;

		$query = '//' . ReTidy::get_html_namespace() . implode('/text() | //' . ReTidy::get_html_namespace(), $this->config['fix_text_tags']) . '/text()';
		$nodes = $this->xpath->query($query);

		$this->logMsg("=== fix_text_tags === \nDOM nodes: " . $nodes->length);

		$ct = $c = 0;
		$regex_fq = '\"|\'|&quot;|&#034;|&apos;|&#039;|&lsquo;|&rsquo;';

		foreach($nodes as $child)
		{
			$child->nodeValue = preg_replace(
				array(
					// ,, = &quot;
					'/,,/', 

					// test2 , test = test2, test
					'/([^\.])\s*(,|\.|\?|\!|:)\s*([^\.0-9])/i',

					// test , test2 = test, test2
					'/([^\.0-9])\s*(,|\.|\?|\!|:)\s*([^\.])/i',

					// a ( b = a (b
					'/\s*\(\s*/i',

					// a ) . b = a). b
					'/\s*\)\s*(,|\.|\?|\!|:|;)*\s*/i',

					// 2 - 3 = 2-3
					'/(\d)\s*-\s*(\d)/i',

					// ( &quot; test " ) . = (&quot;test").
					'/\s*(\()?\s*('.$regex_fq.')(.+?)('.$regex_fq.')\s*(,|\.|\?|\!|;|\))*\s*/i',

					// a  / b = a/b
					'/\s*\/\s*/',

					// "2 % , " = "2%,"
					'/(\d)\s*%\s*(,|\.|;|:\?|\!)*\s*/',
				),
				array(
					'"',
					'\1\2 \3',
					'\1\2 \3',
					' (',
					')\1 ',
					'\1-\2',
					' \1\2\3\4\5 ',
					'/',
					'\1%\2 ',
				), $child->nodeValue, -1, $c);

			$ct += $c;
		}

		$this->logMsg("Changes made: $ct ");

		return true;
	}

	protected function dom_fix_headings ()
	{
		if (!$this->dom || !$this->xpath || !$this->config['fix_headings'])
			return false;

		$tags = $this->xpath->query('//' . ReTidy::get_html_namespace() . 'h1 | //' . ReTidy::get_html_namespace() . 'h2 | //' . ReTidy::get_html_namespace() . 'h3 | //' . ReTidy::get_html_namespace() . 'h4 | //' . ReTidy::get_html_namespace() . 'h5 | //' . ReTidy::get_html_namespace() . 'h6');

		$this->logMsg("=== fix_headings === \nDOM nodes: " . $tags->length);

		$c = 0;
		$heading = false;

		foreach($tags as $tag)
		{
			$nodeName = $tag->nodeName;

			if($heading && $heading < $nodeName{1} && ($heading+1) != $nodeName{1})
			{
				$tag->setAttribute('renametag', 'h' . ($heading+1));
				$c++;
			} else
				$heading = $nodeName{1};
		}

		$this->logMsg("Changes made: $c ");

		return true;
	}

	protected function dom_strip_child_tags ()
	{
		if (!$this->dom || !$this->xpath || !$this->config['strip_child_tags'])
			return false;

		$query = '';
		foreach($this->config['strip_tags'] as $parent => $childs)
		{
			if($parent == '*')
				continue;

			$query .= ' | //' . ReTidy::get_html_namespace() . $parent . '/' . ReTidy::get_html_namespace() . implode(' | //' . ReTidy::get_html_namespace() . $parent . '/' . ReTidy::get_html_namespace(), $childs);
		}
		$query{1} = ' ';
		$query = trim($query);

		$tags = $this->xpath->query($query);

		$this->logMsg("=== strip_child_tags (strip_tags[any_tag]) === \nDOM nodes: " . $tags->length);

		$c = array();

		foreach($tags as $tag)
		{
			$nodeName = $tag->nodeName;
			$pName = $tag->parentNode->nodeName;

			$tag->setAttribute('stripme', 'y');
			ReTidy::DOM_strip_node($tag);

			if(!isset($c[$pName]))
				$c[$pName] = array();

			if(!isset($c[$pName][$nodeName]))
				$c[$pName][$nodeName] = 0;

			$c[$pName][$nodeName]++;
		}

		foreach($c as $pName => $c2)
		{
			foreach($c2 as $nodeName => $n)
			{
				$this->logMsg("$pName > $nodeName : $n ");
			}
		}

		return true;
	}

	protected function dom_strip_attrs ()
	{
		if (!$this->dom || !$this->xpath || !is_array($this->config['strip_attrs']))
			return false;

		$query = '';
		foreach($this->config['strip_attrs'] as $tag => $attrs)
		{
			if($tag != '*')
			{
				$tag = ReTidy::get_html_namespace() . $tag;
				$query .= ' | //' . $tag . '/@' . implode(' | //' . $tag . '/@', $attrs);
			} else
				$query .= ' | //@' . implode(' | //@', $attrs);
		}

		$query{1} = ' ';
		$query = trim($query);

		$attrs = $this->xpath->query($query);

		foreach($attrs as $attr)
		{
			$elem = $attr->ownerElement;
			$elem->removeAttributeNode($attr);
		}

		$this->logMsg('strip_attrs ' . $attrs->length);

		return true;
	}

	protected function dom_strip_only_child ()
	{
		if (!$this->dom || !$this->xpath || !is_array($this->config['strip_only_child']))
			return false;

		$query = '';

		foreach($this->config['strip_only_child'] as $parent => $childs)
		{
			$query .= ' | //' . ReTidy::get_html_namespace() . $parent . '/' . ReTidy::get_html_namespace() . implode('[count(..)=1] | //' . ReTidy::get_html_namespace() . $parent . '/' . ReTidy::get_html_namespace(), $childs) . '[count(..)=1]';
		}

		$query{1} = ' ';
		$query = trim($query);

		$tags = $this->xpath->query($query);
		if(!$tags || !$tags->length)
			return false;

		$this->logMsg("=== strip_only_child === \nDOM nodes: " . $tags->length);

		$c = array();

		foreach($tags as $tag)
		{
			$nodeName = $tag->nodeName;
			$pName = $tag->parentNode->nodeName;

			$tag->setAttribute('stripme', 'y');
			ReTidy::DOM_strip_node($tag);

			if(!isset($c[$pName]))
				$c[$pName] = array();

			if(!isset($c[$pName][$nodeName]))
				$c[$pName][$nodeName] = 0;

			$c[$pName][$nodeName]++;
		}

		foreach($c as $pName => $c2)
		{
			foreach($c2 as $nodeName => $n)
			{
				$this->logMsg("$pName > $nodeName : $n ");
			}
		}

		return true;
	}

	protected function dom_strip_parent_only_child ()
	{
		if (!$this->dom || !$this->xpath || !is_array($this->config['strip_parent_only_child']))
			return false;

		$query = '';

		foreach($this->config['strip_parent_only_child'] as $parent => $childs)
		{
			$query .= ' | //' . ReTidy::get_html_namespace() . $parent . '/' . ReTidy::get_html_namespace() . implode('[count(..)=1] | //' . ReTidy::get_html_namespace() . $parent . '/' . ReTidy::get_html_namespace(), $childs) . '[count(..)=1]';
		}

		$query{1} = ' ';
		$query = trim($query);

		$tags = $this->xpath->query($query);
		if(!$tags || !$tags->length)
			return false;

		$this->logMsg("=== strip_parent_only_child === \nDOM nodes: " . $tags->length);

		$c = array();

		foreach($tags as $tag)
		{
			$nodeName = $tag->nodeName;
			$pName = $tag->parentNode->nodeName;

			$tag->parentNode->setAttribute('stripme', 'y');
			ReTidy::DOM_strip_node($tag->parentNode);

			if(!isset($c[$pName]))
				$c[$pName] = array();

			if(!isset($c[$pName][$nodeName]))
				$c[$pName][$nodeName] = 0;

			$c[$pName][$nodeName]++;
		}

		foreach($c as $pName => $c2)
		{
			foreach($c2 as $nodeName => $n)
			{
				$this->logMsg("$pName > $nodeName : $n ");
			}
		}

		return true;
	}

	protected function dom_merge_parent_attr ()
	{
		if (!$this->dom || !$this->xpath || !is_array($this->config['merge_parent_attr']))
			return false;

		$query = '';

		foreach($this->config['merge_parent_attr'] as $tag)
		{
			$query .= ' | //' . ReTidy::get_html_namespace() . $tag . '/' . ReTidy::get_html_namespace() . $tag . '[count(..)=1 and @*]';
		}

		$query{1} = ' ';
		$query = trim($query);

		$tags = $this->xpath->query($query);
		if(!$tags || !$tags->length)
			return false;

		$this->logMsg("=== merge_parent_attr === \nDOM nodes: " . $tags->length);

		$c = array();

		foreach($tags as $tag)
		{
			$nodeName = $tag->nodeName;
			$pNode = $tag->parentNode;

			foreach($tag->attributes as $attr)
			{
				$pNode->setAttribute($attr->name, $attr->value);
			}
			$tag->setAttribute('stripme', 'y');
			ReTidy::DOM_strip_node($tag);

			if(!isset($c[$nodeName]))
				$c[$nodeName] = 0;

			$c[$nodeName]++;
		}

		foreach($c as $nodeName => $c2)
		{
			$this->logMsg("$nodeName : $c2 ");
		}

		return true;
	}
	
	protected function DOM_table_accessibility() {
		ReTidy::DOM_remove_table_accessibility();
		ReTidy::dom_save();
	
		ReTidy::post_dom();
		
		ReTidy::dom_init();
		ReTidy::DOM_apply_table_accessibility();
		//file_put_contents("page_id_counter.txt", $this->page_id_counter);
	}

	protected function DOM_table_headers_and_ids_to_scope($table) {
		//print('$this->table_grid: ');var_dump($this->table_grid);
		$index = 1;
		//foreach($this->table_grid as $index => $column) {
		while($index <= sizeof($this->table_grid)) {
			$column = $this->table_grid[$index];
			//foreach($column as $index2 => $value2) {
			$index2 = 1;
			while($index2 <= sizeof($column)) {
				$grid_cell = $column[$index2][0];
				//print('$grid_cell: ');var_dump(ReTidy::DOM_getNodeString($grid_cell));
				//print('getRowspan 1<br>');
				$grid_cell_rowspan = ReTidy::getRowspan($grid_cell);
				$grid_cell_colspan = ReTidy::getColspan($grid_cell);
				$grid_cell_id = ReTidy::getAttribute($grid_cell, 'id')->nodeValue;
				//print('$index, $index2, $grid_cell_rowspan, $grid_cell_colspan: ');var_dump($index, $index2, $grid_cell_rowspan, $grid_cell_colspan);
				if($grid_cell->nodeName === 'th' || ReTidy::getAttribute($grid_cell, 'newtag')->nodeValue === 'th') {
					//print('Found a th!');exit(0);
					$grid_cell_scope = ReTidy::getScope($grid_cell);
					//print('$grid_cell_scope: ');var_dump($grid_cell_scope);
					if($grid_cell_scope != false) { // it was already done
						$index2 += $grid_cell_rowspan;
						continue;
						print('skipping for scope');
					}
					$grid_cell_new_tbody_attribute = ReTidy::getAttribute($grid_cell, 'new_tbody')->nodeValue;
					if($grid_cell_new_tbody_attribute && $grid_cell_new_tbody_attribute === 'true') {
						$each_cell_in_this_row_has_the_headers_entry = false;
					} else {
						$x = $index + $grid_cell_colspan;
						if($x > sizeof($this->table_grid)) {
							$each_cell_in_this_row_has_the_headers_entry = false;
						} else {
							$each_cell_in_this_row_has_the_headers_entry = true;
							while($x <= sizeof($this->table_grid)) {
								//print('$x, sizeof($this->table_grid): ');var_dump($x, sizeof($this->table_grid));
								$headers_cell = $this->table_grid[$x][$index2][0];
								//print('cell in this row: ');var_dump(ReTidy::DOM_getNodeString($headers_cell));
								$headers_cell_header_attribute = ReTidy::getAttribute($headers_cell, 'headers')->nodeValue;
								if($headers_cell_header_attribute && ReTidy::contains_whole_word_for_styles($headers_cell_header_attribute, $grid_cell_id) !== false) {
									//print('Found a headers attribute in cell in this row for the id!<br>');
								} else {
									//print('Did not find a headers attribute in cell in this row for the id!<br>');
									$each_cell_in_this_row_has_the_headers_entry = false;
									break;
								}
								$x++;
							}
						}
					}
					if($grid_cell_new_tbody_attribute && $grid_cell_new_tbody_attribute === 'true') {
						$each_cell_in_this_column_has_the_headers_entry = true;
					} else {
						$y = $index2 + $grid_cell_rowspan;
						if($y > sizeof($column)) {
							$each_cell_in_this_column_has_the_headers_entry = false;
						} else {
							$each_cell_in_this_column_has_the_headers_entry = true;
							while($y <= sizeof($column)) {
								$headers_cell = $this->table_grid[$index][$y][0];
								//print('cell in this column: ');var_dump(ReTidy::DOM_getNodeString($headers_cell));
								$headers_cell_new_tbody_attribute = ReTidy::getAttribute($headers_cell, 'new_tbody')->nodeValue;
								$headers_cell_new_tfoot_attribute = ReTidy::getAttribute($headers_cell, 'new_tfoot')->nodeValue;
								if($headers_cell_new_tbody_attribute && $headers_cell_new_tbody_attribute === 'true') {
									//print('Found a new_tbody attribute in cell in this column!<br>');
								} elseif($headers_cell_new_tfoot_attribute && $headers_cell_new_tfoot_attribute === 'true') {
									//print('Found a new_tfoot attribute in cell in this column!<br>');
									if($index2 === sizeof($column) - 1) {
										$each_cell_in_this_column_has_the_headers_entry = false;
										break;
									}
								} else {
									$headers_cell_header_attribute = ReTidy::getAttribute($headers_cell, 'headers')->nodeValue;
									if($headers_cell_header_attribute && ReTidy::contains_whole_word_for_styles($headers_cell_header_attribute, $grid_cell_id) !== false) {
										//print('Found a headers attribute in cell in this column for the id!<br>');
									} else {
										//print('Did not find a headers attribute in cell in this column for the id!<br>');
										$each_cell_in_this_column_has_the_headers_entry = false;
										break;
									}
								}
								$y++;
							}
						}
					}
					if($each_cell_in_this_row_has_the_headers_entry) {
						if($each_cell_in_this_column_has_the_headers_entry) {
							// take a guess and go for column
							if($grid_cell_colspan > 1) {
								$grid_cell->setAttribute('scope', 'colgroup');
							} else {
								$grid_cell->setAttribute('scope', 'col');
							}
							ReTidy::warning('Found a table header id that converts to both row and col scope.');
							print('$grid_cell: ');var_dump(ReTidy::DOM_getNodeString($grid_cell));
						} else {
							if($grid_cell_rowspan > 1) {
								$grid_cell->setAttribute('scope', 'rowgroup');
							} else {
								$grid_cell->setAttribute('scope', 'row');
							}
						}
					} elseif($each_cell_in_this_column_has_the_headers_entry) {
						if($grid_cell_colspan > 1) {
							$grid_cell->setAttribute('scope', 'colgroup');
						} else {
							$grid_cell->setAttribute('scope', 'col');
						}
					} else {
						ReTidy::warning('Found a table header id that isn\'t convertable to row or col scope.');
					}
				}
				$index2 += $grid_cell_rowspan;
			}
			$index++;
		}
		$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
		$cells = $this->xpath->query($query, $table);
		foreach($cells as $cell) {
			if($cell->hasAttributes()) {
				foreach($cell->attributes as $attribute) {
					if($attribute->nodeName === "headers") {
						$attribute->nodeValue = "XXX9o9stripme9o9XXX";
					}
					if($attribute->nodeName === "id" && strpos($attribute->nodeValue, $this->config['table_headers_string']) === 0) {
						$attribute->nodeValue = "XXX9o9stripme9o9XXX";
					}
				}
			}
		}
	}
	
	protected function DOM_remove_table_accessibility() {
		$query = '//' . ReTidy::get_html_namespace() . 'table';
		$tables = $this->xpath->query($query);
		foreach($tables as $table) {
			$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
			$cells = $this->xpath->query($query, $table);
			foreach($cells as $cell) {
				if($cell->hasAttributes()) {
					foreach($cell->attributes as $attribute) {
						if($attribute->nodeName === "headers" || $attribute->nodeName === "scope") {
							$attribute->nodeValue = "XXX9o9stripme9o9XXX";
						}
						if($attribute->nodeName === "id" && strpos($attribute->nodeValue, $this->config['table_headers_string']) === 0) {
							$attribute->nodeValue = "XXX9o9stripme9o9XXX";
						}
					}
				}
				if(Retidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
					$cell->setAttribute('newtag', 'td');
				}
			}
			if($this->config['trust_ths'] === false) { // remove thead, tbody
				//$query = './/' . ReTidy::get_html_namespace() . 'thead | .//' . ReTidy::get_html_namespace() . 'tfoot | .//' . ReTidy::get_html_namespace() . 'tbody';
				$query = './/' . ReTidy::get_html_namespace() . 'thead | .//' . ReTidy::get_html_namespace() . 'tbody';
				$table_structuring_tags = $this->xpath->query($query, $table);
				foreach($table_structuring_tags as $table_structuring_tag) {
					ReTidy::DOM_strip_node($table_structuring_tag);
				}
			}
		}
	}
	
	protected function force_headings () {
		$count = 0;
		//$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h6><a name="$4_$5_$6_$7_$8" id="$4_$5_$6_$7_$8"></a>$4.$5.$6.$7.$8$9$10</h6>', $this->code, -1, $ct1);
		//$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h5><a name="$4_$5_$6_$7" id="$4_$5_$6_$7"></a>$4.$5.$6.$7$8$9</h5>', $this->code, -1, $ct2);
		//$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h4><a name="$4_$5_$6" id="$4_$5_$6"></a>$4.$5.$6$7$8</h4>', $this->code, -1, $ct3);
		//$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})\.([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h3><a name="$4_$5" id="$4_$5"></a>$4.$5$6$7</h3>', $this->code, -1, $ct4);
		//$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h2><a name="$4" id="$4"></a>$4$5$6</h2>', $this->code, -1, $ct5);

		//$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*(section )*([0-9]{1,2})(\.*0*\.*)(' . $this->nonBreakingSpaceRegex . ')*:(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h2><a name="$5" id="$5"></a>$4$5$6$7:$8</h2>', $this->code, -1, $ct6);
		//$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*(chapter )*([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h2><a name="$5" id="$5"></a>$4$5$6$7</h2>', $this->code, -1, $ct7);
		
		// changed (2011-06-27); the name attribute is deprecated and validators are starting to complain more and old browsers and javascripts are hopefully being used less
		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h6 id="$4_$5_$6_$7_$8">$4.$5.$6.$7.$8$9$10</h6>', $this->code, -1, $ct1);
		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h5 id="$4_$5_$6_$7">$4.$5.$6.$7$8$9</h5>', $this->code, -1, $ct2);
		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h4 id="$4_$5_$6">$4.$5.$6$7$8</h4>', $this->code, -1, $ct3);
		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})\.([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h3 id="$4_$5">$4.$5$6$7</h3>', $this->code, -1, $ct4);
		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h2 id="$4">$4$5$6</h2>', $this->code, -1, $ct5);

		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*(section )*([0-9]{1,2})(\.*0*\.*)(' . $this->nonBreakingSpaceRegex . ')*:(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h2 id="$5">$4$5$6$7:$8</h2>', $this->code, -1, $ct6);
		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*(chapter )*([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h2 id="$5">$4$5$6$7</h2>', $this->code, -1, $ct7);
		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6)[^<>]*>(\s*<strong>)*\s*(<a[^<>]*><\/a>\s*)*(chp )*([0-9]{1,2})(\.*0*\.*)(\s{1,}.*?)(<\/strong>\s*)*<\/\1>/is', '<h2 id="$5">$4$5$6$7</h2>', $this->code, -1, $ct8);
		$count += $ct1 += $ct2 += $ct3 += $ct4 += $ct5 += $ct6 += $ct7 += $ct8;
		$this->logMsgIf(force_headings, $count);
		return true;
	}	
	
	protected function firstNonAttributeChild($node) {
		foreach($node->childNodes as $childNode) {
			if($childNode->nodeType === 2) {
				
			} else {
				return $childNode;
			}
		}
		return false;
	}
	
	protected function getFirstNonAttributeChild($node) {
		return ReTidy::firstNonAttributeChild($node);
	}
	
	protected function isEmptyElement($tag) {
		if($tag->nodeType === 1) {
			return ReTidy::isEmptyTag($tag);
		}
		return false;
	}
	
	protected function isEmpty($var) {
		if(is_string($var)) {
			return strlen($var);
		}
		if(ReTidy::isNode($var)) {
			return ReTidy::isEmptyTag($var);
		}
		return false;
	}
	
	function isNode($var) {
		if($var->nodeType && $var->nodeType < 13) {
			return true;
		}
		return false;
	}
	
	protected function isEmptyIgnoringWhitespaceAndAttributes($tag) {
		return ReTidy::isEmptyTagIgnoringWhitespaceAndAttributes($tag);
	}
	
	protected function isEmptyTagIgnoringWhitespaceAndAttributes($tag) {
		$count177 = 0;
		if($tag->hasChildNodes()) {
			foreach($tag->childNodes as $child) {
				if($child->nodeType === 2) {
					// ignore attributes
					continue;
				}
				// very questionable; what if there is simple white space instead of a non-breaking space entity?
				if($child->nodeType === 3 && strlen(trim($child->textContent)) > 0) {
					if($child->nodeValue === "XXX9o9Ampersand9o9XXXnbsp;" || $child->nodeValue === "XXX9o9Ampersand9o9XXX#160;" || 
					$child->nodeValue === "XXX9o9Ampersand9o9XXX#xa0;" || $child->nodeValue === "XXX9o9Ampersand9o9XXX#xA0;" || 
					$child->nodeValue === html_entity_decode('&nbsp;')) {
						continue;
					}
				}
				if($child->nodeType == 5 && ($child->nodeName === "nbsp" || $child->nodeName === "#160" || $child->nodeName === "#xa0" || $child->nodeName === "#xA0")) {
					continue;
				}
				$count177++;
			}
		} else {
			return true;		
		}
		if($count177 === 0) {
			return true;
		}
		return false;
	}

	protected function isEmptyTag($tag) {
		$count177 = 0;
		if($tag->hasChildNodes()) {
			foreach($tag->childNodes as $child) {
				if(!ReTidy::isWhitespace($child)) {
					$count177++;
				}
			}
		} else {
			return true;		
		}		
		if($count177 === 1) {
			if($child->nodeType == 5 && $child->nodeName === "nbsp") {
				return true;
			}
			if($child->nodeType == 3 && $child->nodeValue === "XXX9o9Ampersand9o9XXXnbsp;") {
				return true;
			}
		}
		return false;
	}
	
	protected function clean_rtf_from_jade_tables() {
		//$this->code = preg_replace('/style=\'[^\']*\'/', '', $this->code, -1, $c);
		//$this->code = preg_replace('/class=[^\s<>]*/', '', $this->code, -1, $d);
		//$this->code = preg_replace('/colspan=[0-9]*/', '', $this->code, -1, $e);
		//$this->code = preg_replace('/width=[0-9]*/', '', $this->code, -1, $f);
		//$this->code = str_replace('<p  >', '', $this->code, $g);
		//$this->code = str_replace('<span >', '', $this->code, $h);
		//$this->code = str_replace('</p>', '', $this->code, $i);
		//$this->code = str_replace('</span>', '', $this->code, $j);
		//$this->code = str_replace('<p >', '', $this->code, $k);		
		// INAC1168
		if($this->language === "english") {
		$this->code = preg_replace('/<tr>\s*<td([^<>]*)>\s*<b>ACTIVITIES<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<b>RESPONSIBILITY<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<b>TIMING GUIDELINES<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*1\./', '</table>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td$1 colspan="2"><b>ACTIVITIES</b></td>
<td$2><b>RESPONSIBILITY</b></td>
<td$3><b>TIMING GUIDELINES</b></td>
</tr>
<tr>
<td$10>1.', $this->code, -1, $l);
		$this->code = preg_replace('/<tr>\s*<td([^<>]*)>\s*<b>ACTIVITIES<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<b>RESPONSIBILITY<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<b>TIMING GUIDELINES<\/b>\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*1\./', '</table>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td$1 colspan="2"><b>ACTIVITIES</b></td>
<td$2><b>RESPONSIBILITY</b></td>
<td$3><b>TIMING GUIDELINES</b></td>
</tr>
<tr>
<td$9>1.', $this->code, -1, $m);
		}
		if($this->language === "french") {
		print("<h1>french</h1>");
		$this->code = preg_replace('/<tr>\s*<td([^<>]*)>\s*<b>ACTIVITÉS<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<b>RESPONSABILITÉ<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<b>HORIZON<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*<b>TEMPOREL<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*1\./', '</table>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td$1 colspan="2"><b>ACTIVITÉS</b></td>
<td$2><b>RESPONSABILITÉ</b></td>
<td$3><b>HORIZON TEMPOREL</b></td>
</tr>
<tr>
<td$10>1.', $this->code, -1, $n);
		$this->code = preg_replace('/<tr>\s*<td([^<>]*)>\s*<b>ACTIVITÉS<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<b>RESPONSABILITÉ<\/b>\s*<\/td>\s*<td([^<>]*)>\s*<b>HORIZON<\/b>\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*<b>TEMPOREL<\/b>\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<td([^<>]*)>\s*&nbsp;\s*<\/td>\s*<\/tr>\s*<tr>\s*<td([^<>]*)>\s*1\./', '</table>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td$1 colspan="2"><b>ACTIVITÉS</b></td>
<td$2><b>RESPONSABILITÉ</b></td>
<td$3><b>HORIZON TEMPOREL</b></td>
</tr>
<tr>
<td$9>1.', $this->code, -1, $o);		
		}
		//$this->code = preg_replace('/<span\s*>/', '', $this->code, -1, $p);
		$this->code = preg_replace('/<tr height="0">.*?<\/tr>/', '', $this->code, -1, $q);
		
		$this->logMsgIf("clean_rtf_from_jade_tables", $c + $d + $e + $f + $g + $h + $i + $j + $k + $l + $m + $n + $o + $p + $q);
	}

	protected function isEmptyTR($tr) {
		if($tr->hasChildNodes()) {
			foreach($tr->childNodes as $child) {
				if($child->nodeType === 1) {
					if(ReTidy::isEmptyElement($child)) {
					
					} else {
						return false;
					}
				}
			}
			return true;
		} else {
			return true;
		}
		return false;
	}
	
	protected function DOM_decoded_for_DOM_child_of($node) {
		$string = ReTidy::DOM_getNodeString($node);
		$string = preg_replace('/<(\w*)[^<>]*>(.*?)<\/\1>/is', '$2', $string);
		$string = ReTidy::decode_for_DOM($string);
		return $string;
	}
	
	protected function decode_for_DOM_all_character_entities() {
		$this->code = ReTidy::decode_for_DOM_character_entities($this->code);
	}
	
	protected function decode_for_DOM_character_entities($string) {
		return preg_replace('/&([a-zA-Z0-9#]+);/is', 'XXX9o9CharacterEntityXXX${1}9o9XXX', $string);
	}
	
	protected function encode_for_DOM_all_character_entities() {
		$this->code = ReTidy::encode_for_DOM_character_entities($this->code);
	}
	
	protected function encode_for_DOM_character_entities($string) {
		return preg_replace('/XXX9o9CharacterEntityXXX(.*?)9o9XXX/is', '&$1;', $string);
	}

	protected function decode_for_DOM_all() {
		$this->code = ReTidy::decode_for_DOM($this->code);
	}

	protected function decode_for_DOM_not_entities($string) {
		//$string = ReTidy::decode_for_DOM_character_entities($string);
		$replaceArray = array(
		'<' => 'XXX9o9LeftAngleBracket9o9XXX',
		'>' => 'XXX9o9RightAngleBracket9o9XXX',		
		//'&' => 'XXX9o9Ampersand9o9XXX',
		'\'' => 'XXX9o9SingleQuote9o9XXX',
		'"' => 'XXX9o9DoubleQuote9o9XXX',
		);
		foreach($replaceArray as $search => $replace) {
			$string = str_replace($search, $replace, $string);
		}
		return $string;
	}	

	protected function decode_for_DOM($string) {
		$string = ReTidy::decode_for_DOM_character_entities($string);
		$replaceArray = array(
		'<' => 'XXX9o9LeftAngleBracket9o9XXX',
		'>' => 'XXX9o9RightAngleBracket9o9XXX',		
		'&' => 'XXX9o9Ampersand9o9XXX',
		'\'' => 'XXX9o9SingleQuote9o9XXX',
		'"' => 'XXX9o9DoubleQuote9o9XXX',
		);
		foreach($replaceArray as $search => $replace) {
			$string = str_replace($search, $replace, $string);
		}
		return $string;
	}
	
	protected function decode_for_DOM_all_inline() {
		$this->code = ReTidy::decode_for_DOM_inline($this->code);
		//print('here3546358<br>');
	}
	
	protected function decode_for_DOM_inline($string) {
		$allBlockOStringArrays = OM::getAllBlockOStrings_for_structure($this->code);
		//var_dump($allBlockOStringArrays);exit(0);
		foreach($allBlockOStringArrays as $blockOStringArray) {
			$inline_decoded = $initial_string = $blockOStringArray[0];
			$strpos_first_close = strpos($inline_decoded, '>');
			$strpos_last_open = ReTidy::strpos_last($inline_decoded, '<');
			$opening_tag = substr($inline_decoded, 0, $strpos_first_close + 1);
			$closing_tag = substr($inline_decoded, $strpos_last_open);
			$part_to_decode = substr($inline_decoded, $strpos_first_close + 1, $strpos_last_open - $strpos_first_close - 1);
			$part_to_decode = ReTidy::decode_for_DOM_not_entities($part_to_decode);
			$inline_decoded = $opening_tag . $part_to_decode . $closing_tag;
			//print('$initial_string: ');var_dump($initial_string);
			//print('$inline_decoded: ');var_dump($inline_decoded);
			$string = str_replace($initial_string, $inline_decoded, $string);
			//print('here3546357<br>');
		}
		return $string;
	}
	
	protected function encode_for_DOM_all() {
		$this->code = ReTidy::encode_for_DOM($this->code);
	}

	protected function encode_for_DOM($string) {
		$string = ReTidy::encode_for_DOM_character_entities($string);
		$replaceArray = array(
		'XXX9o9LeftAngleBracket9o9XXX' => '<',
		'XXX9o9RightAngleBracket9o9XXX' => '>',		
		'XXX9o9Ampersand9o9XXX' => '&',
		'XXX9o9SingleQuote9o9XXX' => '\'',
		'XXX9o9DoubleQuote9o9XXX' => '"',
		);
		foreach($replaceArray as $search => $replace) {
			$string = str_replace($search, $replace, $string);
		}
		return $string;
	}		

	protected function DOM_flipLists() { 
		$lists_to_flip = $this->xpath->query('//' . ReTidy::get_html_namespace() . 'ol[contains(concat(" ", @class, " "), concat(" ", "fliplist", " "))] | //' . ReTidy::get_html_namespace() . 'ul[contains(concat(" ", @class, " "), concat(" ", "fliplist", " "))]');
		foreach($lists_to_flip as $list) {
			// assuming the list is valid, then there should only be <li>s in it.
			$array_lis = array();
			$lis = $this->xpath->query('./' . ReTidy::get_html_namespace() . 'li', $list);
			foreach($lis as $li) {
				$array_lis[] = $li;
			}
			$array_lis = array_reverse($array_lis);
			$new_list = $list->cloneNode();
			$list->setAttribute('deleteme', 'y');
			$list->parentNode->insertBefore($new_list, $list);
			foreach($array_lis as $li) {
				$new_list->appendChild($li);
			}
			// remove flip list marker
			// notice that tidy or DOM would remove it since it is not a valid attribute.
		}
	}
	
	protected function create_latin1_entities_exhausting_document() {
		// is it sufficient to only take the entities in the DTD?
		//var_dump(get_html_translation_table());
		//print("1");
		//<!ENTITY nbsp   "&#160;">
		//var_dump(file_get_contents("DTD/xhtml-lat1.ent"));
		//$contents = file_get_contents("DTD/xhtml-lat1.ent");
		//$contents = file_get_contents("mappings/latin1.php");
		include('mappings' . DS . 'latin1.php');
		//var_dump($latin1array);exit(0);
		foreach($latin1array as $index => $value) {
			foreach($value as $index2 => $value2) {
				print($value2 . " ");
			}
			print("<br>\r\n");
		}exit(0);
		//var_dump($contents);exit(0);
		//preg_match_all('/<!ENTITY\s+([^\s]+)\s+"([^"]+)">/is', $contents, $matches);
		//foreach($matches[0] as $index => $value) {
		//	print(html_entity_decode($matches[2][$index]) . " &" . $matches[1][$index] . "; " . $matches[2][$index] . "\r\n");
		//}
		//var_dump($matches);
		//var_dump(htmlentities("Équipe à l&rsquo;exécution"));
	}
	
	protected function encode_character_entities() {
		$count = 0;
		//include('mappings' . DS . 'latin1.php');
		ReTidy::entities_init();
		if($this->config['character_entity_encoding_type'] === "decimal") {
			$encode_index = 1;
		} elseif($this->config['character_entity_encoding_type'] === "hexadecimal") {
			$encode_index = 2;
		} else { // default to named character entities
			$encode_index = 3;
		}
		foreach($this->entities_array as $index => $value) {
			foreach($value as $index2 => $value2) {
				if($encode_index === $index2) {
					continue;
				}
				// do not use  . "//TRANSLIT" in the line below as it may destroy the file...
				//$this->code = str_replace(iconv("iso-8859-1", $this->config['encoding'], $value2), $value[$encode_index], $this->code, $ct);
				$this->code = str_replace($value2, $value[$encode_index], $this->code, $ct);
				$count += $ct;
			}
		}
		$this->logMsgIf("character entities encoded", $count);
	}
	
	protected function decode_character_entities() {
		$count = 0;
		//include('mappings' . DS . 'latin1.php');
		ReTidy::entities_init();
		$encode_index = 0;
		//print('$this->entities_array: ');ReTidy::var_dump_full($this->entities_array);
		//$code_before_replaces = $this->code;
		foreach($this->entities_array as $index => $value) {
			foreach($value as $index2 => $value2) {
				if($encode_index === $index2) {
					continue;
				}
				//$this->code = str_replace($value2, iconv("iso-8859-1", $this->config['encoding'] . "//TRANSLIT", $value[$encode_index]), $this->code, $ct);
				$this->code = str_replace($value2, $value[$encode_index], $this->code, $ct);
				$count += $ct;
			}
		}
		//if($code_before_replaces === $this->code) { // debug
		//	ReTidy::fatal_error('the code is unchanged in decode_character_entities');
		//}
		//print('$this->code after decode_character_entities: ');ReTidy::var_dump_full($this->code);exit(0);
		$this->logMsgIf("character entities decoded", $count);
	}
	
	protected function firstElementChild($node) { return ReTidy::getFirstElementChild($node); }
	
	protected function lastElementChild($node) { return ReTidy::getlastElementChild($node); }
	
	protected function getFirstElementChild($node) {
		$nextElement = $node->firstChild;
		while($nextElement) {
			if($nextElement->nodeType === 1) {
				return $nextElement;
			}
			$nextElement = ReTidy::nextElement($nextElement);
		}
		return false;
	}

	protected function getlastElementChild($node) {
		$previousElement = $node->lastChild;
		while($previousElement) {
			if($previousElement->nodeType === 1) {
				return $previousElement;
			}
			$previousElement = ReTidy::previousElement($previousElement);
		}
		return false;
	}
	
	protected function hasABulletForThePurposesOfTableSourceInformation($string) {
		preg_match('/' . $this->order_indicator_regex_without_exceptions . '/is', $string, $bullet_matches);
		if(strlen($bullet_matches[1]) > 0) {
			return true;
		}
		return false;
	}
	
	protected function DOM_clean_tables() {
		$query = '//' . ReTidy::get_html_namespace() . 'table';
		$tables = $this->xpath->query($query);
		foreach($tables as $table) {
			ReTidy::DOM_clean_table($table);			
		}	
	}	
	
	protected function DOM_strip_one_cell_table($table) {
		$table->setAttribute("stripme", "y");
		ReTidy::DOM_strip_node($table);
		$query = ReTidy::get_html_namespace() . 'tr | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr | ' . ReTidy::get_html_namespace() . 'thead | ' . ReTidy::get_html_namespace() . 'tfoot | ' . ReTidy::get_html_namespace() . 'tbody | ' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td';
		$containers = $this->xpath->query($query, $table);
		foreach($containers as $container) {
			$container->setAttribute("stripme", "y");
			ReTidy::DOM_strip_node($container);
		}
	}
	
	protected function DOM_strip_all_but_datum_of_one_datum_table($table, $datum_cell) {
		$table->setAttribute("stripme", "y");
		ReTidy::DOM_strip_node($table);
		$query = ReTidy::get_html_namespace() . 'tr | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr | ' . ReTidy::get_html_namespace() . 'thead | ' . ReTidy::get_html_namespace() . 'tfoot | ' . ReTidy::get_html_namespace() . 'tbody | ' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th';
		$tags = $this->xpath->query($query, $table);
		foreach($tags as $tag) {
			if($tag !== $datum_cell) {
				$tag->setAttribute("stripme", "y");
				ReTidy::DOM_strip_node($tag);
			}
		}
	}
	
	protected function DOM_clean_table($table) {
		
		// unstyled <div>s on tables
		$parentNode = $table->parentNode;
		if($parentNode->nodeName === "div" && ReTidy::DOM_isConflationaryWithParentIgnoringWhitespace($table) && !$parentNode->hasAttributes()) {
			$parentNode->setAttribute("stripme", "y");
			ReTidy::DOM_strip_node($parentNode);
		}
		
		// empty tables...
		if(ReTidy::isEmptyElement($table)) {
			$table->setAttribute("stripme", "y");
			ReTidy::DOM_strip_node($table);
			return true;
		}
		
		// tables with only one datum
		$border_attribute = ReTidy::getAttribute($table, "border");
		//$blockString = DTD::getBlock();
		//$query = ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th';
		$query = ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td';
		$cells = $this->xpath->query($query, $table);
		$count_cells = $count_empty_cells = 0;
		$last_cell_with_content = false;
		foreach($cells as $cell) {
			$count_cells++;
			if(ReTidy::isEmptyElement($cell)) {
				$count_empty_cells++;
			} else {
				$last_cell_with_content = $cell;
			}
		}
		//if($count_cells - $count_empty_cells < 2 && isset($last_cell_with_content)) {
		if($count_cells - $count_empty_cells < 2) {
			/*$table->setAttribute("deleteme", "y");
			$firstElementChild = ReTidy::getFirstElementChild($last_cell_with_content);
			$isConflationaryBlock = false;
			// notice that this is not smart enough to catch multiple block elements as the single datum in a table.
			if($firstElementChild && ReTidy::DOM_isConflationaryWithParentIgnoringWhitespace($firstElementChild)) {
				foreach(explode("|", $blockString) as $blockName) {
					if($blockName === $firstElementChild->nodeName) {
						$isConflationaryBlock = true;
						break;
					}
				}
			}
			if($isConflationaryBlock) {
				$new_node = $firstElementChild->cloneNode(true);
			} else {
				$last_cell_with_content->setAttribute("divme", "y");
				$new_node = $last_cell_with_content->cloneNode(true);
			}*/
			if($border_attribute !== false) {
				//var_dump($border_attribute->nodeValue);
				if($border_attribute->nodeValue == 0) {
					// do nothing
					//$last_cell_with_content->setAttribute("divme", "stripme");
					//$last_cell_with_content->setAttribute("stripme", "y");
					//ReTidy::DOM_strip_node($last_cell_with_content);
					ReTidy::DOM_strip_one_cell_table($table);
				} else {
					if($last_cell_with_content !== false) {
						$last_cell_with_content->setAttribute("divme", "y");
						ReTidy::addStyleWithoutOverwrite($last_cell_with_content, "border: " . $border_attribute->nodeValue . "px solid black;");
						ReTidy::DOM_strip_all_but_datum_of_one_datum_table($table, $last_cell_with_content);
					}
				}
			} else {
				ReTidy::DOM_strip_one_cell_table($table);
			}
			//$table->parentNode->insertBefore($new_node, $table);
		}
		
		// eliminate layout tables (at least the kind that is only one cell with a table in it)
		// seems to be taken care of by the above
		/*$query = ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'tr/' . ReTidy::get_html_namespace() . 'th';
		$cells = $this->xpath->query($query, $table);
		$count_cells = 0;
		foreach($cells as $cell) {
			$count_cells++;
		}
		if($count_cells === 1) {
			$query = '//' . ReTidy::get_html_namespace() . 'table';
			$tables_in_single_cell = $this->xpath->query($query, $table);
			$count_tables_in_single_cell = 0;
			foreach($tables_in_single_cell as $table_in_single_cell) {
				$count_tables_in_single_cell++;
				break;
			}
			if($count_tables_in_single_cell > 0) {
				ReTidy::DOM_strip_one_cell_table($table);
			}
		}*/
		
		/*
		// take "captions" out of tables
		$query = ReTidy::get_html_namespace() . 'thead';
		$theads = $this->xpath->query($query, $table);
		foreach($theads as $thead) {
			$query = ReTidy::get_html_namespace() . 'tr[1]';
			$first_tr_in_theads = $this->xpath->query($query, $thead);
			foreach($first_tr_in_theads as $first_tr_in_thead) {
				// (there should only be one <thead> and only one first <tr> therein.
			}
		}
		if($first_tr_in_thead) {
			$first_tr_table = $first_tr_in_thead;
		} else {
			$query = ReTidy::get_html_namespace() . 'tr[1]';
			$first_tr_tables = $this->xpath->query($query, $table);
			foreach($first_tr_tables as $first_tr_table) {

			}
		}
		$query = ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'th';
		$cells_in_first_tr = $this->xpath->query($query, $first_tr_table);
		foreach($cells_in_first_tr as $cell_in_first_tr) {
			$count429++;
		}
		if(strpos(trim(ReTidy::tagless($first_tr_table)), "Table") === 0 && $count429 === 1) {
			// then we want to take the caption out of the table
			if($thead) {
				// not sure if this is right since a thead could encompass many rows.
				//$thead->setAttribute("deleteme", "y");
				// so:
				//$thead->setAttribute("stripme", "y");
				//ReTidy::DOM_strip_node($thead);
				// maybe we do not want to do this at all
			}
			if($this->config['turn_captions_into'] === 'paragraphs') {
				$new_node = ReTidy::firstElementChild($first_tr_table)->cloneNode(true);
				$ps_in_new_node = $this->xpath->query('.//' . ReTidy::get_html_namespace() . 'p', $new_node);
				$number_of_ps = 0;
				foreach($ps_in_new_node as $index356435 => $value356435) {
					if($index356435 === 0) {
						$first_p_in_new_node = $value356435;
					}
					$number_of_ps++;
				}
				if($number_of_ps > 0) {
					if($number_of_ps === 1) {
						if(ReTidy::areConflationaryIgnoringWhiteSpace($new_node, $first_p_in_new_node)) {
							// it is unlikely but possible to have one paragraph that is not conflationary with the cell.
							$new_node = $first_p_in_new_node->cloneNode(true);
						} else {
							print("deal with one non-conflationary paragraph in the cell 43490434<br>\r\n");
							print("cell: ");var_dump(ReTidy::DOM_getNodeString($new_node));
							exit(0);
						}
					} else {
						print("deal with more than one paragraph in a table caption 43490435<br>\r\n");
						print("cell: ");var_dump(ReTidy::DOM_getNodeString($new_node));
						exit(0);
					}
				} else {
					$new_node->setAttribute('newtag', 'p');
				}
				$first_tr_table->setAttribute("deleteme", "y");
				foreach($new_node->attributes as $attribute) {
					$attribute->nodeValue = "stripme";
				}
				$new_node->insertBefore(new DOMText('XXX9o9NewTagBeginXXXstrong9o9XXX'), $new_node->firstChild);
				$new_node->appendChild(new DOMText('XXX9o9NewTagEndXXXstrong9o9XXX'));
				$table->parentNode->insertBefore($new_node, $table);
			} elseif($this->config['turn_captions_into'] === 'captions') {
				$first_tr_table->setAttribute("stripme", "y");
				ReTidy::DOM_strip_node($first_tr_table);
				if($cell_in_first_tr->hasAttributes()) {
					foreach($cell_in_first_tr->attributes as $attribute) {
						$attribute->nodeValue = "stripme";
					}
				}
				$cell_in_first_tr->setAttribute('newtag', 'caption');
				$cell_in_first_tr->setAttribute('style', 'text-align: left;');
				$cell_in_first_tr->insertBefore(new DOMText("XXX9o9NewTagBeginXXXstrong9o9XXX"), $cell_in_first_tr->firstChild);
				$cell_in_first_tr->appendChild(new DOMText("XXX9o9NewTagEndXXXstrong9o9XXX"));
			}
		} else {
			//$previousElement = ReTidy::previousElement($table);
			$previousElement = ReTidy::previousElementIgnoringNesting($table);
			$tagless = trim(ReTidy::tagless($previousElement));
			preg_match('/Table(au){0,1} [0-9]*:/is', $tagless, $matches45089);
			if(strpos($tagless, $matches45089[0]) === 0 && $previousElement->nodeName === "p") {
				if($this->config['turn_captions_into'] === 'captions') {
					$new_node = $previousElement->cloneNode(true);
					$previousElement->setAttribute("deleteme", "y");
					if($new_node->hasAttributes()) {
						foreach($new_node->attributes as $attribute) {
							$attribute->nodeValue = "stripme";
						}
					}
					$new_node->setAttribute('newtag', 'caption');
					$new_node->setAttribute('style', 'text-align: left;');
					$new_node->insertBefore(new DOMText("XXX9o9NewTagBeginXXXstrong9o9XXX"), $new_node->firstChild);
					$new_node->appendChild(new DOMText("XXX9o9NewTagEndXXXstrong9o9XXX"));
					if($thead) {
						$table->insertBefore($new_node, $thead);
					} else {
						$table->insertBefore($new_node, $first_tr_table);
					}
				} elseif($this->config['turn_captions_into'] === 'paragraphs') {
					$query = './/' . ReTidy::get_html_namespace() . 'strong';
					$strongs735 = $this->xpath->query($query, $previousElement);
					$found_strong735 = false;
					foreach($strongs735 as $strong735) {
						$found_strong735 = true;
						break;
					}
					if(!$found_strong735) {
						$previousElement->insertBefore(new DOMText("XXX9o9NewTagBeginXXXstrong9o9XXX"), $previousElement->firstChild);
						$previousElement->appendChild(new DOMText("XXX9o9NewTagEndXXXstrong9o9XXX"));
					}
				}
			}
		}
		
		// take bottom table notes (source information, etc...) out of tables
		// needs work to properly identify only bottom table notes...
		$query = ReTidy::get_html_namespace() . 'tfoot';
		$tfoots = $this->xpath->query($query, $table);
		foreach($tfoots as $tfoot) {
			$query = ReTidy::get_html_namespace() . 'tr[last()]';
			$first_tr_in_tfoots = $this->xpath->query($query, $tfoot);
			foreach($first_tr_in_tfoots as $first_tr_in_tfoot) {
				// (there should only be one <tfoot> and only one first <tr> therein.
			}
		}
		if($first_tr_in_tfoot) {
			$last_tr_table = $first_tr_in_tfoot;
		} else {
			$query = ReTidy::get_html_namespace() . 'tr[last()]';
			$last_tr_tables = $this->xpath->query($query, $table);
			foreach($last_tr_tables as $last_tr_table) { }
		}
		$query = ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'th';
		$cells_in_last_tr = $this->xpath->query($query, $last_tr_table);
		$count430 = 0;
		foreach($cells_in_last_tr as $cell_in_last_tr) {
			$count430++;
		}
		$tagless = ReTidy::tagless($cell_in_last_tr);
		if($count430 === 1 && (stripos(trim($tagless), "source") === 0 || ReTidy::hasABulletForThePurposesOfTableSourceInformation(trim($tagless)))) {
			// then we want to take the table notes out of the table
			$last_tr_table->setAttribute("deleteme", "y");
			$new_node = ReTidy::lastElementChild($last_tr_table)->cloneNode(true);
			foreach($new_node->attributes as $attribute) {
				$attribute->nodeValue = "stripme";
			}
			$new_node->setAttribute('newtag', 'div');
			if($this->config['table_note_size'] == '80percent') {
				//$new_node->setAttribute('class', 'fontSize80');
				// the file is not necessarily CLF2
				$new_node->setAttribute('style', 'font-size: 80%;');
			}
			//if($border_attribute !== false) { // ???
			//	if($border_attribute->nodeValue === 0) {
			//		// do nothing
			//	} else {
			//		ReTidy::addStyleWithoutOverwrite($new_node, "border: " . $border_attribute->nodeValue . "px solid black;");
			//	}
			//}
			$table->parentNode->insertBefore($new_node, $table->nextSibling);
		}
		*/
		$query = './/' . ReTidy::get_html_namespace() . 'tr';
		$trs = $this->xpath->query($query, $table);
		// another case that we would want to merge in: when for some number of columns; in each row out of these columns,
		// there is only content in one of the cells... not necessarily; empty cells could be considered data.
		/*
		
		// merge cells
		// check if this table is a difficult one that we want to avoid
		$proceed_with_merging = true;
		foreach($trs as $tr) {
			$query = ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'th';
			$cells = $this->xpath->query($query, $tr);
			$count_cells_in_row = 0;
			foreach($cells as $cell) {
				$colspan_amount = ReTidy::getColspan($cell);
				while($colspan_amount > 1) {
					$colspan_amount--;
					$count_cells_in_row++;
				}
				$count_cells_in_row++;
			}
			if($count_cells_in_row !== $this->table_width) {
				$proceed_with_merging = false;
				break;
			}
		}
		if($proceed_with_merging) {
			foreach($trs as $tr) {
				// merge cells containing text that belongs in the same cell:
				// criteria for determining if cells should be joined:
					// * the text content of cells in a column that should be joined is of about the same length 
					// (because a new cell exists where the text should simply wrap)?
					// * merging should begin at a row that has content in every cell?
					// * merging should end at the row before one where it could begin or at the end of the table
				
				// to simplify matters, we choose in rows without any rowspan or colspan
				// although we may want to consider rowspan later (because of the case where "one part of a column
				// that should be joined is already joined")
				$query = ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'th';
				$tr_cells = $cells = $this->xpath->query($query, $tr);
				$number_cells_in_row = 0;
				foreach($cells as $cell) {
					$number_cells_in_row++;
				}
				if($number_cells_in_row === $this->table_width) {
					$cells_in_this_row_have_content = true;
					foreach($cells as $cell) {
						if(ReTidy::isEmptyTag($cell)) {
							$cells_in_this_row_have_content = false;
							break;
						}
					}
					if($cells_in_this_row_have_content) {
						// then this is a candidate for merging so check the criteria
						// check if the text content in the cells is about the same length:
						// check if the cells look like they should be merged to a similar row or the end of the table:
						$nextElement = $tr;
						while($nextElement = ReTidy::nextElement($nextElement)) {
							$query = ReTidy::get_html_namespace() . 'td | ' . ReTidy::get_html_namespace() . 'th';
							$cells4 = $this->xpath->query($query, $nextElement);
							$number_cells_in_row4 = 0;
							foreach($cells4 as $cell4) {
								$number_cells_in_row4++;
							}
							if($number_cells_in_row4 === $this->table_width) {						
								$cells_in_this_row_have_content4 = true;
								foreach($cells4 as $cell4) {
									if(ReTidy::isEmptyTag($cell4)) {
										$cells_in_this_row_have_content4 = false;
									}
								}
								if($cells_in_this_row_have_content4) {
									break;
								}							
								$element_cell_count = 0;
								foreach($cells4 as $element_cell) {
									$element_cell_count++;
									$tr_cell_count = 0;
									foreach($tr_cells as $tr_cell) {
										$tr_cell_count++;
										if($tr_cell_count === $element_cell_count) {
											//print("tr_cell" . htmlentities(ReTidy::DOM_getNodeString($tr_cell)) . "<br>\r\n");
											if($element_cell->hasChildNodes()) {
												if(!ReTidy::isEmptyTag($element_cell)) {
													//$tr_cell->nodeValue = ReTidy::decode_for_DOM($tr_cell->nodeValue) . " ";
													$tr_cell->nodeValue .= " ";													
													$tr_cell->appendChild(new DOMText(ReTidy::DOM_decoded_for_DOM_child_of($element_cell)));
												}
												$element_cell->nodeValue = "";
											}
										}
									}
								}
								$element_cell->parentNode->setAttribute("deleteme", "y");
							} else {
								break;
							}
						}
					}
				}
			}
		}
		*/
		
		// (2011-10-26) we are doing very little table cleaning by now, due simply to the variety of ways <table>s may be misused (or possibly my lack of DOM coding skills)
		/*
		// eliminate empty rows then reduce rowspan on previous (along their column) cells
		foreach($trs as $tr) {
			if(ReTidy::isSpace(ReTidy::tagless($tr))) {
				$tr->setAttribute("deleteme", "y");
				//if($tr->hasChildNodes()) {
				//	foreach($tr->childNodes as $child) {
				//		if($child->nodeType === 1) {
				//			$child->setAttribute("deleteme", "y");
				//		}
				//	}
				//}
			}
		}
		
		ReTidy::DOM_build_table_grid($table);
		$mirrored_array = ReTidy::array_mirror($this->table_grid);
		foreach($mirrored_array as $index => $row) {
			$empty_row = true;
			foreach($row as $index2 => $value2) {
				$cell = $value2[0];
				//if(ReTidy::isEmpty($cell)) {
				if(ReTidy::isSpace(ReTidy::tagless($cell))) {
					//$last_non_spanning_cell = $cell;
					continue;
				}
				$rowspan = ReTidy::getRowspan($cell);
				if($rowspan > 1 && $mirrored_array[$index-1][$index2][0] === $cell) {
					continue;
				}
				$empty_row = false;
				break;
			}
			if($empty_row) {
				//$tr = $last_non_spanning_cell->parentNode;
				//$tr->setAttribute("deleteme", "y");
				foreach($row as $index2 => $value2) {
					$cell = $value2[0];
					$rowspan = ReTidy::getRowspan($cell);
					if($rowspan > 1) {
						$rowspan--;
						if($rowspan === 1) {
							$cell->setAttribute('rowspan', 'stripme');
						} else {
							$cell->setAttribute('rowspan', $rowspan);
						}
					} else {
						$cell->setAttribute("deleteme", "y");
					}
				}
			}
		}
		
		
		// eliminate empty columns then reduce colspan on previous sibling cells
		ReTidy::DOM_build_table_grid($table);
		foreach($this->table_grid as $index => $column) {
			$empty_column = true;
			foreach($column as $index2 => $value2) {
				$cell = $value2[0];
				//if(ReTidy::isEmpty($cell)) {
				if(ReTidy::isSpace(ReTidy::tagless($cell))) {
					continue;
				}
				$colspan = ReTidy::getColspan($cell);
				if($colspan > 1 && $this->table_grid[$index-1][$index2][0] === $cell) {
					continue;
				}
				$empty_column = false;
				break;
			}
			if($empty_column) {
				foreach($column as $index2 => $value2) {
					$cell = $value2[0];
					$colspan = ReTidy::getColspan($cell);
					if($colspan > 1) {
						$colspan--;
						if($colspan === 1) {
							$cell->setAttribute('colspan', 'stripme');
						} else {
							$cell->setAttribute('colspan', $colspan);
						}
					} else {
						//var_dump(ReTidy::DOM_getNodeString($cell));print("<br>\r\n");
						$cell->setAttribute("deleteme", "y");
					}
				}
			}
		}		
		*/
		

		ReTidy::DOM_empty_ths($table);
		/*
		// remove unnecessary <tbody>
		//$query = ReTidy::get_html_namespace() . 'tbody';
		//$tbodys = $this->xpath->query($query, $table);
		//foreach($tbodys as $tbody) {
		//	if(ReTidy::DOM_isConflationaryWithParentIgnoringWhitespace($tbody)) {
		//		$tbody->setAttribute("stripme", "y");
		//		ReTidy::DOM_strip_node($tbody);
		//	}
		//}
		// remove empty <thead>, <tbody>, <tfoot>? no.
		
		// cell splitting
		// it seems to be a rare case where the program will be able to determine when cells should be split
		// in other words; to determine when a putative datum cell is really many data
		// disabled 2011-09-09
		foreach($trs as $tr) {
			$array_cells_to_split = array();
			$saved_p_count = 0;
			$count_cells_with_large_number_of_ps = 0;
			$cells = $this->xpath->query('.//' . ReTidy::get_html_namespace() . 'td | .//' . ReTidy::get_html_namespace() . 'th', $tr);
			foreach($cells as $cell) {
				$p_in_cells = $this->xpath->query('.//' . ReTidy::get_html_namespace() . 'p', $cell);
				$count_ps_for_this_cell = 0;
				foreach($p_in_cells as $p_in_cell) {
					$count_ps_for_this_cell++;
				}
				if($count_ps_for_this_cell > 4) {
					if($saved_p_count < $count_ps_for_this_cell) {
						$saved_p_count = $count_ps_for_this_cell;
					}
					$array_cells_to_split[] = $cell;
					$count_cells_with_large_number_of_ps++;
				}
			}
			if($count_cells_with_large_number_of_ps > 2) { // then do the splitting
				ReTidy::splitCells($array_cells_to_split, $saved_p_count, 'row', $table);
			}
		}*/
		return true;
	}
	
	protected function splitCells($cells, $number, $direction, $table) {
		ReTidy::DOM_build_table_grid($table);
		$mirrored_grid = ReTidy::array_mirror($this->table_grid);
		if($direction = 'row') {
			foreach($mirrored_grid as $index => $row) {
				foreach($row as $index2 => $value2) {
					$grid_cell = $value2[0];
					if($grid_cell === $cells[0]) {
						break 2;
					}
				}
			}
			// get the cells in the row by the index
			$tr = $grid_cell->parentNode;
			$did_first_cell = false;
			foreach($mirrored_grid[$index] as $index2 => $value2) {
				$grid_cell = $value2[0];
				foreach($cells as $cell) {
					if($grid_cell === $cell) {
						// here we split a cell
						$ps = $this->xpath->query('.//' . ReTidy::get_html_namespace() . 'p', $cell);
						$count4589 = 0;
						foreach($ps as $p) {
							$count4589++;
						}
						$rowspan_amount = 1;
						while($count4589 !== $number) {
							$rowspan_amount++;
							$count4589++;
						}
						if($did_first_cell) {
							$last_tr = $tr;
							foreach($ps as $p_index => $p) {
								if($p_index === 0) {
									if($rowspan_amount > 1) {
										//print('getRowspan 2<br>');
										$rowspan = ReTidy::getRowspan($grid_cell);
										$grid_cell->setAttribute('rowspan', $rowspan - 1 + $rowspan_amount);
									}
									// skip the first one
								} else {
									$new_tr = $array_new_trs[$p_index-1];
									$new_td = new DOMElement('td');
									$p_clone = $p->cloneNode(true);
									$new_tr->appendChild($new_td);
									$new_td->appendChild($p_clone);
									$p->setAttribute('deleteme', 'y');
								}
							}
						} else {
							$last_tr = $tr;
							foreach($ps as $p_index => $p) {
								if($p_index === 0) {
									if($rowspan_amount > 1) {
										//print('getRowspan 3<br>');
										$rowspan = ReTidy::getRowspan($grid_cell);
										$grid_cell->setAttribute('rowspan', $rowspan - 1 + $rowspan_amount);
										while($rowspan_amount > 1) {
											$new_tr = new DOMElement('tr');
											$array_new_trs[] = $new_tr;
											$nextTr = ReTidy::nextElement($last_tr);
											if($nextTr === false) {
												$tr->parentNode->appendChild($new_tr);
											} else {
												$tr->parentNode->insertBefore($new_tr, $nextTr);
											}
											$last_tr = $new_tr;
											$rowspan_amount--;
										}
									}									
									// skip the first one
								} else {
									$new_tr = new DOMElement('tr');
									$new_td = new DOMElement('td');
									$p_clone = $p->cloneNode(true);
									$array_new_trs[] = $new_tr;
									$nextTr = ReTidy::nextElement($last_tr);
									if($nextTr === false) {
										$tr->parentNode->appendChild($new_tr);
									} else {
										$tr->parentNode->insertBefore($new_tr, $nextTr);
									}									
									$new_tr->appendChild($new_td);
									$new_td->appendChild($p_clone);
									$p->setAttribute('deleteme', 'y');
									$last_tr = $new_tr;
								}
							}
							$did_first_cell = true;
						}
						continue 2;
					}
				}
				// here we increase the rowspan
				//print('getRowspan 4<br>');
				$rowspan = ReTidy::getRowspan($grid_cell);
				$grid_cell->setAttribute('rowspan', $rowspan - 1 + $number);
			}
		} elseif($direction = 'column') {
			// untested (2009-07-02); use of this should probably be rare (since paragraphs stack vertically by default)
			ReTidy::warning('<h1>Merging cells in a column</h1>');
			foreach($this->table_grid as $index => $column) {
				foreach($column as $index2 => $value2) {
					$grid_cell = $value2[0];
					if($grid_cell === $cells[0]) {
						break 2;
					}
				}
			}
			// get the cells in the column by the index
			$did_first_cell = false;
			foreach($this->table_grid[$index] as $index2 => $value2) {
				$grid_cell = $value2[0];
				$tr = $grid_cell->parentNode;
				foreach($cells as $cell) {
					if($grid_cell === $cell) {
						// here we split a cell
						$ps = $this->xpath->query('.//' . ReTidy::get_html_namespace() . 'p', $cell);
						$count4590 = 0;
						foreach($ps as $p) {
							$count4590++;
						}
						$colspan_amount = 1;
						while($count4590 !== $number) {
							$colspan_amount++;
							$count4590++;
						}
						foreach($ps as $p_index => $p) {
							if($p_index === 0) {
								if($colspan_amount > 1) {
									$colspan = ReTidy::getColspan($grid_cell);
									$grid_cell->setAttribute('colspan', $colspan - 1 + $colspan_amount);
								}
								// skip the first one
							} else {
								$new_td = new DOMElement('td');
								$p_clone = $p->cloneNode(true);
								$nextElement = ReTidy::nextElement($cell);
								if($nextElement) {
									$tr->insertBefore($new_td, $nextElement);
								} else {
									$tr->appendChild($new_td);
								}
								$new_td->appendChild($p_clone);
								$p->setAttribute('deleteme', 'y');
							}
						}
						continue 2;
					}
				}
				// here we increase the colspan
				$colspan = ReTidy::getColspan($grid_cell);
				$grid_cell->setAttribute('colspan', $colspan - 1 + $number);
			}		
		} else {
			print("direction of cells for splitCells not properly specified: ");var_dump($direction);print("<br>\r\n");
		}
	}
	
	protected function getScope($node) {
		if($node->nodeName !== "th" && $node->nodeName !== "td") {
			print("trying to find the scope of a node that is not a cell258925: ");var_dump(ReTidy::DOM_getNodeString($node));print("<br>\r\n");
			return false;
		}
		return ReTidy::getAttribute($node, 'scope')->nodeValue;
	}
	
	protected function getRowspan($node) {
		if($node->nodeName !== "th" && $node->nodeName !== "td") {
			print("trying to find the rowspan of a node that is not a cell258925: ");var_dump(ReTidy::DOM_getNodeString($node));print("<br>\r\n");
			//return 1;
			return false;
		}
		$rowspan = (int)ReTidy::getAttribute($node, 'rowspan')->nodeValue;
		if($rowspan) {
			return $rowspan;
		} else {
			return 1;
		}
	}
	
	protected function getColspan($node) {
		if($node->nodeName !== "th" && $node->nodeName !== "td") {
			print("trying to find the colspan of a node that is not a cell258926: ");var_dump(ReTidy::DOM_getNodeString($node));print("<br>\r\n");
			//return 1;
			return false;
		}
		$colspan = (int)ReTidy::getAttribute($node, 'colspan')->nodeValue;
		if($colspan) {
			return $colspan;
		} else {
			return 1;
		}
	}	
	
	protected function DOM_empty_ths($table) {
		// turn empty table headers into normal cells
		$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td[@newtag="th"]';
		$ths = $this->xpath->query($query, $table);
		foreach($ths as $th) {
			if(ReTidy::isEmptyTagIgnoringWhitespaceAndAttributes($th)) {
				$th->setAttribute("newtag", "td");
			}
		}	
	}

	protected function DOM_alt_text () {
		$query = '//' . ReTidy::get_html_namespace() . 'img';
		$images = $this->xpath->query($query);
		foreach($images as $image) {
			if($image->hasAttributes()) {
				foreach($image->attributes as $image_attribute) {
					if($image_attribute->nodeName === "alt") {
						continue 2;
					}
				}
			}
			// get the alt text from the previous element and strip tags
			if($previousElement = ReTidy::rec_DOM_previousElement($image)) {
				$image->setAttribute("alt", ReTidy::tagless($previousElement));
			}
		}
		return true;	
	}
	
	protected function hasContent($node) {
		return !ReTidy::isEmptyTagIgnoringWhitespaceAndAttributes($node);
	}
	
	protected function addCaption($table, $caption) {
		$firstNonAttributeChild = ReTidy::firstNonAttributeChild($table);
		$table->insertBefore(new DOMText('XXX9o9NewTagBeginXXXcaption9o9XXX' . $caption . 'XXX9o9NewTagEndXXXcaption9o9XXX'), $firstNonAttributeChild->nextSibling);
	}
	
	protected function DOM_table_structure($table) {
		// great code would also ignore nested tables
		//$query = './/' . ReTidy::get_html_namespace() . 'thead';
		$query = './' . ReTidy::get_html_namespace() . 'thead';
		$theads = $this->xpath->query($query, $table);
		$number_theads = 0;
		foreach($theads as $thead) {
			$number_theads++;
		}
		if($number_theads > 1) {
			print('Found ' . $number_theads . ' &lt;thead&gt;s, DOM_table_structure() has stopped. Problematic table:<br>' . ReTidy::DOM_getNodeString($table));exit(0);
		}
		//$query = './/' . ReTidy::get_html_namespace() . 'tfoot';
		$query = './' . ReTidy::get_html_namespace() . 'tfoot';
		$tfoots = $this->xpath->query($query, $table);
		$number_tfoots = 0;
		foreach($tfoots as $tfoot) {
			$number_tfoots++;
		}
		if($number_tfoots > 1) {
			print('Found ' . $number_tfoots . ' &lt;tfoot&gt;s, DOM_table_structure() has stopped. Problematic table:<br>' . ReTidy::DOM_getNodeString($table));exit(0);
		}
		//$query = './/' . ReTidy::get_html_namespace() . 'tbody';
		$query = './' . ReTidy::get_html_namespace() . 'tbody';
		$tbodys = $this->xpath->query($query, $table);
		$number_tbodys = 0;
		foreach($tbodys as $tbody) {
			$number_tbodys++;
		}
		/*if($number_tbodys > 1) {
			print('Found ' . $number_tbodys . ' &lt;tbody&gt;s, DOM_table_structure() has stopped. Problematic table:<br>' . ReTidy::DOM_getNodeString($table));exit(0);
		}*/
		if($this->config['trust_ths'] === false || ($number_theads === 0 && $number_tbodys === 0)) { // assume they are not there and apply them
			$query = './/' . ReTidy::get_html_namespace() . 'tr';
			$trs = $this->xpath->query($query, $table);
			$first_tr = false;
			$first_tr_in_tbody = false;
			$last_tr = false;
			//$found_first_tr_in_tbody = false;
			$skipped_first_new_tbody = false;
			foreach($trs as $tr) {
				$second_last_tr = $last_tr;
				$last_tr = $tr;
				if($first_tr === false) {
					$first_tr = $tr;
				}
				$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
				$cells_in_tr = $this->xpath->query($query, $tr);
				$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td[@newtag="th"]';
				$headers_in_tr = $this->xpath->query($query, $tr);
				//$last_number_cells_in_tr = $number_cells_in_tr;
				foreach($cells_in_tr as $first_cell_in_tr) { break; }
				$new_tbody = ReTidy::getAttribute($first_cell_in_tr, 'new_tbody')->nodeValue;
				if($new_tbody === 'true') {
					if(!$skipped_first_new_tbody) {
						$skipped_first_new_tbody = true;
					} else {$first_cell_in_tr_parent = $first_cell_in_tr->parentNode;
						$first_cell_in_tr_parent->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXtbody9o9XXXXXX9o9NewTagBeginXXXtbody9o9XXX"), $first_cell_in_tr_parent);
					}
				}
				$number_cells_in_tr = 0;
				$number_empty_cells_in_tr = 0;
				foreach($cells_in_tr as $cell_in_tr) {
					$number_cells_in_tr++;
					if(ReTidy::isEmptyIgnoringWhitespaceAndAttributes($cell_in_tr)) {
						$number_empty_cells_in_tr++;
					}
				}
				//print('$number_empty_cells_in_tr: ');var_dump($number_empty_cells_in_tr);
				$number_headers_in_tr = 0;
				foreach($headers_in_tr as $header_in_tr) {
					$newtag_attribute = ReTidy::getAttribute($header_in_tr, "newtag");
					if($newtag_attribute->nodeValue === "td") {
						
					} else {
						$number_headers_in_tr++;
					}
				}
				if(!$first_tr_in_tbody) {
					$number_headers_and_empty_in_tr = $number_headers_in_tr + $number_empty_cells_in_tr;
					//print('$number_cells_in_tr: ');var_dump($number_cells_in_tr);
					//print('$number_headers_in_tr: ');var_dump($number_headers_in_tr);
					//print('$number_headers_and_empty_in_tr: ');var_dump($number_headers_and_empty_in_tr);
					//exit(0);
					if($new_tbody === 'true') {
						$last_tr_in_thead = $last_tr;
						$first_tr_in_tbody = $tr;
					} elseif($number_headers_and_empty_in_tr === $number_cells_in_tr) {
						//$last_tr_in_table_head = $tr;
					} else {
						$last_tr_in_thead = $last_tr;
						$first_tr_in_tbody = $tr;
						//$found_first_tr_in_tbody = true;
						//break;
					}
				}
			}
			if($number_tfoots === 1) { // then there is a simple solution
				$first_tr->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXthead9o9XXX"), $first_tr);
				$tfoot->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXthead9o9XXX"), $tfoot);
				$node_after_tfoot = $tfoot->nextSibling;
				$node_after_tfoot->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXtbody9o9XXX"), $node_after_tfoot);
				$first_tr->parentNode->appendChild(new DOMText("XXX9o9NewTagEndXXXtbody9o9XXX"));
			} else {
				if($first_tr_in_tbody === false) {
					ReTidy::warning('Applying table structure but how to apply &lt;tbody&gt; to table could not be determined since no content cells were identified');
					$first_tr_in_tbody = $tr;
				}
				// tfoot processing
				// this is not general enough
				/*$did_table_source = false;
				if($number_cells_in_tr === 1) { // then we call this table source information
					// clear any existing attributes
					if($cell_in_tr->hasAttributes()) {
						foreach($cell_in_tr->attributes as $source_information_cell_attribute) {
							$source_information_cell_attribute->nodeValue = 'stripme';
						}
					}
					$moved_last_tr = $cell_in_tr->cloneNode(true);
					$moved_last_tr->setAttribute('newtag', 'div');
					$moved_last_tr->setAttribute('class', 'source');
					$node_after_table = $table->nextSibling;
					$node_after_table->parentNode->insertBefore($moved_last_tr, $node_after_table);
					$last_tr->setAttribute('deleteme', 'y');
					$did_table_source = true;
				}
				if(!$did_table_source) {*/
					if($last_tr === false) { // hack
						
					} else {
						$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
						$cells_in_potential_tfoot_tr = $this->xpath->query($query, $last_tr);
						$adding_a_tfoot = false;
						foreach($cells_in_potential_tfoot_tr as $cell_in_potential_tfoot_tr) {
							$new_tfoot = ReTidy::getAttribute($cell_in_potential_tfoot_tr, 'new_tfoot')->nodeValue;
							if($new_tfoot === 'true') {
								$adding_a_tfoot = true;
								break;
							}
						}
					
				/*} else {
					$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
					$cells_in_potential_tfoot_tr = $this->xpath->query($query, $second_last_tr);
					foreach($cells_in_potential_tfoot_tr as $cell_in_potential_tfoot_tr) {
						if(ReTidy::isEmptyIgnoringWhitespaceAndAttributes($cell_in_potential_tfoot_tr)) {
							// look for the next one
						} else {
							if(stripos(ReTidy::tagless(ReTidy::DOM_getNodeString($cell_in_potential_tfoot_tr)), 'total') === false) {
								
							} else { // then we call this the tfoot
								$moved_second_last_tr = $second_last_tr->cloneNode(true);
								$first_tr_in_tbody->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXtfoot9o9XXX"), $first_tr_in_tbody);
								$first_tr_in_tbody->parentNode->insertBefore($moved_second_last_tr, $first_tr_in_tbody);
								$first_tr_in_tbody->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXtfoot9o9XXX"), $first_tr_in_tbody);
								$second_last_tr->setAttribute('deleteme', 'y');
							}
							break;
						}
					}
				}*/
				// thead and tbody
				if($first_tr_in_tbody === $first_tr) {
					ReTidy::warning('Applying table structure but how to apply &lt;thead&gt; to table could not be determined');
					$first_tr->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXtbody9o9XXX"), $first_tr);
					$first_tr->parentNode->appendChild(new DOMText("XXX9o9NewTagEndXXXtbody9o9XXX"));
				} else {
					$first_tr->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXthead9o9XXX"), $first_tr);
					//$last_tr_in_thead->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXthead9o9XXX"), $last_tr_in_thead);
					$first_tr_in_tbody->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXthead9o9XXX"), $first_tr_in_tbody);
					$first_tr_in_tbody->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXtbody9o9XXX"), $first_tr_in_tbody);
					$first_tr->parentNode->appendChild(new DOMText("XXX9o9NewTagEndXXXtbody9o9XXX"));
					if($adding_a_tfoot) {
						$moved_last_tr = $last_tr->cloneNode(true);
						//$first_tr_in_tbody->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXtfoot9o9XXX"), $first_tr_in_tbody);
						//$first_tr_in_tbody->parentNode->insertBefore($moved_last_tr, $first_tr_in_tbody);
						//$first_tr_in_tbody->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXtfoot9o9XXX"), $first_tr_in_tbody);
						//$last_tr->setAttribute('deleteme', 'y');
						// (2017-03-31) validator now wants <tfoot>s at the bottom of the table for HTML5; shrug, it's a bit easier to code
						$last_tr->parentNode->appendChild(new DOMText("XXX9o9NewTagBeginXXXtfoot9o9XXX"));
						$last_tr->parentNode->appendChild($moved_last_tr);
						$last_tr->parentNode->appendChild(new DOMText("XXX9o9NewTagEndXXXtfoot9o9XXX"));
						$last_tr->setAttribute('deleteme', 'y');
					} else {
						//var_dump(ReTidy::DOM_getNodeString($last_tr_in_thead));
						if(isset($last_tr_in_thead)) {
							//$last_tr_in_thead->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXthead9o9XXX"), $last_tr_in_thead);
						} else {
							$last_tr->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXthead9o9XXX"), $last_tr_in_thead);
							ReTidy::warning('this needs revision... it causes problems when there\'s no apparent thead and I\'m not sure it\'s working perfectly 4e57546767896892478');
						}
					}
				}
			}
			}
		} else { // if we get to here then we work with the table structure in its problematic existing state (which should never happen since we should always redo the thead and tbody; regardless of their states)
			//print('here48794586409<br>');
			if($number_theads === 1) {
				//print('here48794586410<br>');
				if($number_tbodys === 0) {
					$query = './/' . ReTidy::get_html_namespace() . 'tr';
					$trs = $this->xpath->query($query, $table);
					$first_non_thead_tr = false;
					$first_tr = false;
					foreach($trs as $tr) {
						if($first_tr === false) {
							$first_tr = $tr;
						}
						//$ancestry_array = ReTidy::DOM_getAncestryArray($tr);
						$parentNode = $tr->parentNode;
						if($parentNode->nodeName === "thead") {
							
						} else {
							$first_non_thead_tr = $tr;
							break;
						}
					}
					if($first_non_thead_tr === false) {
						ReTidy::warning('Applying table structure but how to apply &lt;tbody&gt; to table could not be determined since no content cells were identified 2');
						$first_non_thead_tr = $tr;
					}
					//if(!ReTidy::isNode($first_non_thead_tr->parentNode)) {
					//	var_dump(ReTidy::DOM_getNodeString($first_non_thead_tr));
					//	var_dump(ReTidy::DOM_getNodeString($first_non_thead_tr->parentNode));exit(0);
					//}
					$first_non_thead_tr->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXtbody9o9XXX"), $first_non_thead_tr);
					$tr->parentNode->appendChild(new DOMText("XXX9o9NewTagEndXXXtbody9o9XXX"));
				} else {
					// no need to do anything
				}
			} else {
				if($number_tbodys >= 1) {
					//print('here48794586411<br>');
					// here we want to put <thead> around <tr>s before <tbody>; will it ever come up?
					if($number_theads === 0) {
						$query = './/' . ReTidy::get_html_namespace() . 'tr';
						$trs = $this->xpath->query($query, $table);
						$query = './/' . ReTidy::get_html_namespace() . 'tbody/tr';
						$trs_in_tbody = $this->xpath->query($query, $table);
						if(sizeof($trs) === sizeof($trs_in_tbody)) {
							
						} else {
							ReTidy::warning('Applying table structure but how to apply &lt;thead&gt; to table could not be determined since this code has not been written yet 3');exit(0);
						}
					}
				} else {
					//print('here48794586412<br>');
					if($number_theads === 0) {
						$query = './/' . ReTidy::get_html_namespace() . 'tr';
						$trs = $this->xpath->query($query, $table);
						$last_non_tbody_tr = false;
						$first_tr = false;
						foreach($trs as $tr) {
							if($first_tr === false) {
								$first_tr = $tr;
							}
							$parentNode = $tr->parentNode;
							if($parentNode->nodeName === "tbody") {
								
							} else {
								$last_non_tbody_tr = $tr;
							}
						}
						if($first_tr === false) {
							ReTidy::warning('Applying table structure but how to apply &lt;tbody&gt; to table could not be determined since no content cells were identified 4');
							$first_tr = $tr;
						}
						$first_tr->parentNode->insertBefore(new DOMText("XXX9o9NewTagBeginXXXtbody9o9XXX"), $first_tr);
						$tbody->parentNode->insertBefore(new DOMText("XXX9o9NewTagEndXXXtbody9o9XXX"), $tbody);
					}
				}
			}
		}
		$query = './/@new_tbody';
		$new_tbody_attributes = $this->xpath->query($query, $table);
		foreach($new_tbody_attributes as $new_tbody_attribute) {
			$new_tbody_attribute->nodeValue = "stripme";
		}
		$query = './/@new_tfoot';
		$new_tfoot_attributes = $this->xpath->query($query, $table);
		foreach($new_tfoot_attributes as $new_tfoot_attribute) {
			$new_tfoot_attribute->nodeValue = "stripme";
		}
		$query = './/@tfoot_member';
		$tfoot_member_attributes = $this->xpath->query($query, $table);
		foreach($tfoot_member_attributes as $tfoot_member_attribute) {
			$tfoot_member_attribute->nodeValue = "stripme";
		}
	}
	
	function DOM_getAncestryArray($node) {
		$ancestry_array = array();
		while(isset($node->parentNode)) {
			$ancestry_array[] = array($node->parentNode, $node->parentNode->nodeName);
			$node = $node->parentNode;
		}
		return $ancestry_array;
	}
	
	protected function DOM_table_summary($table) {
		// if there is already a summary
		// now (2012-05-03) we are only trying to pick a caption out of the top of or right before the table
		/*$summary = ReTidy::getAttribute($table, "summary");
		if($summary) {
			$summary_text = trim(ReTidy::decode_for_DOM_character_entities(ReTidy::tagless(ReTidy::DOM_getNodeString($summary))));
			if(strlen($summary_text) > 0) {
				if($this->config['HTML5'] === 'HTML5' || $this->config['HTML5'] === true || ReTidy::get_HTML5()) {
					ReTidy::addCaption($table, $summary_text);
					$table->setAttribute("summary", "stripme");
				}
				return true;
			}
		}*/
		$captions = false;
		$query = ReTidy::get_html_namespace() . 'caption | ' . ReTidy::get_html_namespace() . 'thead/' . ReTidy::get_html_namespace() . 'caption | ' . ReTidy::get_html_namespace() . 'tfoot/' . ReTidy::get_html_namespace() . 'caption | ' . ReTidy::get_html_namespace() . 'tbody/' . ReTidy::get_html_namespace() . 'caption';
		$captions = $this->xpath->query($query, $table);
		// if there is a caption tag but no summary
		//if($this->config['HTML5'] === 'HTML5' || $this->config['HTML5'] === true || ReTidy::get_HTML5()) {
			foreach($captions as $caption) {
				// this function won't concern itself with too many (more than one) captions; although it could.
				return true;
			}
		/*} else { // add the (slightly altered) caption to the missing summary
			foreach($captions as $caption) {
				$tagless = trim(ReTidy::decode_for_DOM_character_entities(ReTidy::tagless(ReTidy::DOM_getNodeString($caption))));
				if($this->language === "french") {
					if(isset($this->config['french_existing_caption_summary_pre_text']) && strlen($this->config['french_existing_caption_summary_pre_text']) > 0) {
						$pre_text = $this->config['french_existing_caption_summary_pre_text'];
					} else {
						$pre_text = "D&eacute;tails de ";
					}
				} else {
					if(isset($this->config['english_existing_caption_summary_pre_text']) && strlen($this->config['english_existing_caption_summary_pre_text']) > 0) {
						$pre_text = $this->config['english_existing_caption_summary_pre_text'];
					} else {
						$pre_text = "Details of ";
					}
				}
				$table->setAttribute("summary", $pre_text . $tagless);			
				return true;
			}
		}*/
		
		
		if($this->config['trust_ths'] === true) {
			
		} else {
			$query = './/' . ReTidy::get_html_namespace() . 'tr';
			$trs = $this->xpath->query($query, $table);
			foreach($trs as $tr) {
				$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
				$cells_in_tr = $this->xpath->query($query, $tr);
				$number_cells_in_tr = 0;
				foreach($cells_in_tr as $cell_in_tr) {
					$number_cells_in_tr++;
				}
				break;
			}
			//print('number_cells_in_tr: ' . $number_cells_in_tr . '<br>');
			if($number_cells_in_tr === 1) { // then we call this a caption
				//print('This table is having its first cell transformed into a caption.<br>');
				// clear any existing attributes
				if($cell_in_tr->hasAttributes()) {
					foreach($cell_in_tr->attributes as $source_information_cell_attribute) {
						$source_information_cell_attribute->nodeValue = 'stripme';
					}
				}
				$moved_last_tr = $cell_in_tr->cloneNode(true);
				$moved_last_tr->setAttribute('newtag', 'caption');
				$moved_last_tr->setAttribute('class', 'alignLeft');
				$first_table_child_node = $table->firstChild;
				$first_table_child_node->parentNode->insertBefore($moved_last_tr, $first_table_child_node);
				$tr->setAttribute('deleteme', 'y');
				return true;
			}
		}
		
		// get the summary text from the previous element and strip tags
		$previousElement = ReTidy::previousElement($table);
		while($previousElement->nodeName === "table") {
			$previousElement = ReTidy::previousElement($previousElement);
		}
		// we could here do some intelligent thing like looking for a string "The following table describes...".
		if($previousElement && ReTidy::hasContent($previousElement)) {
			$tagless = trim(ReTidy::decode_for_DOM_character_entities(ReTidy::tagless($previousElement)));
			//print('$tagless: ');var_dump($tagless);
	//		if($this->config['HTML5'] === 'HTML5' || $this->config['HTML5'] === true || ReTidy::get_HTML5()) {
				//print('here475885986096097<br>');
				if(stripos($tagless, 'table') === 0 || stripos($tagless, 'figure') === 0) {
					//ReTidy::addCaption($table, $tagless);
					$moved_previous_element = $previousElement->cloneNode(true);
					$moved_previous_element->setAttribute('newtag', 'caption');
					$moved_previous_element->setAttribute('class', 'alignLeft');
					$first_table_child_node = $table->firstChild;
					$first_table_child_node->parentNode->insertBefore($moved_previous_element, $first_table_child_node);
					$previousElement->setAttribute('deleteme', 'y');
					return true;
				}
	//		} else {
				//print('here475885986096098<br>');
	//			$table->setAttribute("summary", $tagless);
	//		}
		}
		
		return true;
	}
	
	protected function DOM_table_summary_ti($table) {
		if($table->hasAttributes()) {
			foreach($table->attributes as $table_attribute) {
				if($table_attribute->nodeName === "summary") {
					return true;
				}
			}
		}
		// get the summary text from the previous element and strip tags
		$count = 0;
		$previousElement = $table;
		while($count < 7) {
			if($previousElement = ReTidy::rec_DOM_previousElement($previousElement)) {
				if($previousElementString = ReTidy::DOM_getNodeString($previousElement)) {
					//$tagless = utf8_encode(html_entity_decode(preg_replace('/<[^<>]*>/is', '', $previousElementString)));
					$tagless = html_entity_decode(preg_replace('/<[^<>]*>/is', '', $previousElementString));
					preg_match('/Projet [0-9]*\s*(\-|&ndash;|–)\s*[0-9]*\s*( |&nbsp;| ):/', $tagless, $matches);
					if(sizeof($matches[0]) > 0) {
						if($this->language === "english") {
							$tagless = "Activities (in sequence), Responsibility and Timing Guidelines for" . preg_replace('/Project[^:]*:/', '', $tagless);
						}
						if($this->language === "french") {
							$tagless = "ACTIVITÉS (en séquence), RESPONSABLE et CALENDRIER-GUIDE pour" . $tagless;
						}						
						$table->setAttribute("summary", $tagless);
						return true;
					}					
				}
			}
			$count++;
		}
		return false;	
	}
	
	protected function DOM_table_summary_PC($table) {
		if($table->hasAttributes()) {
			foreach($table->attributes as $table_attribute) {
				if($table_attribute->nodeName === "summary") {
					return true;
				}
			}
		}
		// get the summary text from the previous element and strip tags
		$count = 0;
		$previousElement = $table;
		while($count < 7) {
			if($previousElement = ReTidy::rec_DOM_previousElement($previousElement)) {
				if($previousElementString = ReTidy::DOM_getNodeString($previousElement)) {
					//$tagless = utf8_encode(html_entity_decode(preg_replace('/<[^<>]*>/is', '', $previousElementString)));
					$tagless = html_entity_decode(preg_replace('/<[^<>]*>/is', '', $previousElementString));
					preg_match('/Projet [0-9]*\s*(\-|&ndash;|–)\s*[0-9]*\s*( |&nbsp;| ):/', $tagless, $matches);
					if(sizeof($matches[0]) > 0) {
						if($this->language === "english") {
							$tagless = "Activities (in sequence), Responsibility and Timing Guidelines for" . preg_replace('/Project[^:]*:/', '', $tagless);
						}
						if($this->language === "french") {
							$tagless = "ACTIVITÉS (en séquence), RESPONSABLE et CALENDRIER-GUIDE pour" . $tagless;
						}						
						$table->setAttribute("summary", $tagless);
						return true;
					}					
				}
			}
			$count++;
		}
		return false;	
	}	
	
	protected function DOM_apply_table_headers($table) {
		$biggest_header_dimension = sizeof($this->table_headers_dimensions);
		//$biggest_header_dimension = 5;
		//$this->table_headers_dimensions[4][0] = 5;
		//print('$this->table_headers_dimensions: ');var_dump($this->table_headers_dimensions);
		//print('$this->table_grid: ');var_dump($this->table_grid);
		//$number_of_grid_spots_to_skip = 0;
		foreach($this->table_grid as $index => $column) {
			foreach($column as $index2 => $value) {
				$cell = $value[0];
				//print("cell: ");var_dump(ReTidy::DOM_getNodeString($cell));
				//if($this->table_grid[$index + 1][index2][0] === $cell) {
				//	print('Don\'t do anything but the last grid instance of this cell. (colspan)<br>');
				//	continue;
				//}
				//if($this->table_grid[$index][index2 + 1][0] === $this->table_grid[$index][index2][0]) {
				//	var_dump($index, $index2, $this->table_grid[$index][index2 + 1][0], $cell);
				//	print('Don\'t do anything but the last grid instance of this cell. (rowspan)<br>');
				//	continue;
				//}
				$cell_new_tbody = ReTidy::getAttribute($cell, "new_tbody")->nodeValue;
				if($cell_new_tbody === 'true') {
					continue;
				}
				$cell_new_tfoot = ReTidy::getAttribute($cell, "new_tfoot")->nodeValue;
				if($cell_new_tfoot === 'true') {
					continue;
				}
				$cell_tfoot_member = ReTidy::getAttribute($cell, "tfoot_member")->nodeValue;
				//print('cell1: ' . ReTidy::DOM_getNodeString($cell));print("<br>\r\n");
				$cell_colspan = (int)ReTidy::getAttribute($cell, "colspan")->nodeValue;
				if($cell_colspan < 1) {
					$cell_colspan = 1;
				}
				$cell_rowspan = (int)ReTidy::getAttribute($cell, "rowspan")->nodeValue;
				if($cell_rowspan < 1) {
					$cell_rowspan = 1;
				}
				$highest_found_header_new_tbody = false;
				//$header_dimension_of_cell = $value[1];
				$header_dimension_of_cell = ReTidy::getAttribute($cell, "header_dimension")->nodeValue;
				$dimension_counter = 0;
				while($dimension_counter <= $biggest_header_dimension) {
					$dimension_counter++;
					//print('$dimension_counter: ');var_dump($dimension_counter);
					//print("here120<br>\r\n");
					//print('$header_dimension_of_cell, $dimension_counter: ');var_dump($header_dimension_of_cell, $dimension_counter);
					if($header_dimension_of_cell == $dimension_counter) {
						//print("here189<br>\r\n");
						continue;
					}
					if($this->table_headers_dimensions[$dimension_counter][1] === "wide") {
						$y = $index2 - 1;
						while($y > 0) {
							//print("header cell: ");var_dump(ReTidy::DOM_getNodeString($this->table_grid[$index][$y][0]));
							$header_dimension = ReTidy::getAttribute($this->table_grid[$index][$y][0], "header_dimension")->nodeValue;
							if($header_dimension == $dimension_counter) {
								$header_new_tbody = ReTidy::getAttribute($this->table_grid[$index][$y][0], "new_tbody")->nodeValue;
								if($header_new_tbody === 'true') {
									$highest_found_header_new_tbody = $y;
								} else {
									$cell_colspan_counter = $cell_colspan;
									while($cell_colspan_counter > 0) {
										$id = ReTidy::getAttribute($this->table_grid[$index][$y - ($cell_colspan_counter - 1)][0], "id")->nodeValue;
										//print('$id: ' . $id . '<br>');
										if($id) {
											//print('$id2: ' . $id . '<br>');
											ReTidy::applyHeadersWithoutOverwriteIfNew($id, $cell);
										}
										$cell_colspan_counter--;
									}
									break;
								}
							}
							$y--;
						}
					} elseif($this->table_headers_dimensions[$dimension_counter][1] === "high") {
						$x = $index - 1;
						while($x > 0) {
							//print("header cell2: ");var_dump(ReTidy::DOM_getNodeString($this->table_grid[$x][$index2][0]));
							$header_dimension = ReTidy::getAttribute($this->table_grid[$x][$index2][0], "header_dimension")->nodeValue;
							//$header_dimension = $this->table_grid[$x][$index2][1];
							if($header_dimension == $dimension_counter) {
								$cell_rowspan_counter = $cell_rowspan;
								while($cell_rowspan_counter > 0) {
									$id = ReTidy::getAttribute($this->table_grid[$x - ($cell_rowspan_counter - 1)][$index2][0], "id")->nodeValue;
									if($id) {
										//print('$id3: ' . $id . '<br>');
										ReTidy::applyHeadersWithoutOverwriteIfNew($id, $cell);
									}
									$cell_rowspan_counter--;
								}
								break;
							}
							$x--;
						}
					}
				}
				if($highest_found_header_new_tbody !== false && $cell_tfoot_member !== 'true') {
					//print('her3895896909078-098<br>');
					$cell_colspan_counter = $cell_colspan;
					//print("apply_it other<br>\r\n");
					//print('$cell_colspan_counter: ');var_dump($cell_colspan_counter);print('<br>');
					while($cell_colspan_counter > 0) {
						//print('her3895896909078-099<br>');
						$id = ReTidy::getAttribute($this->table_grid[$index][$highest_found_header_new_tbody - ($cell_colspan_counter - 1)][0], "id")->nodeValue;
						//print('$id: ' . $id . '<br>');
						//print('$highest_found_header_new_tbody: ' . $highest_found_header_new_tbody . '<br>');
						if($id) {
							//print(ReTidy::DOM_getNodeString($cell));print("<br>\r\n");
							ReTidy::applyHeadersWithoutOverwriteIfNew($id, $cell);
						}
						$cell_colspan_counter--;
					}
					//continue 2;
				}
			}
		}
		$query = './/@header_dimension';
		$header_dimension_attributes = $this->xpath->query($query, $table);	
		foreach($header_dimension_attributes as $header_dimension_attribute) {
			$header_dimension_attribute->nodeValue = "stripme";
		}
	}
	
	protected function nonEmptyTags($arrayTags) {
		$tempArray = array();
		foreach($arrayTags as $tag) {
			if(!ReTidy::isEmptyTag($tag)) {
				$tempArray[] = $tag;
			}
		}
		return $tempArray;
	}

	protected function areHeaders($arrayCells) {
		foreach($arrayCells as $cell) {
			if($cell->nodeName === "th" || ReTidy::isEmptyTag($cell)) {
				//
			} else {
				return false;
			}		
		}
		return true;
	}
	
	protected function DOM_apply_table_scope($table) {
		//print('applying scope to a table');exit(0);
		//print('here2374785867970<br>');
		$query = './/' . ReTidy::get_html_namespace() . 'tr | .//' . ReTidy::get_html_namespace() . '*[@newtag="tr"]';
		$trs = $this->xpath->query($query, $table);
		foreach($trs as $tr) {
			//print('here2374785867971<br>');
			// make <th>s in first row have scope="col"
			//print($tr->nodeName . "<br>\r\n");
			$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . '*[@newtag="th"]';
			$ths = $this->xpath->query($query, $tr);
			foreach($ths as $th) {
				//print('here2374785867972<br>');
				$spans_cols = false;
				if($th->hasAttributes()) {
					foreach ($th->attributes as $attribute) {
						if($attribute->nodeName === "colspan") {
							$th->setAttribute('scope', 'colgroup');
							continue 2;
						} elseif($attribute->nodeName === "rowspan") {
							$th->setAttribute('scope', 'rowgroup');
							continue 2;
						}
					}
				}
				$th->setAttribute('scope', 'col');
			}
			//print('here2374785867973<br>');
			/*$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
			$cells = $this->xpath->query($query, $tr);
			foreach($cells as $cell) {
			
			if(ReTidy::getAttribute($th, 'newtag')->nodeValue !== "td") {
				$th->setAttribute('id', $this->table_headers_string . $this->page_id_counter);
				$this->page_id_counter++;
			}*/
			//break; // only doing the first row is simplistic...
		}
		
		// make <th>s in first column have scope="row"
		$did_top_left_cell = false;
		foreach($trs as $tr) {
			if($tr->parentNode->nodeName === 'thead') {
				continue;
			}
			//print('here2374785867974<br>');
			$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . '*[@newtag="th"]';
			$ths = $this->xpath->query($query, $tr);
			foreach($ths as $th) {
				// it's difficult for a program to determine what sort of scope the top left cell of a table should have, but we'll try
				/*$apply_row_scope_to_first_th = true;
				
				if(!$did_top_left_cell) {
					$did_top_left_cell = true;
					if(!$apply_row_scope_to_first_th) {
						break; // ?
					}
				}*/
				//print('here2374785867975<br>');
				$spans_rows = false;
				if($th->hasAttributes()) {
					foreach($th->attributes as $attribute) {
						if($attribute->nodeName === "rowspan") {
							$th->setAttribute('scope', 'rowgroup');
							break 2;
						} elseif($attribute->nodeName === "colspan") {
							$th->setAttribute('scope', 'colgroup');
							break 2;
						}
					}
				}
				$th->setAttribute('scope', 'row');
				break; // only looking at the first th in a tr is simplistic...
			}
		}
		//print('here2374785867976<br>');
		return true;
		
	}
	
	protected function DOM_apply_table_headers_ids($table) {
		$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . '*[@newtag="th"]';
		$ths = $this->xpath->query($query, $table);
		foreach($ths as $th) {
			if(ReTidy::getAttribute($th, 'newtag')->nodeValue !== "td") {
				$th->setAttribute('id', $this->table_headers_string . $this->page_id_counter);
				$this->page_id_counter++;
			}
		}
	}
	
	protected function DOM_th_dimension() {
		$query = '//' . ReTidy::get_html_namespace() . 'table';
		$tables = $this->xpath->query($query);
		foreach($tables as $table) {
			ReTidy::DOM_th_dimension_for_table($table);
		}
	}
	
	protected function array_mirror($array) {
		$new_array = array();
		foreach($array as $index => $column) {
			foreach($column as $index2 => $value) {
				$new_array[$index2][$index] = $value;
			}
		}
		return $new_array;
	}
	protected function isNumberDatum($tagless) {
		preg_match('/\s*(\(){0,1}(\-\s*){0,1}[0-9]([0-9.,\s\*\+\-]|&nbsp;){0,}[\$\s%]{0,}(\)){0,1}\s*/is', $tagless, $matches79);
		if(strlen($matches79[0]) === strlen($tagless)) {
			return true;
		} else {
			return false;
		}
	}
	
	protected function DOM_th_dimension_for_table($table) {
		$this->table_headers_dimensions = array();
		$header_dimension_counter = 0;
		$found_a_th = false;
		$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td[@newtag="th"]';
		$ths = $this->xpath->query($query, $table);
		foreach($ths as $th) {
			$found_a_th = true;
			break;
		}
		if(!$this->config['trust_ths']) {
			if(!$found_a_th) {
				ReTidy::DOM_force_ths($table);
			}
		} else { 
			if(!$found_a_th) {
				// if the table does not have table headers, then we may as well break here.
				return;
			}
		}		
		if(!$this->config["trust_ths"] && $found_a_th) {
			foreach($ths as $th) {
				if($th->nodeName === "th") {
					$th->setAttribute('newtag', 'td');
				}
			}
		}
		$width_of_table = sizeof($this->table_grid);
		$height_of_table = sizeof($this->table_grid[1]);
		//print($width_of_table . " x " . $height_of_table . "<br>\r\n");
		$mirrored_table_grid = ReTidy::array_mirror($this->table_grid);
		$found_a_new_tbody_marker = false;
		$added_a_tfoot = false;
		$look_for_tfoot = true;
		//print('$mirrored_table_grid: ');var_dump($mirrored_table_grid);
		foreach($mirrored_table_grid as $index => $row) {
			// the last row should not be table headers (assuming that we have properly identified the origins of the axes)
			//if($height_of_table === $index) {
			//	break;
			//}
			$found_non_header = false;
			$a_cell_has_content = false;
			$all_cells_have_content = true;
			$width = 0;
			foreach($row as $index2 => $value2) {
				$width++;
				$cell = $value2[0];
				if($index2 === 1) { // check for pre-existing tfoot
					if($cell->parentNode->parentNode->nodeName === 'tfoot') {
						//print("cell: ");var_dump(ReTidy::DOM_getNodeString($cell));
						//print('Gadzooks; this is in a tfoot already!');exit(0);
						$look_for_tfoot = false;
					}
				}
				if($look_for_tfoot && $index === sizeof($mirrored_table_grid)) { // the last row
					//print('her3754876879890<br>');
					if($added_a_tfoot) {
						//print('her3754876879891<br>');
						//$cell_new_tfoot = ReTidy::getAttribute($cell, 'new_tfoot')->nodeValue;
						//if($cell_new_tfoot !== 'true') {
							$cell->setAttribute('tfoot_member', 'true');
						//}
					} else {
						//print('her3754876879892<br>');
						if(ReTidy::isEmptyIgnoringWhitespaceAndAttributes($cell)) {
							//print('her3754876879893<br>');
							// look for the next one
						} else {
							//print('her3754876879894<br>');
							//print("cell: ");var_dump(ReTidy::DOM_getNodeString($cell));
							if(stripos(ReTidy::tagless(ReTidy::DOM_getNodeString($cell)), 'total') === false) {
								//print('her3754876879895<br>');
								$look_for_tfoot = false;
							} else { // then we call this the tfoot
								//print('her3754876879896<br>');
								$cell->setAttribute('new_tfoot', 'true');
								$added_a_tfoot = true;
							}
						}
					}
				}
				if(!ReTidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
					$a_cell_has_content = true;
				} else {
					$all_cells_have_content = false;
				}
				if(!($cell->nodeName === "th" || ReTidy::getAttribute($cell, "newtag")->nodeValue === "th") && !Retidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
					$found_non_header = true;
				}
				$cell_colspan = (int)ReTidy::getAttribute($cell, "colspan")->nodeValue;
				if($cell_colspan === 0) {
					$cell_colspan = 1;
				}
			}
			if($cell_colspan == $width && $index !== 1 && $index !== sizeof($mirrored_table_grid)) { // this cell spans the whole row and is not in the last or first row
				//print("cell: ");var_dump(ReTidy::DOM_getNodeString($cell));print('$cell_colspan, $width, $index, sizeof($mirrored_table_grid): ');var_dump($cell_colspan, $width, $index, sizeof($mirrored_table_grid));
				$cell->setAttribute('new_tbody', 'true');
				$found_a_new_tbody_marker = true;
			}
			//print('$found_a_new_tbody_marker, $all_cells_have_content, $found_non_header, $index, $a_cell_has_content: ');var_dump($found_a_new_tbody_marker, $all_cells_have_content, $found_non_header, $index, $a_cell_has_content);
			//if(!$found_non_header && $a_cell_has_content) {
			if(($found_a_new_tbody_marker && $all_cells_have_content && !$found_non_header) || 
			(!$found_a_new_tbody_marker && (!$found_non_header || $index === 1 /* first row */) && $a_cell_has_content)) {
				//print('here8459890097<br>');
				// call this row table headers:
				if($width > 0) {
					$header_dimension_counter++;
					$this->table_headers_dimensions[$header_dimension_counter] = array($width, "wide", 1);
					// if no th was found then only if the width equals the table width
					foreach($row as $index3 => $value3) {
						$cell = $value3[0];
						// a row of headers should not have rowspan
						//print('here48592<br>');
						if(ReTidy::getAttribute($cell, 'rowspan')) {
							// not strictly true; we are approaching questions of fractal dimensionality...
							if($cell === $this->table_grid[$index3][$index - 1][0]) {
								//print('here48593<br>');
								continue;
							}
						}
						if((!$this->config["trust_ths"] || !$found_a_th) && $cell->nodeName != "th" && !Retidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
							//print('here48594<br>');
							$cell->setAttribute('newtag', 'th');
						}
						if(Retidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
							//print('here48595<br>');
							//if(!$this->config["trust_ths"] && $cell->nodeName === "th") { // (2011-11-29)
								$cell->setAttribute('newtag', 'td');
							//}
						}
						if(!ReTidy::getAttribute($cell, 'header_dimension')) {
							//print('here48596<br>');
							//print(ReTidy::DOM_getNodeString($cell));print("<br>\r\n");
							//print("header_dimension_counter1: ");var_dump($header_dimension_counter);print("<br>\r\n");
							$cell->setAttribute('header_dimension', $header_dimension_counter);
						}
						//if($this->table_grid[$index3][$index][1] === 0) {
						//	$this->table_grid[$index3][$index][1] = $header_dimension_counter;
						//}							
					}
				}
			}
		}
		foreach($this->table_grid as $index => $column) {
			// the last column should not be table headers (assuming that we have properly identified the origins of the axes)
			if($width_of_table === $index) {
				break;
			}
			$found_non_header = false;
			$a_cell_has_content = false;
			foreach($column as $index2 => $value2) {
				$cell = $value2[0];
				if(!$a_cell_has_content && !ReTidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
					$a_cell_has_content = true;
				}
				if(!Retidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell) && !($cell->nodeName === "th" || ReTidy::getAttribute($cell, "newtag")->nodeValue === "th")) {
					$found_non_header = true;
					break;
				}
			}
			//if(!$found_non_header && $a_cell_has_content) {
			if((!$found_non_header || $index === 1 ) && $a_cell_has_content) { // first column
				// call this column table headers:
				$height = 0;
				foreach($column as $index3 => $value3) {
					$cell = $value3[0];
					if(!ReTidy::getAttribute($cell, 'header_dimension')) {
						$height++;
					}
					//if($this->table_grid[$index][$index3][1] === 0) {
					//	$height++;
					//}						
				}
				if($height > 0) {
					$header_dimension_counter++;
					$this->table_headers_dimensions[$header_dimension_counter] = array($height, "high", 1);
					foreach($column as $index3 => $value3) {
						$cell = $value3[0];
						// a column of headers should not have colspan
						if(ReTidy::getAttribute($cell, 'colspan')) {
							// not strictly true; we are approaching questions of fractal dimensionality...
							if($cell === $this->table_grid[$index-1][$index3][0]) {
								continue;
							}
						}						
						if((!$this->config["trust_ths"] || !$found_a_th) && $cell->nodeName != "th" && !Retidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
							$cell->setAttribute('newtag', 'th');
						}
						if(Retidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
							//if(!$this->config["trust_ths"] && $cell->nodeName === "th") { // (2011-11-29)
								$cell->setAttribute('newtag', 'td');
							//}
						}
						if(!ReTidy::getAttribute($cell, 'header_dimension')) {
							//print(ReTidy::DOM_getNodeString($cell));print("<br>\r\n");
							//print("header_dimension_counter2: ");var_dump($header_dimension_counter);print("<br>\r\n");								
							$cell->setAttribute('header_dimension', $header_dimension_counter);
						}
						//if($this->table_grid[$index][$index3][1] === 0) {
						//	$this->table_grid[$index][$index3][1] = $header_dimension_counter;
						//}							
					}
				}
			}
		}
		// disabled since this is not generally useful and could confuse somebody not expecting it.
		/*
		$rebuild_table_grid = false;
		foreach($this->table_headers_dimensions as $index => $value) {
			$magnitude = $value[0];
			$direction = $value[1];
			$axis_magnitude = $value[2];
			if($axis_magnitude > 1) {
				if($direction === "wide" && !($this->table_grid[1][1][0] === $this->table_grid[2][1][0])) {
					$query = './/' . ReTidy::get_html_namespace() . 'tr[1]';
					$first_trs = $this->xpath->query($query, $table);
					foreach($first_trs as $first_tr) {  }
					$clone = $first_tr->cloneNode(true);
					$clone->setAttribute('deleteme', 'y');
					$first_clone_th = ReTidy::firstElementChild($clone);
					if($first_clone_th->hasChildNodes()) {
						foreach($first_clone_th->childNodes as $child) {
							//$first_clone_th->removeChild($child);
							//$first_clone_th->setAttribute('deleteme', 'y');
							// ???
						}
					}
					$header_dimension_counter++;
					$this->table_headers_dimensions[$header_dimension_counter] = array($magnitude, "wide", 1);
					if($clone->hasChildNodes()) {
						foreach($clone->childNodes as $child) {
							$header_dimension = ReTidy::getAttribute($child, 'header_dimension');
							if($header_dimension) {
								$header_dimension->nodeValue = $header_dimension_counter;
							}
						}
					}
					$first_tr->parentNode->insertBefore($clone, $first_tr);
					$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
					$not_first_tr_ths = $this->xpath->query($query, $first_tr);
					foreach($not_first_tr_ths as $index => $not_first_tr_th) {
						if($index == 0) { continue; }
						if($not_first_tr_th->hasChildNodes()) {
							foreach($not_first_tr_th->childNodes as $child) {
								//$not_first_tr_th->removeChild($child);
								//$not_first_tr_th->setAttribute('deleteme', 'y');
								// ???
							}
						}
					}
				}
				// doing this for columns is also possible and unlikely and somewhat harder since HTML tables have cells in <tr>s.
				$rebuild_table_grid = true;
			}
		}
		if($rebuild_table_grid) {
			ReTidy::DOM_build_table_grid($table);
			// merge rows where the first cell is a header then all following cells are empty
			foreach(ReTidy::array_mirror($this->table_grid) as $index => $row) {
				//print("row: ");var_dump($row);print("<br>\r\n");
				// check that they all have the same dimension
				$dimension = 0;
				$merge_em = true;
				foreach($row as $index2 => $value) {
					$cell = $value[0];
					$header_dimension = ReTidy::getAttribute($cell, 'header_dimension');
					if(!$header_dimension) {
						$merge_em = false;
						break;
					}
					if($dimension === 0) { // initialization
						$dimension = $header_dimension;
					} else {
						if(!ReTidy::isEmpty($cell) || $dimension != $header_dimension) {
							$merge_em = false;
							break;						
						}
					}
				}
				if($merge_em) {
					$width490 = sizeof($row);
					$array_cells_removed = array();
					foreach($row as $index2 => $value) {
						$cell = $value[0];
						// since cells could span columns
						foreach($array_cells_removed as $cell_removed) {
							if($cell === $cell_removed) {
								continue 2;
							}
						}
						if($index2 === 1) {
							$cell->setAttribute('colspan', $width490);
						} else {
							$array_cells_removed[] = $cell;
							//$cell->parentNode->removeChild($cell);
							//$cell->setAttribute('deleteme', 'y');
							// ???
						}
					}
				}
			}
			ReTidy::DOM_empty_ths($table);
			ReTidy::DOM_build_table_grid($table);
		}*/
		//var_dump($this->table_headers_dimensions);
	}
	
	protected function DOM_build_table_grid($table) {
		$this->table_grid = array();
		//$this->count40945++;
		$grid_x = 0;
		$grid_y = 0;
		$this->table_width = 0;
		$this->table_height = 0;
		$query = './/' . ReTidy::get_html_namespace() . 'tr';
		$trs = $this->xpath->query($query, $table);
		foreach($trs as $tr) {
			$query = ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'td';
			$cells = $this->xpath->query($query, $tr);
			//print("tr: ");var_dump(ReTidy::DOM_getNodeString($tr));print("<br>\r\n");
			// find the table that this <tr> is in to check for nested tables.
			$table_query = 'ancestor::' . ReTidy::get_html_namespace() . 'table[1]';
			$tables_for_this_tr = $this->xpath->query($table_query, $tr);
			foreach($tables_for_this_tr as $table_for_this_tr) {
				//print("table_for_this_tr: ");var_dump(ReTidy::DOM_getNodeString($table_for_this_tr));print("<br>\r\n");
				if($table_for_this_tr !== $table) {
					continue 2;
				}
			}
			foreach($cells as $cell) {
				$colspan_amount = ReTidy::getAttribute($cell, "colspan")->nodeValue;
				$rowspan_amount = ReTidy::getAttribute($cell, "rowspan")->nodeValue;
				if(!$colspan_amount) $colspan_amount = 1;
				$colspan_amount2 = $colspan_amount;
				if(!$rowspan_amount) $rowspan_amount = 1;
				$grid_y2 = $grid_y;
				$grid_x2 = $grid_x;
				while($rowspan_amount > 0) {
					$grid_y2++;
					while($colspan_amount > 0) {
						$grid_x2++;
						if(isset($this->table_grid[$grid_x2][$grid_y2])) {
							// skip it
						} else {
							//$this->table_grid[$grid_x2][$grid_y2] = ReTidy::DOM_getNodeString($cell);
							$this->table_grid[$grid_x2][$grid_y2] = array($cell);
							$colspan_amount--;
						}
					}
					$rowspan_amount--;
					if($rowspan_amount > 0) {
						$colspan_amount = $colspan_amount2;
						$grid_x2 = $grid_x;
					} else {
						$grid_x = $grid_x2;
					}
				}
			}
			if($grid_x > $this->table_width) {
				$this->table_width = $grid_x;
			}
			$grid_x = 0;
			$grid_y++;
		}
		$this->table_height = $grid_y;
		
		// analyze the table for, among other things, data cells and chart styleness
		ReTidy::DOM_analyze_table($table);
		
		/*foreach($this->table_grid as $index => $column) {
			foreach($column as $index2 => $value) {
				if($this->table_grid[$index][$index2][0]->nodeName === "th") {
					$this->table_grid[$index][$index2][] = 1;
				} else {
					$this->table_grid[$index][$index2][] = 0;
				}
			}
		}
		foreach(ReTidy::array_mirror($this->table_grid) as $index => $row) {
			foreach($row as $index2 => $value) {
				$cell = $value[0];
				$header_dimension = $value[1];
				print($header_dimension);
			}
			print("<br>\r\n");
		}
		print("-<br>\r\n");*/
		
		//var_dump($this->table_grid);print("<br>\r\n");
		return true;
	}	
	
	protected function DOM_analyze_table($table) {
		// this is currently (2009-08-25) a dummy function but it could extend DOM_build_table_grid
		if(false) {
			$this->table_style = "chart";
		} else {
			$this->table_style = "normal";
		}
	}
	
	protected function DOM_force_ths($table) {
		// neither this or the table headers applier are currently smart enough to apply in reverse reading order (I believe) (2009-06-23)
		// ??
		$number_cells = $number_number_cells = $number_empty_cells = 0;
		$toppest_number = false;
		$leftest_number = false;
		foreach($this->table_grid as $index => $column) {
			foreach($column as $index2 => $value) {
				$number_cells++;
				$cell = $value[0];
				if(ReTidy::isNumberDatum(ReTidy::tagless($cell))) {
					$number_number_cells++;
					// mark the cell as a number
					$this->table_grid[$index][$index2][2] = "number";
					if(!$toppest_number && !$leftest_number) {
						// this should always find the first number in the table.
						$toppest_number = $index2;
						$leftest_number = $index;
					}
				}
				if(ReTidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell)) {
					$number_empty_cells++;
					// mark the cell as empty
					$this->table_grid[$index][$index2][2] = "empty";
				}
			}
		}
		
		$number_data_cells = $number_number_cells + $number_empty_cells;
		if(bcdiv($number_number_cells, $number_cells, 2) > 0.3) {
			if(bcdiv($number_empty_cells, $number_cells, 2) < 0.1 || bcdiv($number_data_cells, $number_cells, 2) > 0.5) {
				// the primary type of data is numbers
				foreach($this->table_grid as $index => $column) {
					foreach($column as $index2 => $value) {
						if($toppest_number <= $index2 && $leftest_number <= $index) {
							// we are into the data region of the table
							break;
						}
						$cell = $value[0];
						if($this->table_grid[$index][$index2][2] != "number" && 
						$this->table_grid[$index][$index2][2] != "empty" && 
						$cell->nodeName != "th" /*&& 
						!Retidy::isEmpty($cell)*/) {
							$cell->setAttribute('newtag', 'th');
						}
					}
				}
			}
		}
		$done_a_column = false;
		$done_a_row = false;
		foreach($this->table_grid as $index => $column) {
			$found_non_strong_in_column = false;
			foreach($column as $index2 => $value) {
				$cell = $value[0];
				if($index === 1) {
					if($index2 === 1) {
						// the top left cell will not be a data cell
						continue;
					}
					if(ReTidy::getAttribute($cell, 'rowspan')) {
						// this is pretty aggressive
						break;
					}
				}
				if(!$found_non_strong_in_column) {
					$query = './/' . ReTidy::get_html_namespace() . 'strong[1]';
					$first_strong_in_cell = $this->xpath->query($query, $cell);
					$strong = false;
					foreach($first_strong_in_cell as $strong) { }
					if(!$strong) {
						if(ReTidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell) || ReTidy::getAttribute($cell, "newtag")->nodeValue === "th" || $cell->nodeName === "th") {
					
						} else {
							$found_non_strong_in_column = true;
							break;
						}
					} else {
						if(ReTidy::haveSameTextContent($cell, $strong)) {
							
						} else {
							$found_non_strong_in_column = true;
							break;
						}
					}
				}
			}
			if(!$found_non_strong_in_column) {
				$done_a_column = true;
				foreach($column as $index2 => $value) {
					if($toppest_number && $leftest_number && $toppest_number <= $index2 && $leftest_number <= $index) {
						// we are into the data region of the table
						break;
					}
					$cell = $value[0];
					if(!ReTidy::isEmpty($cell)) {
						$cell->setAttribute('newtag', 'th');
					}
				}
			} elseif(!$done_a_column) {
				// keep looking
			} else {
				break;
			}
		}
		foreach(ReTidy::array_mirror($this->table_grid) as $index => $row) {
			$found_non_strong_in_row = false;
			foreach($row as $index2 => $value) {
				$cell = $value[0];
				if($index === 1) {
					if($index2 === 1) {
						// the top left cell will not be a data cell
						continue;
					}
					if(ReTidy::getAttribute($cell, 'colspan')) {
						// this is pretty aggressive
						break;
					}
				}
				if(!$found_non_strong_in_row) {
					$query = './/' . ReTidy::get_html_namespace() . 'strong[1]';
					$first_strong_in_cell = $this->xpath->query($query, $cell);
					$strong = false;
					foreach($first_strong_in_cell as $strong) { }
					if(!$strong) {
						if(ReTidy::isEmptyTagIgnoringWhitespaceAndAttributes($cell) || ReTidy::getAttribute($cell, "newtag")->nodeValue === "th" || $cell->nodeName === "th") {
						
						} else {
							$found_non_strong_in_row = true;
							break;
						}
					} else {
						if(ReTidy::haveSameTextContent($cell, $strong)) {
							//print("same<br>\r\n");
						} else {
							//print("not<br>\r\n");
							$found_non_strong_in_row = true;
							break;
						}
					}
				}
			}
			if(!$found_non_strong_in_row) {
				$done_a_row = true;
				foreach($row as $index2 => $value) {
					if($toppest_number && $leftest_number && $toppest_number <= $index2 && $leftest_number <= $index) {
						// we are into the data region of the table
						break;
					}
					$cell = $value[0];
					if(!ReTidy::isEmpty($cell)) {
						$cell->setAttribute('newtag', 'th');
					}
				}
			} elseif(!$done_a_row) {
				// keep looking
			} else {
				break;
			}
		}
	}

	protected function definition_listify() {
		preg_match_all('/<div class="definition_listify">(.*?)<\/div>/is', $this->code, $matches);
		// we are going through in reverse order to allow substr maniplation to be the replacement mechanism by preserving the offsets but is it necessary?
		$this->logMsgIf('definition_listify', sizeof($matches[0]));
		$counter = sizeof($matches[0]) - 1;
		while($counter > -1) {
			$initial_code_to_listify = $code_to_listify = $matches[0][$counter];
			$code_to_listify = '<dl>' . $matches[1][$counter] . '</dl>';
			$code_to_listify = preg_replace('/<p>([^:]*?):\s*(.*?)<\/p>/is', '<dt>$1:</dt>
<dd>$2</dd>', $code_to_listify);
			$this->code = str_replace($initial_code_to_listify, $code_to_listify, $this->code);
			$counter--;
		}
	}
	
	protected function flip_tables() {
		// simplistic function that does not currently (2015-04-23) preserve attributes on trs or the table tag
		$tables_flipped_counter = 0;
		$new_tables_array = array();
		$tables = OM::getAllOStrings($this->code, '<table', '</table>');
		//print('$tables: ');var_dump($tables);exit(0);
		foreach($tables as $table) {
			$new_table_array = array();
			preg_match_all('/<(tr)([^<>]*?)>(.*?)<\/\1>/is', $table[0], $tr_matches, PREG_OFFSET_CAPTURE);
			//print('$tr_matches: ');var_dump($tr_matches);exit(0);
			$rowspan = 1;
			//$debug_counter = 0;
			foreach($tr_matches[0] as $index => $value) {
				preg_match_all('/<(td|th)([^<>]*?)>(.*?)<\/\1>/is', $value[0], $cell_matches, PREG_OFFSET_CAPTURE);
				if($rowspan > 1) {
					foreach($cell_matches[0] as $index2 => $value2) {
						preg_match_all('/rowspan="([^"]*?)"/is', $value2[0], $rowspan_matches, PREG_OFFSET_CAPTURE);
						if(sizeof($rowspan_matches[0]) > 0) {
							$rowspan = (int)$rowspan_matches[1][0][0];
							//print('$rowspan2: ');var_dump($rowspan);exit(0);
						}
						$new_table_array[$index2 + 1][] = $value2[0];
					} 
				} else {
					foreach($cell_matches[0] as $index2 => $value2) {
						preg_match_all('/rowspan="([^"]*?)"/is', $value2[0], $rowspan_matches, PREG_OFFSET_CAPTURE);
						if(sizeof($rowspan_matches[0]) > 0) {
							//print('$rowspan_matches: ');var_dump($rowspan_matches);exit(0);
							$rowspan = (int)$rowspan_matches[1][0][0] + 1;
							//print('$rowspan2: ');var_dump($rowspan);exit(0);
						}
						$new_table_array[$index2][] = $value2[0];
					}
				}
				$rowspan--;
				/*if($debug_counter === 8) {
					//print('$new_table_array: ');var_dump($new_table_array);exit(0);
					break;
				}
				$debug_counter++;*/
			}
			$new_tables_array[] = $new_table_array;
		}
		//print('$new_tables_array: ');var_dump($new_tables_array);exit(0);
		$reversed_tables = array_reverse($tables);
		$counter = sizeof($reversed_tables) - 1;
		foreach($reversed_tables as $table) {
			$new_table_code = '<table>
';
			foreach($new_tables_array[$counter] as $row => $cells) {
				$new_table_code .= '<tr>
';
				foreach($cells as $cell) {
					$cell = str_replace('colspan', 'XXXrow9o9spanXXX', $cell);
					$cell = str_replace('rowspan', 'colspan', $cell);
					$cell = str_replace('XXXrow9o9spanXXX', 'rowspan', $cell);
					$new_table_code .= $cell . '
';
				}
				$new_table_code .= '</tr>
';
			}
			$new_table_code .= '</table>';
			$this->code = substr($this->code, 0, $table[1]) . $new_table_code . '<table deleteme="y"' . substr($this->code, $table[1] + 6);
			$counter--;
			$tables_flipped_counter++;
		}
		
		// fucking DOM...
		/*$query = '//' . ReTidy::get_html_namespace() . 'table';
		$tables = $this->xpath->query($query);
		foreach($tables as $table) {
			$query = './/' . ReTidy::get_html_namespace() . 'tr';
			$trs = $this->xpath->query($query, $table);
			$new_table_array = array();
			$record_max_cells_per_row = 0;
			$row = 0;
			foreach($trs as $tr) {
				$max_cells_per_row = 0;
				$query = './/' . ReTidy::get_html_namespace() . 'th | .//' . ReTidy::get_html_namespace() . 'td';
				$cells = $this->xpath->query($query, $tr);
				$new_tr_array = array();
				foreach($cells as $cell) {
					$new_tr_array[] = $cell;
					$max_cells_per_row++;
				}
				$new_table_array[$row] = $new_tr_array;
				if($max_cells_per_row > $record_max_cells_per_row) {
					$record_max_cells_per_row = $max_cells_per_row;
				}
				$row++;
			}
			//var_dump($new_table_array);
			//$new_table = new DOMElement('table');
			$new_table = $this->dom->createElementNS(self::$xhtmlns, 'table');
			$tr_counter = 0;
			while($tr_counter < $record_max_cells_per_row) {
				print('here4585687979789<br>');
				//$new_tr = new DOMElement('tr');
				$new_tr = $this->dom->createElementNS(self::$xhtmlns, 'tr');
				foreach($new_table_array as $row => $cells) {
					print('here4585687979790<br>');
					foreach($cells as $index => $cell) {
						print('here4585687979791<br>');
						//if($index === $tr_counter) {
							print('here4585687979792<br>');
							//$clone = $cell->cloneNode(true);
							$new_tr->appendChild($cell);
						//}
					}
					break;
				}
				$new_table->appendChild($new_tr);
				$tr_counter++;
			}
			$table->parentNode->appendChild($new_table);
			//$table->parentNode->appendChild(new DOMText("XXX9o9NewTagEndXXXccc9o9XXX"));
			//$previousElement->appendChild(new DOMText("XXX9o9NewTagEndXXXstrong9o9XXX"));
			//$tr_cell->appendChild(new DOMText(ReTidy::DOM_decoded_for_DOM_child_of($element_cell)));
			$table->setAttribute('deleteme', 'y');
			$tables_flipped_counter++;
		}*/
		$this->logMsgIf('tables flipped', $tables_flipped_counter);
		return $tables_flipped_counter;
	}
	
	protected function DOM_apply_table_accessibility() {
		if($this->config['table_headers_id_start_count']) {
			$this->page_id_counter = $this->config['table_headers_id_start_count'];
		} else {
			$this->page_id_counter = file_get_contents("page_id_counter.txt");
			//$this->page_id_counter = 0;
		}
		if($this->config['table_headers_string']) {
			$this->table_headers_string = $this->config['table_headers_string'];
		} else {
			$this->table_headers_string = 'th_';
		}
		$query = '//' . ReTidy::get_html_namespace() . 'table';
		$tables = $this->xpath->query($query);
		//$count5890 = 0;
		//$this->count40945 = 0;
		foreach($tables as $table) {
			//$count5890++;
			//if($this->config['table_type'] === 'simple') {
			//	ReTidy::DOM_apply_table_scope($table);
			//} else { // default to complex table accessibility
				ReTidy::DOM_build_table_grid($table);
				ReTidy::DOM_th_dimension_for_table($table);
				ReTidy::DOM_apply_table_headers_ids($table);
				ReTidy::DOM_apply_table_headers($table);
			//}
			if($this->config['table_type'] === 'simple') {
				ReTidy::DOM_table_headers_and_ids_to_scope($table);
			}
			//ReTidy::DOM_table_summary_ti($table);
			//ReTidy::DOM_table_summary_PC($table);
			ReTidy::DOM_table_summary($table); // It seems that finally (2012-04-01) accessibility has been separated from validation for W3C validator so that it no longer complains about summary attributes missing.
			ReTidy::DOM_table_structure($table);
		}
		//print("count: " . $count5890 . "<br>\r\n");
		//print("grid count: " . $this->count40945);		
		return true;
	}	

	protected function DOM_clean_redundant_tags() {
		$count = 0;
		// at least for treasury board, <th>s are not bold by default.
		/*$query = '//' . ReTidy::get_html_namespace() . 'th/' . ReTidy::get_html_namespace() . 'strong';
		$strong_in_ths = $this->xpath->query($query);
		foreach($strong_in_ths as $strong_in_th) {
			$strong_in_th->setAttribute("stripme", "y");
			ReTidy::DOM_strip_node($strong_in_th);
			$count++;
		}*/
		$arrayHeadings = array("h1", "h2", "h3", "h4", "h5", "h6");
		foreach($arrayHeadings as $heading) {
			$query = '//' . ReTidy::get_html_namespace() . $heading . '/' . ReTidy::get_html_namespace() . 'strong';
			$strong_in_headings = $this->xpath->query($query);
			foreach($strong_in_headings as $strong_in_heading) {
				$strong_in_heading->setAttribute("stripme", "y");
				ReTidy::DOM_strip_node($strong_in_heading);
				$count++;
			}			
		}
		// added (2011-06-28) since <a... name=""...> is deprecated.
		// tidy cleans name attributes off of footnotes; 
		// as for anchors, we want to do better than tidy and give their IDs to their parents if they anchor the same position.
		// anchors are <a> tags without href attributes
		if($this->WET === "WET" || $this->config['WET'] === "WET") {
			$ignore_array = array('stripme', 'XXX9o9stripme9o9XXX');
			$query = '//' . ReTidy::get_html_namespace() . 'a';
			$possible_anchors = $this->xpath->query($query);
			foreach($possible_anchors as $possible_anchor) {
				$is_anchor = true;
				if($possible_anchor->hasAttributes()) {
					foreach($possible_anchor->attributes as $attribute) {
						if($attribute->nodeName === "href") {
							$is_anchor = false;
							break 2;
						}
					}
					if($is_anchor) {
						//ReTidy::giveAttributesToLeastAncientConflationaryBlockAllowed($possible_anchor);
						// it would be nice if this worked, but it does not account for being an empty first child
						$move_the_id = false;
						$possible_parent = $possible_anchor;
						while(ReTidy::isFirstChildIgnoringWhitespace($possible_parent) || 
						ReTidy::isConflationaryWithParentIgnoringWhitespace($possible_parent)) {
							$possible_parent = $possible_parent->parentNode;
							if(ReTidy::isBlock($possible_parent)) {
								$parent = $possible_parent;
								$move_the_id = true;
								break; // applying to the least ancient conflationary block is better than applying to the most ancient conflationary block
							}
						}
						if($move_the_id) {
							// notice that if the <a> tag has attributes other than the id that should not be promoted to its block parent
							// (which is unliklely) they still will be promoted.
							ReTidy::applyAttributesWithoutOverwriteWithIgnore($possible_anchor, $parent, $ignore_array);
							$possible_anchor->setAttribute("stripme", "y");
							ReTidy::DOM_strip_node($possible_anchor);
							$count++;
						}
					}
				}
			}
		}
		$this->logMsgIf("DOM_clean_redundant_tags", $count);
	}

	protected function DOM_clean_extraneous () {
		ReTidy::DOM_non_styled_spans();
		//ReTidy::DOM_clean_extraneous_inline_in_block();
		ReTidy::DOM_clean_extraneous_inline();
		//ReTidy::DOM_clean_extraneous_block();
		ReTidy::DOM_clean_extraneous_ineffective_inline();		
	}
	
	protected function clean_ineffective_inline() {
		$ct = $ct2 = 0;
		$arrayTagNames = array();
		$entity = DTD::getInline();
		$arrayIgnoreTagNames = DTD::getElementsByContent("EMPTY");
		$arrayInlineTags = explode("|", $entity);
		foreach($arrayInlineTags as $inlineTag) {
			if($inlineTag === "a") {
				continue;
			}
			foreach($arrayIgnoreTagNames as $ignoreTagName) {
				if($inlineTag === $ignoreTagName) {
					continue 2;
				}
			}
			$arrayTagNames[] = $inlineTag;
		}
		$inline_string = implode('|', $arrayTagNames);
		$this->code = preg_replace('/((' . $this->spaceRegex . '){1,})(<\/(' . $inline_string . ')>)/is', '$3$1', $this->code, -1, $ct);
		$this->code = preg_replace('/(<(' . $inline_string . ')( [^<>]*){0,1}>)((' . $this->spaceRegex . '){1,})/is', '$4$1', $this->code, -1, $ct2);		
		$this->logMsgIf("clean_ineffective_inline", $ct + $ct2);
	}

	protected function DOM_clean_extraneous_ineffective_inline() {
		$ct = 0;
		$arrayTagNames = array();
		$entity = DTD::getInline();
		$arrayIgnoreTagNames = DTD::getElementsByContent("EMPTY");
		$arrayInlineTags = explode("|", $entity);
		foreach($arrayInlineTags as $inlineTag) {
			foreach($arrayIgnoreTagNames as $ignoreTagName) {
				if($inlineTag === $ignoreTagName) {
					continue 2;
				}
			}
			$arrayTagNames[] = $inlineTag;
		}
		$inline_string = '//' . ReTidy::get_html_namespace() . implode('|//' . ReTidy::get_html_namespace(), $arrayTagNames);
		$query = $inline_string;
		$inline_tags = $this->xpath->query($query);
		foreach($inline_tags as $inline_tag) {
			if($inline_tag->nodeName === "a") {
				if(ReTidy::getAttribute($inline_tag, "name") || ReTidy::getAttribute($inline_tag, "id")) { // we want to keep <a>s acting as anchors
					continue;
				}
			}
			$tagless = ReTidy::tagless(ReTidy::DOM_getNodeString($inline_tag));
			preg_match('/([' . $this->styleAgnosticCharacters . ' ]|&nbsp;|&#160;){0,}/is', $tagless, $matches);
			if(strlen($matches[0]) === strlen($tagless)) {
				$inline_tag->setAttribute("stripme", "y");
				ReTidy::DOM_strip_node($inline_tag);
				$ct++;
			}
		}
		$this->logMsgIf("DOM_clean_extraneous_ineffective_inline", $ct);
	}
	
	protected function non_styled_spans() {
		while(strpos($this->code, "<span>") !== false) {
			$array_replaces = array();
			preg_match_all('/<span>/i', $this->code, $span_matches, PREG_OFFSET_CAPTURE);
			foreach($span_matches[0] as $index => $value) {
				$offset = $value[1];
				$object_string = OM::getOString($this->code, "<span", "</span>", $offset);
				$replace_string = substr($object_string, 6, strlen($object_string)-6-7);
				$array_replaces[] = array($object_string, $replace_string);
			}
			$array_replaces = ReTidy::arrayUnique($array_replaces);
			foreach($array_replaces as $index => $value) {
				$search = $value[0];
				$replace = $value[1];
				$this->code = str_replace($search, $replace, $this->code);
			}
		}
	}
	
	protected function DOM_non_styled_spans() {
		$query = '//' . ReTidy::get_html_namespace() . 'span';
		$spans = $this->xpath->query($query);
		foreach($spans as $span) {
			$stripit = false;
			if(!$span->hasAttributes()) {
				$stripit = true;
			} else {
				$found_non_strip = false;
				foreach($span->attributes as $attribute) {
					if(strpos($attribute->nodeName, "stripme") === false && strpos($attribute->nodeValue, "stripme") === false) {
						$found_non_strip = true;
						break;
					}
				}
				if(!$found_non_strip) {
					$stripit = true;
				}
			}
			if($stripit) {
				$span->setAttribute('stripme', 'y');
				ReTidy::DOM_strip_node($span);
			}
		}
	}

	protected function clean_extraneous_inline() {
		// not used (2009-08-10) although this would probably work faster than its DOM counterpart (by using OM).
	}
	
	protected function DOM_clean_extraneous_inline() {
		$count = 0;
		$ArrayOfInlineTagToCleanNames = array(
		'span',
		'font',
		);
		foreach($ArrayOfInlineTagToCleanNames as $inlineTagToCleanName) {
			$query = '//' . ReTidy::get_html_namespace() . $inlineTagToCleanName;
			$inlineTagsToClean = $this->xpath->query($query);
			foreach($inlineTagsToClean as $inlineTagToClean) {
				if($inlineTagToClean->hasAttributes()) {
					if(ReTidy::getAttribute($inlineTagToClean, "stripme")->nodeValue === "y") {
						// do not promote attributes
						continue;
					}					
					if(ReTidy::giveAttributesToMostAncientConflationaryInlineAllowed($inlineTagToClean)) {
						$inlineTagToClean->setAttribute("stripme", "y");
						ReTidy::DOM_strip_node($inlineTagToClean);
						$count++;
						continue;
					}
				} else {
					$inlineTagToClean->setAttribute("stripme", "y");
					ReTidy::DOM_strip_node($inlineTagToClean);
					$count++;						
					continue;
				}
			}
		}
		// <a> (with no attributes)...
		$ArrayOfInlineTagToCleanNames = array(
		'a',										
		);
		foreach($ArrayOfInlineTagToCleanNames as $inlineTagToCleanName) {
			$query = '//' . ReTidy::get_html_namespace() . $inlineTagToCleanName;
			$inlineTagsToClean = $this->xpath->query($query);
			foreach($inlineTagsToClean as $inlineTagToClean) {
				if($inlineTagToClean->hasAttributes()) {

				} else {
					$inlineTagToClean->setAttribute("stripme", "y");
					ReTidy::DOM_strip_node($inlineTagToClean);
					$count++;						
					continue;
				}
			}
		}
		$this->logMsgIf("DOM_clean_extraneous_inline", $count);
		return true;
	}
	
	protected function DOM_clean_extraneous_inline_in_block() {
		$count = 0;
		$ArrayOfInlineTagToCleanNames = array(
		'span',
		'font',
		);
		foreach($ArrayOfInlineTagToCleanNames as $inlineTagToCleanName) {
			$query = '//' . ReTidy::get_html_namespace() . $inlineTagToCleanName;
			$inlineTagsToClean = $this->xpath->query($query);
			foreach($inlineTagsToClean as $inlineTagToClean) {
				if($inlineTagToClean->hasAttributes()) {
					if(ReTidy::getAttribute($inlineTagToClean, "stripme")->nodeValue === "y") {
						// do not promote attributes
						continue;
					}
					if(ReTidy::giveAttributesToLeastAncientConflationaryBlockAllowed($inlineTagToClean)) {
						$inlineTagToClean->setAttribute("stripme", "y");
						ReTidy::DOM_strip_node($inlineTagToClean);
						$count++;
						continue;
					}
				} else {
					$inlineTagToClean->setAttribute("stripme", "y");
					ReTidy::DOM_strip_node($inlineTagToClean);
					$count++;						
					continue;
				}
			}
		}
		$this->logMsgIf("DOM_clean_extraneous_inline_in_block", $count);
		return true;
	}

	protected function DOM_clean_extraneous_block() {
		$count = 0;
		$ArrayOfBlockTagToCleanNames = array(
		'div',
		);
		foreach($ArrayOfBlockTagToCleanNames as $blockTagToCleanName) {
			//$query = '//' . ReTidy::get_html_namespace() . $blockTagToCleanName;
			$query = '//' . $blockTagToCleanName;
			$blockTagsToClean = $this->xpath->query($query);
			foreach($blockTagsToClean as $blockTagToClean) {
				if($blockTagToClean->hasAttributes()) {
					if(ReTidy::giveAttributesToLeastAncientConflationaryBlockAllowed($blockTagToClean)) {
						$blockTagToClean->setAttribute("stripme", "y");
						ReTidy::DOM_strip_node($blockTagToClean);
						$count++;
						continue;
					}
				} else {
					$blockTagToClean->setAttribute("stripme", "y");
					ReTidy::DOM_strip_node($blockTagToClean);
					$count++;						
					continue;
				}
			}
		}
		$this->logMsgIf("DOM_clean_extraneous_block", $count);
		return true;
	}
	
	protected function rec_DOM_previousElement($node) {
		$previousSibling = $node->previousSibling;
		if($previousSibling) {		
			if($previousSibling->nodeType != 1) {
				$previousSibling = ReTidy::rec_DOM_previousElement($previousSibling);
			}
		} else {
			return false;
		}
		return $previousSibling;
	}
	
	protected function nextElement($node, $element_name = false) {
		$nextSibling = $node->nextSibling;
		if($nextSibling) { // should we use ReTidy::isNode() here?
			if($nextSibling->nodeType != 1) {
				$nextSibling = ReTidy::nextElement($nextSibling, $element_name);
			}
			if($element_name !== false) {
				if(!($nextSibling->nodeName === $element_name)) {
					$nextSibling = ReTidy::nextElement($nextSibling, $element_name);
				}
			}
		} else {
			return false;
		}
		return $nextSibling;
	}
	
	protected function previousElement($node, $element_name = false) {
		$previousSibling = $node->previousSibling;
		if($previousSibling) { // should we use ReTidy::isNode() here?
			if($previousSibling->nodeType != 1) {
				$previousSibling = ReTidy::previousElement($previousSibling, $element_name);
			}
			if($element_name !== false) {
				if(!($previousSibling->nodeName === $element_name)) {
					$previousSibling = ReTidy::previousElement($previousSibling, $element_name);
				}
			}
		} else {
			return false;
		}
		return $previousSibling;
	}	

	protected function previousElementIgnoringNesting($node) {
		if($node->nodeType === 9) {
			return false;
		}
		$previousSibling = $node->previousSibling;
		if($previousSibling) {		
			if($previousSibling->nodeType != 1) {
				$previousSibling = ReTidy::previousElementIgnoringNesting($previousSibling);
			}
		} else {
			$previousSibling = ReTidy::previousElementIgnoringNesting($node->parentNode);
		}
		return $previousSibling;
	}

	protected function rec_DOM_previousSiblingNonWhitespace($node) {
		$previousSibling = $node->previousSibling;
		if($previousSibling->nodeType === 3) {
			if(ReTidy::isWhitespace($previousSibling)) {
				$previousSibling = ReTidy::rec_DOM_previousSiblingNonWhitespace($previousSibling);			
			} else {
				return $previousSibling;
			}
		}
		return $previousSibling;
	}
	
	protected function rec_DOM_nextSiblingNonWhitespace($node) {
		$nextSibling = $node->nextSibling;
		if($nextSibling->nodeType === 3) {
			if(ReTidy::isWhitespace($nextSibling)) {
				$nextSibling = ReTidy::rec_DOM_nextSiblingNonWhitespace($nextSibling);			
			} else {
				return $nextSibling;			
			}
		}
		return $previousSibling;
	}	
	
	protected function hasOnlyOneChildIgnoringSpace($node) {
		$children_count = 0;
		if($node->hasChildNodes()) {
			foreach($node->childNodes as $childNode) {
				if(!ReTidy::isSpace($childNode)) {
					$children_count++;
				}
			}
			if($children_count === 1) {
				return true;
			}
		}
		return false;
	}
	
	protected function hasOnlyOneChildIgnoringWhitespace($node) {
		$children_count = 0;
		if($node->hasChildNodes()) {
			foreach($node->childNodes as $childNode) {
				if(!ReTidy::isWhitespace($childNode)) {
					$children_count++;
				}
			}
			if($children_count === 1) {
				return true;
			}
		}
		return false;
	}
	
	protected function firstChildIgnoringWhitespace($node) {
		if($node->hasChildNodes()) {
			$firstChild = $node->firstChild;
			if(ReTidy::isWhitespace($firstChild)) {
				$firstChild = ReTidy::nextSiblingNonWhitespace($firstChild);
			}
			return $firstChild;
		} else {
			return false;
		}
	}

	protected function firstChildIgnoringWhitespaceAndAttributes($node) {
		if($node->hasChildNodes()) {
			$firstChild = $node->firstChild;
			if(ReTidy::isWhitespace($firstChild)) {
				$firstChild = ReTidy::nextSiblingNonWhitespace($firstChild);
			}
			if($firstChild->nodeType === 2) {
				$firstChild = ReTidy::nextSiblingNonAttribute($firstChild);
			}
			return $firstChild;
		} else {
			return false;
		}
	}
	
	protected function previousSiblingNonWhitespace($node) {
		while(ReTidy::isWhitespace($node)) {
			$node = $node->previousSibling;
		}
		return $node;
	}
	
	protected function previousSiblingNonAttribute($node) {
		while($node->nodeType === 2) {
			$node = $node->previousSibling;
		}
		return $node;
	}
	
	protected function nextSiblingNonWhitespace($node) {
		while(ReTidy::isWhitespace($node)) {
			$node = $node->nextSibling;
		}
		return $node;
	}
	
	protected function nextSiblingNonAttribute($node) {
		while($node->nodeType === 2) {
			$node = $node->nextSibling;
		}
		return $node;
	}	
	
	protected function isWhitespace($node) {
		if($node->nodeType) {
			if($node->nodeType === 3) {
				preg_match_all('/[^\s]/s', $node->nodeValue, $matches);
				if(sizeof($matches[0]) > 0) {
					return false;
				} else {
					return true;		
				}
			}
		} else {
			print("has no nodeType (isWhitespace): " . htmlentities(ReTidy::DOM_getNodeString($node)) . "<br>\r\n");
		}
		return false;
	}
	
	protected function isInlineForMostAncientConflationary($node) {
		$entity = DTD::getInline();
		$entity = str_replace('|sup', '', $entity);
		// this is a hack... we do not want a string with a footnote where inline tags have been split to give the id="" to the <sup> and 
		// and the name="" to the <a> since after the code is tidied, the <a> gets the id="" added on which is then invalid since there
		// are two id=""s with the same value.
		// I guess ideally we would join any split spans to avoid this problem.
		// (2011-06-27) footnotes no longer use the name attribute which may avoid the problem
		$arrayInlineTags = explode("|", $entity);
		foreach($arrayInlineTags as $inline) {
			if($node->nodeName === $inline) {
				return true;
			}
		}
		return false;
	}
	
	protected function isBlock($node) {
		if(!isset($this->blockString)) {
			$this->blockString = DTD::getBlock() . "|td|th|li";
		}
		$arrayBlockTags = explode("|", $this->blockString);
		foreach($arrayBlockTags as $block) {
			if($node->nodeName === $block) {
				return true;
			}
		}
		return false;
	}	
	
	protected function isInline($node) {
		$entity = DTD::getInline();
		$arrayInlineTags = explode("|", $entity);
		foreach($arrayInlineTags as $inline) {
			if($node->nodeName === $inline) {
				return true;
			}
		}
		return false;
	}

	protected function mostAncientConflationaryInlineAncestorWithIgnore($tag, $ignore) {
		if(ReTidy::DOM_isConflationaryWithParentIgnoringWhitespace($tag) && ReTidy::isInline($tag->parentNode)) {
			if($tag->parentNode->nodeName === $ignore) {
				return $tag;
			} else {
				return ReTidy::mostAncientConflationaryInlineAncestor($tag->parentNode);
			}
		} else {
			return $tag;
		}
	}
	
	protected function mostAncientConflationaryInlineAncestor($tag) {
		if(ReTidy::DOM_isConflationaryWithParentIgnoringWhitespace($tag) && ReTidy::isInline($tag->parentNode)) {
			return ReTidy::mostAncientConflationaryInlineAncestor($tag->parentNode);
		} else {
			return $tag;
		}
	}	
	
	protected function getAllPreviousSiblings($node) {
		$previousSiblings = array();
		$previousSibling = $node->previousSibling;
		while($previousSibling->nodeType) {
			$previousSiblings[] = $previousSibling;
			$previousSibling = $previousSibling->previousSibling;
		}
		return $previousSiblings;
	}
	
	protected function getAllNextSiblings($node) {
		$nextSiblings = array();
		$nextSibling = $node->nextSibling;
		while($nextSibling->nodeType) {
			$nextSiblings[] = $nextSibling;
			$nextSibling = $nextSibling->nextSibling;
		}
		return $nextSiblings;
	}	
	
	protected function hasNoSiblingsIgnoringWhitespace($node) {
		$previousSiblings = ReTidy::getAllPreviousSiblings($node);
		$nextSiblings = ReTidy::getAllNextSiblings($node);
		$siblings = array_merge($previousSiblings, $nextSiblings);
		foreach($siblings as $sibling) {
			if(!ReTidy::isWhitespace($sibling)) {
				return false;
			}
		}
		return true;
	}
	
	function trim_nbsp($string) {
		// &#160; 	&#xa0; 	&nbsp;
		while(true) {
			$initial_string = $string;
			while(strpos($string, "&nbsp;") === 0) {
				$string = substr($string, 6);
			}
			while(strpos(strrev($string), strrev("&nbsp;")) === 0) {
				$string = substr($string, 0, strlen($string) - 6);
			}
			while(strpos($string, "&#160;") === 0) {
				$string = substr($string, 6);
			}
			while(strpos(strrev($string), strrev("&#160;")) === 0) {
				$string = substr($string, 0, strlen($string) - 6);
			}
			while(strpos($string, "&#xa0;") === 0) {
				$string = substr($string, 6);
			}
			while(strpos(strrev($string), strrev("&#xa0;")) === 0) {
				$string = substr($string, 0, strlen($string) - 6);
			}
			while(strpos($string, "&#xA0;") === 0) {
				$string = substr($string, 6);
			}
			while(strpos(strrev($string), strrev("&#xA0;")) === 0) {
				$string = substr($string, 0, strlen($string) - 6);
			}
			/*while(strpos($string, ' ') === 0) { // this is a raw non-breaking space character
				$string = substr($string, 1);
			}
			while(strpos(strrev($string), strrev(' ')) === 0) { // this is a raw non-breaking space character
				$string = substr($string, 0, strlen($string) - 1);
			}*/
			while(strpos($string, chr(194)) === 0) {
				$string = substr($string, 1);
			}
			while(strpos(strrev($string), strrev(chr(194))) === 0) {
				$string = substr($string, 0, strlen($string) - 1);
			}
			while(strpos($string, chr(160)) === 0) {
				$string = substr($string, 1);
			}
			while(strpos(strrev($string), strrev(chr(160))) === 0) {
				$string = substr($string, 0, strlen($string) - 1);
			}
			$string = trim($string);
			if($initial_string !== $string) {
				continue;
			} else {
				return $string;
			}
		}
	}
	
	protected function remove_page_number_references($string) {
		$string = str_replace('&hellip;', '...', $string);
		$string = str_replace('&#x2026;', '...', $string);
		$string = str_replace('&#8230;', '...', $string);
		$string = preg_replace('/\.\s\./is', '..', $string);
		$string = preg_replace('/\s*[\.\-_\*]{2,}((\s*<[^<>]+>)*)\s*[mcdxliv]+\s*([^\w])/is', '$1$3', $string, -1, $count1);
		$string = preg_replace('/\s*[\.\-_\*]{2,}((\s*<[^<>]+>)*)\s*[0-9]+\s*([^\w])/is', '$1$3', $string, -1, $count2);
		$this->logMsgIf('page number references removed', $count1 + $count2);
		//print($string);exit(0);
		return $string;
	}
	
	function trim_page_reference($string) {
		//print('in trim_page_reference');exit(0);
		//$string = '<hhh>      <kkk>   some text ..........***...9      <lelel>     </kkel>'; // for testing
		//print('string: ' . $string);
		$string = str_replace('&hellip;', '...', $string);
		$string = str_replace('&#x2026;', '...', $string);
		$string = str_replace('&#8230;', '...', $string);
		$string = preg_replace('/\.\s\./is', '..', $string);
		preg_match('/((<[^<>]+?>\s*){0,})/is', $string, $opening_debuffered_matches); // notice this line could potential (for very dirty code) reach the regular expressions recursion limit (2012-01-16)
		$opening_tags = $opening_debuffered_matches[1];
		$rev_string = strrev($string);
		//print('rev_string: ');var_dump($rev_string);
		preg_match('/((>[^<>]*?<\s*){0,})/is', $rev_string, $closing_debuffered_matches);
		$rev_closing_tags = $closing_debuffered_matches[1];
		$closing_tags = strrev($rev_closing_tags);
		// ignore tags at the start and end of the string
		//$debuffered_string = $debuffered_matches[3];
		$debuffered_string = substr($string, strlen($opening_tags), strlen($string) - strlen($opening_tags) - strlen($closing_tags));
		$rev_debuffered_string = strrev($debuffered_string);
		//print('opening_tags: ');var_dump($opening_tags);
		//print('reverse closing_tags: ');var_dump($rev_closing_tags);
		//print('debuffered_string: ');var_dump($debuffered_string);
		//$closing_tags = $debuffered_matches[4];
		//$rev_string = strrev($debuffered_string);
		preg_match('/([mcdxliv]*\s*((>[^><]*?<\s*)*)[\.\-_\*]{2,}\s*)|([0-9]+\s*((>[^><]*?<\s*)*)[\.\-_\*]{2,}\s*)/is', $rev_debuffered_string, $page_reference_matches, PREG_OFFSET_CAPTURE);
		//print('page reference matches: ');var_dump($page_reference_matches);
		if(strlen($page_reference_matches[0][0]) > 0 && $page_reference_matches[0][1] === 0) {
			$page_reference = $page_reference_matches[0][0];
			$contentless_page_reference = ReTidy::contentless($page_reference);
			$contentless_page_reference_rev_debuffered = $contentless_page_reference . substr($rev_debuffered_string, strlen($page_reference_matches[0][0]));
			$contentless_page_reference_debuffered = strrev($contentless_page_reference_rev_debuffered);
			//strrev(substr($rev_debuffered_string, strlen($page_reference_matches[0][0])))
			$string = $opening_tags . $contentless_page_reference_debuffered . $closing_tags;
		}
		//print('page reference trimmed string: ' . $string);
		return $string;
	}
	
	protected function haveSameTextContent($node1, $node2) {
		return (ReTidy::trim_nbsp(ReTidy::tagless($node1)) === ReTidy::trim_nbsp(ReTidy::tagless($node2)));
	}
	
	protected function areConflationaryIgnoringWhitespace($node1, $node2) {
		return (ReTidy::isConflationaryDescendantIgnoringWhitespace($node1, $node2) || ReTidy::isConflationaryDescendantIgnoringWhitespace($node2, $node1));
	}
	
	protected function isConflationaryDescendantIgnoringWhitespace($node1, $node2) {
		// node2 inside node1
		$descendants = $this->xpath->query('.//' . ReTidy::get_html_namespace() . '*', $node1);
		$is_descendant = false;
		foreach($descendants as $descendant) {
			if($descendant === $node2) {
				$is_descendant = true;
				break;
			}
		}
		if(!$is_descendant) {
			return false;
		}
		// now check if they are conflationary
		if(trim(ReTidy::tagless($node1)) === trim(ReTidy::tagless($node2))) {
			return true;
		} else {
			return false;
		}
	}
	
	protected function isConflationaryDescendant($node1, $node2) {
		// node2 inside node1
		$descendants = $this->xpath->query('.//' . ReTidy::get_html_namespace() . '*', $node1);
		$is_descendant = false;
		foreach($descendants as $descendant) {
			if($descendant === $node2) {
				$is_descendant = true;
				break;
			}
		}
		if(!$is_descendant) {
			return false;
		}
		// now check if they are conflationary
		if(ReTidy::tagless($node1) === ReTidy::tagless($node2)) {
			return true;
		} else {
			return false;
		}
	}

	protected function DOM_isConflationaryWithParentIgnoringWhitespace($node) {
		return (ReTidy::isFirstChildIgnoringWhitespace($node) && ReTidy::isLastChildIgnoringWhitespace($node));
	}
	
	protected function isConflationaryWithParentIgnoringWhitespace($node) {
		return ReTidy::DOM_isConflationaryWithParentIgnoringWhitespace($node);
	}

	protected function DOM_isConflationaryWithChildIgnoringWhitespace($node) {
		return ReTidy::isConflationaryWithChildIgnoringWhitespace($node);
	}
	
	protected function DOM_isConflationaryWithChildIgnoringSpace($node) {
		return ReTidy::isConflationaryWithChildIgnoringSpace($node);
	}	
	
	protected function isConflationaryWithChildIgnoringWhitespace($node) {
		return (ReTidy::hasOnlyOneChildIgnoringWhitespace($node));
	}

	protected function isConflationaryWithChildIgnoringSpace($node) {
		return (ReTidy::hasOnlyOneChildIgnoringSpace($node));
	}
	
	protected function isFirstChildIgnoringWhitespace($node) {
		$firstChild = $node->parentNode->firstChild;
		while($firstChild && ReTidy::isWhiteSpace($firstChild)) {
			$firstChild = $firstChild->nextSibling;
		}
		if($node === $firstChild) {
			
			return true;
		} else {
			return false;
		}
	}

	protected function isLastChildIgnoringWhitespace($node) {
		$lastChild = $node->parentNode->lastChild;
		while($lastChild && ReTidy::isWhiteSpace($lastChild)) {
			$lastChild = $lastChild->previousSibling;
		}
		if($node === $lastChild) {
			
			return true;
		} else {
			return false;
		}	
	}	

	protected function DOM_block_in_cell() {
		$ArrayOfTagsToBr = array(
		'p',
		'h1',
		'h2',
		'h3',
		'h4',
		'h5',
		'h6',
		'div',
		);
		$stringTags = './/' . ReTidy::get_html_namespace() . implode('|.//' . ReTidy::get_html_namespace(), $ArrayOfTagsToBr);
		$AftText = 'XXX9o9br_me9o9XXX';
		$query = '//' . ReTidy::get_html_namespace() . 'th | //' . ReTidy::get_html_namespace() . 'td';
		$cells = $this->xpath->query($query);
		foreach($cells as $cell) {
			//$query = './/' . ReTidy::get_html_namespace() . 'table';
			//$table_in_cells = $this->xpath->query($query, $cell);
			//foreach($table_in_cells as $table_in_cell) {
				// there should be way to look for descendants but stop looking if a certain descendant (table) is found
				// I do not currently know of it (2009-06-19).
				// the xpath would probably have something like ancestor:: and not() in it.
				//print('<h1 style="color:red;">Table in table cell433574!</h1>');
				//var_dump(ReTidy::DOM_getNodeString($table_in_cell));
				// since we are only currently (2009-08-27) using this in the clean_word profile, we need not worry about old-style webpages
				// using tables in tables for layout.
			//}
			$query = $stringTags;
			$block_in_cells = $this->xpath->query($query, $cell);
			$count_blocks_in_cell = 0;
			foreach($block_in_cells as $block_in_cell) {
				$count_blocks_in_cell++;
			}
			if($count_blocks_in_cell > 1) {
				foreach($block_in_cells as $index => $block_in_cell) {
					$nextElement = ReTidy::nextElement($block_in_cell);
					foreach($ArrayOfTagsToBr as $TagToBr) {
						if($nextElement->nodeName === $TagToBr) {
							$block_in_cell->appendChild(new DOMText($AftText));
							break;
						}
					}
				}
			}
			foreach($block_in_cells as $block_in_cell) {
				ReTidy::applyAttributesWithoutOverwrite($block_in_cell, $cell);
				if($block_in_cell->nodeName[0] === "h") { // then it is a heading (which is bolded by default)
					$block_in_cell->insertBefore(new DOMText("XXX9o9NewTagBeginXXXstrong9o9XXX"), $block_in_cell->firstChild);
					$block_in_cell->appendChild(new DOMText("XXX9o9NewTagEndXXXstrong9o9XXX"));
				}				
				$block_in_cell->setAttribute('stripme', 'y');
				ReTidy::DOM_strip_node($block_in_cell);
			}
		}
		
		// we could determine whether items tagged <p> are in fact proper paragraphs. Perhaps by
		// searching for a capital letter at the start and a period at the end. In this case if we call 
		// such one a proper paragraph then treat is specially? Style it if it is the first or last 
		// child so that it does not add space to the top or bottom of a cell?
		
		return true;
	}

	protected function dom_div_layout_tables () {
		if(!$this->config['styles_or_classes']) {
			print("Whether to use styles or classes in dom_div_layout_tables is unspecified.\r\n");
			return false;
		}
		$query = '//' . ReTidy::get_html_namespace() . 'table';
		$tags = $this->xpath->query($query);	
		if(!$tags || !$tags->length) {
			print("No tables were found...(dom_div_layout_tables)<br>\r\n");		
			return false;	
		}
		foreach($tags as $tag) {
			// assumptions
			$layout_table = false;
			$data_table = false;

			// try to determine if this is a data table
			// we must consider nested tables... so we use the version WithIgnore
			if (rec_DOM_SearchForNodeNameWithIgnore($tag, "th", "table", false) === true) {
				$data_table = true;
				//print("found table header<br>\r\n");				
			}
			if ($data_table == false && rec_DOM_SearchForAttributeWithIgnore($tag, "scope", "table", false) === true) {
				$data_table = true;
				//print("found scope<br>\r\n");				
			}
			if ($data_table == false && rec_DOM_SearchForGoodSummaryWithIgnore($tag, "table", false) === true) {
				$data_table = true;
				//print("found good summary<br>\r\n");				
			}
			/*
			// this cannnot currently handle a nested table...maybe.
			if (!$data_table) {
				$previousSibling = $tag->previousSibling;
				while($previousSibling->nodeType !== 1) {
					$previousSibling = $previousSibling->previousSibling;
				}
				//print("previous_sibling:");var_dump(rec_DOM_getNodeString($previousSibling));print("<br>");
				if ($previousSibling) {
					//$previousSibling = $previous2Sibling;
					if ($previousSibling->nodeName === "p") {
						// looking for an anchor signalling a data table
						if ($previousSibling->hasChildNodes()) {
							foreach ($previousSibling->childNodes as $node4) {
								if ($node4->nodeName === "a") {
									if($node4->hasAttributes()) {
										foreach ($node->attributes as $attribute) {
											if ($attribute->nodeName === "name") {
												$nodeValue = $attribute->nodeValue;
												if(substr($nodeValue, 0, 1) === "t") {
													$data_table = true;
												}
											}
										}
									}
								}
							}	
						}					
						$firstChild = $previousSibling->firstChild;
						//while($firstChild->nodeType != 1) {
						//	$firstChild = $firstChild->nextSibling;
						//}
						//if ($firstChild->nodeName === "strong") {
							// looking for text signalling a data table
							$nodeString = rec_DOM_getNodeString($firstChild);
							//print("$%^" . $nodeString . "$%^");
							if (preg_match("/Table(au)* [0-9]{1,3}/", substr($nodeString, 0, 30))) {
								$data_table = true;
							}
						//}
					} 
				} else {
					print("PreviousSibling not found(p)!");
				}
				if ($previousSibling) {
					//print("PreviousSibling found(h#)!");				
					if ($previousSibling->nodeName === "h1" ||
					$previousSibling->nodeName === "h2" ||
					$previousSibling->nodeName === "h3" ||
					$previousSibling->nodeName === "h4" ||
					$previousSibling->nodeName === "h5" ||
					$previousSibling->nodeName === "h6") {
						// looking for an anchor signalling a data table
						if ($previousSibling->hasChildNodes()) {
							foreach ($previousSibling->childNodes as $node4) {
								if ($node4->nodeName === "a") {
									if($node4->hasAttributes()) {
										foreach ($node->attributes as $attribute) {
											if ($attribute->nodeName === "name") {
												$nodeValue = $attribute->nodeValue;
												if(substr($nodeValue, 0, 1) === "t") {
													$data_table = true;
												}
											}
										}
									}
								}
							}	
						}
						// looking for text signalling a data table
						$nodeString = rec_DOM_getNodeString($previousSibling);
						if (preg_match("/Table(au)* [0-9]{1,3}/", substr($nodeString, 0, 30))) {
							$data_table = true;
						}
					}
				} else {
					print("PreviousSibling not found(h#)!");
				}							
			}
			*/
			//var_dump(!$data_table);print("<br><br>\r\n");
			
			// does not currently properly find cells? to try to find data in.
			//if (!$data_table) {
			//	if(searchForData($tag)) {
			//		$data_table = true;
			//	}
			//}
			// some intelligent way to find an apparent set of number data (or other; harder) 
			// rather than layed out numbers.

			// try to determine if this is a layout table
			// marked by a human
			if (rec_DOM_SearchForAttributeWithValueWithIgnore($tag, "class", "layouttable", "table", "contained", false) === true) {
				$layout_table = true;
				$data_table = false;
				//print("marked by a human<br>\r\n");
			}
			// if it has no numbers
			//if (!$layout_table && rec_DOM_SearchForNumbersWithIgnore($tag, "table", false) === false) {
			//	$layout_table = true;
			//}
			//$layout_table = true;
						
			// now that we have classified it, work on it if necessary
			if ($layout_table && !$data_table) {
				// with CSS2 I believe one can use styles to have <div>s behave as tables.
				// (2008-08-27): CSS2 is not widely adopted so we cannot rely only on this.
				
				//$tag->setAttribute('islayouttable', 'yeah');
				
				/*
				// first try to determine any row or column widths that will need to be applied to all the <div>s 
				// because they are less structured than <table>s.
				// even trickier; try to determine an appropriate width where one does not exist...
				
				// grab all the <th>s and <td>s in a certain column (this is tricky after the first cell in a row)
				$ArrayCells = array();
				$ArrayCells = rec_DOM_GrabCellsWithIgnore($tag, 1, $ArrayCells, "table");
				var_dump($ArrayCells);
				exit(0);
				
				// find the biggest width
				$BiggestWidthFormatPlusWidth = rec_DOM_FindWidth($ArrayCells);
				$BiggestWidth = substr($BiggestWidthFormatPlusWidth, strpos($BiggestWidthFormatPlusWidth, ':'));
				$BiggestWidthFormat = substr($BiggestWidthFormatPlusWidth, 0, strpos($BiggestWidthFormatPlusWidth, ':'));			
							
				// apply the width to all the <th>s and <td>s in the column
				foreach($ArrayCells as $index => $cell) {
					if ($BiggestWidthFormat === "class") {
						$AddClass = true;
						if($cell->hasAttributes()) {
							foreach ($node->attributes as $attribute) {
								if ($attribute->nodeName === "class") {
									$AddClass = false;
									$attribute->nodeValue = $attribute->nodeValue . " $BiggestWidth";
									// consider using style instead of class
								}
							}
						}
						if($AddClass === true) {
							$node->setAttribute('class', '$BiggestWidth');
						}
					}
					if ($BiggestWidthFormat === "style") {
						$AddStyle = true;
						if($cell->hasAttributes()) {
							foreach ($node->attributes as $attribute) {
								if ($attribute->nodeName === "style") {
									$AddStyle = false;
									$attribute->nodeValue = $attribute->nodeValue . "width:$BiggestWidth;";
								}
							}
						}
						if($AddStyle === true) {
							$node->setAttribute('style', 'width:$BiggestWidth;');
						}
					}
					if ($BiggestWidthFormat === "width") {
						$node->setAttribute('width', '$BiggestWidth');
					}				
				}
				*/
				
				
				rec_DOM_DivMeLabelWithIgnore($tag, $this->DOM, "table", $this->config['styles_or_classes']);
			}
		}
	}

	protected function dom_strip_no_attr ()
	{
		if (!$this->dom || !$this->xpath || !is_array($this->config['strip_no_attr']))
			return false;

		$query = '';

		foreach($this->config['strip_no_attr'] as $tag)
		{
			$query .= ' | //' . ReTidy::get_html_namespace() . $tag . '[not(@*)]';
		}

		$query{1} = ' ';
		$query = trim($query);

		$tags = $this->xpath->query($query);
		if(!$tags || !$tags->length)
			return false;

		$this->logMsg("=== strip_no_attr === \nDOM nodes: " . $tags->length);

		$c = array();

		foreach($tags as $tag)
		{
			$nodeName = $tag->nodeName;

			$tag->setAttribute('stripme', 'y');
			ReTidy::DOM_strip_node($tag);

			if(!isset($c[$nodeName]))
				$c[$nodeName] = 0;

			$c[$nodeName]++;
		}

		foreach($c as $nodeName => $c2)
		{
			$this->logMsg("$nodeName : $c2 ");
		}

		return true;
	}

	protected function strip_empty_tags ()
	{
		if(!is_array($this->config['strip_empty_tags']))
			return false;

		$regex = implode('|', $this->config['strip_empty_tags']);
		$regex = '/<(' . $regex . ')[^>]*>(\s*|<br\s*\/?>)*<\/\1>/i';
		$c = 1;
		$ct = 0;
		while($c > 0)
		{
			$this->code = preg_replace($regex, ' ', $this->code, -1, $c);
			$ct += $c;
		}
		$this->logMsgIf("strip_empty_tags", $ct);

		return true;
	}

	protected function clean_inline() {
		ReTidy::clean_ineffective_inline();
		// we may need DOM_clean_extraneous_inline to have been done so that cascading styles on space-ignoring conflationary tags
		// do not get shifted (by OM::try_tag_shifting_combinations) in such a way that the cascading changes.
		ReTidy::extra_styles();
		ReTidy::cleanStyles();
		ReTidy::non_inline_attributes();
		ReTidy::split_inline();
		ReTidy::inline_style_to_tag();

		ReTidy::combine_inline();
		
		//ReTidy::fix_inline();
	}
	
	protected function inline_style_to_tag() {
		$array_replaces = array();
		preg_match_all('/<span\s+style="font\-weight\s*:\s*bold\s*;?">/is', $this->code, $strong_matches, PREG_OFFSET_CAPTURE);
		foreach($strong_matches[0] as $strong_match) {
			$match = $strong_match[0];
			$offset = $strong_match[1];
			$Ostring = OM::getOstring($this->code, '<span', '</span>', $offset);
			$replaceString = "<strong>" . substr($Ostring, strlen($match), strlen($Ostring)-strlen($match)-7) . "</strong>";
			$array_replaces[$Ostring] = $replaceString;
		}
		foreach($array_replaces as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code);
		}
		$array_replaces = array();
		preg_match_all('/<span\s+style="font\-style\s*:\s*italic\s*;?">/is', $this->code, $italic_matches, PREG_OFFSET_CAPTURE);
		foreach($italic_matches[0] as $italic_match) {
			$match = $italic_match[0];
			$offset = $italic_match[1];
			$Ostring = OM::getOstring($this->code, '<span', '</span>', $offset);
			$replaceString = "<em>" . substr($Ostring, strlen($match), strlen($Ostring)-strlen($match)-7) . "</em>";
			$array_replaces[$Ostring] = $replaceString;
		}
		foreach($array_replaces as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code);
		}
	}
	
	protected function non_inline_attributes() {
		// this function removes attributes or parts of attributes that do not belong on inline tags from inline tags.
		$this->code = preg_replace('/<span([^>]*) align="[^"]*"([^>]*)>/is', '<span$1$2>', $this->code);
		$this->code = preg_replace('/<span([^>]*) style="([^"]*)text-align\s*:\s*[^;]*;([^"]*)"([^>]*)>/is', '<span$1 style="$2$3"$4>', $this->code);
	}
	
	protected function fix_inline() {
		$count = 0;
		// mostly because of microsoft word from which the code from converter sometimes, for some reason, does not include the last character
		// in a word in the inline tag.
		// does this work or only cause problems?
		// I find it unlikely that this does very much of use since we would want to use something inherently built
		// upon the DOM since this is what understands the hierarchy of the tags, whereas when working on a string we can 
		// only do this with a limited approximation (which is sometimes sufficient (for example, in simple cases)).
		$entity = DTD::getInline();
		// acronyms, sup (others?) may occur intrawordally.
		$entity = str_replace('|acronym', '', $entity);
		$entity = str_replace('|sup', '', $entity);
		$entity = str_replace('|sub', '', $entity);

		$array_replaces = array(
		'(' . $this->a_letter . ')<\/(' . $entity . ')>(' . $this->a_letter . ')\s*(<\/\w*>)' => '$1$3</$2>$4',
		'(' . $this->a_letter . ')<\/(' . $entity . ')>(' . $this->a_letter . '\s+)<\2>(' . $this->a_letter . ')' => '$1$3$4',
		'(' . $this->a_letter . ')<(' . $entity . ')>((' . $this->a_letter . '){2,})' => '<$2>$1$3',
		);		
		foreach($array_replaces as $search => $replace) {
			preg_match_all('/' . $search . '/is', $this->code, $matches32020);
			foreach($matches32020 as $index => $value) {
				if(sizeof($matches32020[0]) > 0) {
					print("<br>\r\nwhat fix_inline fixed: ");
					var_dump(htmlentities($value[0]));
				}
			}
		}	
		foreach($array_replaces as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $ct);
			$count += $ct;			
		}
		ReTidy::warning_if('fix_inline</span>', $count);
	}

	protected function split_inline() { // split inline tags with many attributes
		// it is worth considering whether to split attributes from blocks also.
		// since inline tags are always in a block it may be unnecessary... because we do not need to worry about combining blocks.
		$array_replacesI = array();
		$entity = DTD::getInline();
		$entity = str_replace('img|', '', $entity); // exclude images...
		$entity = str_replace('br|', '', $entity); // exclude line breaks...
		//print('$entity: ');var_dump($entity);
		$arrayNonDTDInline = array('u', 'b', 'i', 'strike', 'blink');
		$entity .= "|" . implode("|", $arrayNonDTDInline);
		preg_match_all('/<(' . $entity . ')[\s>]/is', $this->code, $inlineMatches, PREG_OFFSET_CAPTURE);
		foreach($inlineMatches[0] as $index => $value) {
			$tagName = $inlineMatches[1][$index][0];
			$offset = $value[1];
			$attributes_string = substr($this->code, $offset+strlen($tagName)+1, strpos($this->code, ">", $offset)-($offset+strlen($tagName)+1));
			$opening_string = '<' . $tagName;
			$opening_string_with_attributes = '<' . $tagName . $attributes_string . '>';
			$closing_string = '</' . $tagName . '>';
			$objectString = OM::getOString($this->code, $opening_string, $closing_string, $offset);
			if($objectString === false) {
				continue;
			}
			foreach($array_replacesI as $index => $value) {
				if($value[0] === $objectString) {
					continue 2;
				}
			}
			preg_match_all('/ [\w:]+="[^"]*"/is', $attributes_string, $attribute_matches);
			if($tagName === "span") {
				$new_opening = '';
				$new_closing = '';
				foreach($attribute_matches[0] as $index2 => $value2) {
					if(strpos($value2, ' style="') === 0) { // in addition to splitting attributes, split the styles in this attribute
						$styles_string = substr($value2, 8, strlen($value2)-9);
						$styles_array = OM::explode_non_nested(";", $styles_string, "{", "}");
						foreach($styles_array as $style) {
							if(strlen($style) > 0) { // for the possible last ; in a style attribute.
								$new_opening .= '<span style="' . ReTidy::cleanStyle($style) . '">';
								$new_closing = '</span>' . $new_closing;
							}
						}					
					} elseif(strpos($value2, ' class="') === 0) { // in addition to splitting attributes, split the classes in this attribute
						$classes_string = trim(substr($value2, 8, strlen($value2)-9));
						$classes_array = explode(" ", $classes_string);
						foreach($classes_array as $class) {
							$new_opening .= '<span class="' . $class . '">';
							$new_closing = '</span>' . $new_closing;
						}
					} else {
						$new_opening .= '<span' . $value2 . '>';
						$new_closing = '</span>' . $new_closing;
					}
				}					
			}
			// exclude <a> tags? except for styling. consider whether this is appropriate for all tags (because this function 
			// may only be used in preparation for combine_inline.
			elseif($tagName === "a") {
				$kept_attributes_string = "";
				$found_styling = false;
				$new_opening = '';
				$new_closing = '';
				foreach($attribute_matches[0] as $index2 => $value2) {
					if(strpos($value2, ' style="') === 0) { // in addition to splitting attributes, split the styles in this attribute
						$found_styling = true;
						$styles_string = substr($value2, 8, strlen($value2)-9);
						$styles_array = OM::explode_non_nested(";", $styles_string, "{", "}");
						foreach($styles_array as $style) {
							if(strlen($style) > 0) { // for the possible last ; in a style attribute.
								$new_opening .= '<span style="' . ReTidy::cleanStyle($style) . '">';
								$new_closing = '</span>' . $new_closing;
							}
						}					
					} elseif(strpos($value2, ' class="') === 0) { // in addition to splitting attributes, split the classes in this attribute
						$found_styling = true;
						$classes_string = trim(substr($value2, 8, strlen($value2)-9));
						$classes_array = explode(" ", $classes_string);
						foreach($classes_array as $class) {
							$new_opening .= '<span class="' . $class . '">';
							$new_closing = '</span>' . $new_closing;
						}
					} else {
						$kept_attributes_string .= $value2;
					}
				}
				if(!$found_styling) {
					continue;
				} else {
					$new_opening = '<' . $tagName . $kept_attributes_string . '>' . $new_opening;
					$new_closing = $new_closing . '</' . $tagName . '>';
				}
			} else {
				$new_opening = '<' . $tagName . '>';
				$new_closing = '</' . $tagName . '>';
				foreach($attribute_matches[0] as $index2 => $value2) {
					if(strpos($value2, ' style="') === 0) { // in addition to splitting attributes, split the styles in this attribute
						$styles_string = substr($value2, 8, strlen($value2)-9);
						$styles_array = OM::explode_non_nested(";", $styles_string, "{", "}");
						foreach($styles_array as $style) {
							if(strlen($style) > 0) { // for the possible last ; in a style attribute.
								$new_opening .= '<span style="' . $style . '">';
								$new_closing = '</span>' . $new_closing;
							}
						}					
					} elseif(strpos($value2, ' class="') === 0) { // in addition to splitting attributes, split the classes in this attribute
						$classes_string = trim(substr($value2, 8, strlen($value2)-9));
						$classes_array = explode(" ", $classes_string);
						foreach($classes_array as $class) {
							$new_opening .= '<span class="' . $class . '">';
							$new_closing = '</span>' . $new_closing;
						}
					} else {
						$new_opening .= '<span' . $value2 . '>';
						$new_closing = '</span>' . $new_closing;
					}
				}					
			}
			$replace_string = $new_opening . substr($objectString, strlen($opening_string_with_attributes), strlen($objectString)-strlen($opening_string_with_attributes)-strlen($closing_string)) . $new_closing;
			$array_replacesI[] = array($objectString, $replace_string);
		}
		usort($array_replacesI, "sortByLengthOfFirst");
		//print('$array_replacesI: ');var_dump($array_replacesI);
		foreach($array_replacesI as $index => $value) {
			$search = $value[0];
			$replace = $value[1];
			$this->code = str_replace($search, $replace, $this->code);
		}
	}
	
	function strpos_all($haystack, $needle, $offset = 0) {
		$pos_array = array();
		$last_pos = $offset;
		while(true) {
			$strpos = strpos($haystack, $needle, $last_pos);
			if($strpos === false) {
				break;
			} else {
				$pos_array[] = $strpos;
				$last_pos = $strpos+1;
			}
		}
		if(sizeof($pos_array) > 0) {
			return $pos_array;
		} else {
			return false;
		}
	}
	
	protected function ensure_proper_quotation_nesting() {
		// currently (2011-12-05) not used; combine_inline is just used
		//$this->code = OM::ensure_proper_nesting($this->code, 'q');
		ReTidy::combine_inline();
	}
	
	protected function combine_inline() {
		$blocks = DTD::getBlock() . '|li|td|th|caption';
		// caption added (2011-10-31)
		//print("blocks: ");var_dump($blocks);
		$entity = DTD::getInline();
		//print("entity: ");var_dump($entity);
		$arrayNonDTDInline = array('u', 'b', 'i', 'strike', 'blink');
		$entity .= "|" . implode("|", $arrayNonDTDInline);
		$entityArray = explode("|", $entity);
		$I2 = 0;
		$I = -1;
		while($I != 0) {
			$I = 0;
			$last_OString = "";
			$last_offset = 0;
			$last_blockString = "";
			$last_containing_block_offset = 0;
			$array_replacesI = array();
			preg_match_all('/<(' . $entity . ')[\s>]/is', $this->code, $inlineMatches, PREG_OFFSET_CAPTURE);
			//$pos_array = ReTidy::strpos_all($this->code, '<div id="XXX9o9TOCdiv9o9XXX">');
			$pos_start_and_ends_array = array();
			//if($pos_array !== false) {
			//	foreach($pos_array as $pos_index => $pos_value) {
			//		$TOC_object_string = OM::getOString($this->code, '<div', '</div>', $pos_value);
			//		$pos_start_and_ends_array[] = array($pos_value, $pos_value + strlen($TOC_object_string));
			//	}
			//}
			foreach($inlineMatches[0] as $index => $value) {
				$tagName = $inlineMatches[1][$index][0];
				//print('$tagName: ' . $tagName . '<br>');
				$offset = $inlineMatches[0][$index][1];
				// combining inline tags in the table of contents that usually has many inline tags in the same block can take
				// a VERY long time; we want to avoid it.
				// not anymore (2011-10-14)
				//if(sizeof($pos_start_and_ends_array) > 0) {
				//	foreach($pos_start_and_ends_array as $pos_start_and_ends_index => $pos_start_and_ends_value) {
				//		$begin_TOC_position = $pos_start_and_ends_value[0];
				//		$end_TOC_position = $pos_start_and_ends_value[1];
				//		if($offset < $end_TOC_position && $offset > $begin_TOC_position) {
				//			continue 2;
				//		}
				//	}
				//}
				$attributes_string = substr($this->code, $offset + strlen($tagName) + 1, strpos($this->code, ">", $offset) - ($offset + strlen($tagName) + 1));
				if($attributes_string[strlen($attributes_string) - 1] == "/") {
					// then it is a self-closing tag
					continue;
				}
				$OString = OM::getOString($this->code, '<' . $tagName, '</' . $tagName . '>', $offset);
				if($OString === false) {
					continue;
				}
				// check if this is nested in the last found inline tag (since the inline tag may disrupt this one when replacing)
				if($offset + strlen($OString) < $last_offset + strlen($last_OString)) {
					continue;
				}
				// we do all this fancy getting the block stuff because tags may not interspan
				$blockArray = OM::getContainingBlockForCombineInline($this->code, $offset, $blocks);
				//print("blockArray: ");var_dump($blockArray);
				$blockString = $blockArray[0];
				if($blockString === false) {
					//print('here0303-3=3=<br>');
					continue;
				}
				if(isset($array_replacesI[$blockString])) {
					//print('here0303-3=4=<br>');
					continue;
				}
				$offset_within_block = $blockArray[1];
				$containing_block_offset = $blockArray[2];
				// check if this is nested in the last blockString (since the blockString may disrupt this one when replacing)
				if($containing_block_offset + strlen($blockString) < $last_containing_block_offset + strlen($last_blockString)) {
					//print('here0303-3=5=<br>');
					continue;
				}
				// if there is nothing to combine
				// this check may be unnecessary because getCombineString checks as it is working.
				// it does seem to speed things up though.
				if(strpos(substr($blockString, $offset_within_block + 1), '<' . $tagName . $attributes_string . '>') === false) {
					//print('here0303-3=6=<br>');
					continue;
				}
				$ignore_expression = $this->spaceOrTag;
				$combineString = OM::getCombineString($blockString, '<' . $tagName . $attributes_string . '>', '</' . $tagName . '>', $offset_within_block, $ignore_expression, $entity, $tagName, $blocks);
				//print('$combineString: ' . $combineString . '<br>');
				if($combineString === false) {
					continue;
				} else {
					$array_replacesI[$blockString] = $combineString;
				}
				$last_OString = $OString;
				$last_offset = $offset;
				$last_blockString = $blockString;
				$last_containing_block_offset = $containing_block_offset;
			}
			//print('$array_replacesI: ');var_dump($array_replacesI);
			foreach($array_replacesI as $search => $replace) {
				$this->code = str_replace($search, $replace, $this->code, $i);
				$I += $i;
			}
			$I2 += $I;
		}
		$this->logMsgIf("combine_inline", $I2);
	}
	
	function trimStyleAgnostic($string) {
		$substr = strrev($string);
		preg_match('/((>[^<>]+<|[' . $this->styleAgnosticCharacters . ']){1,})/is', $substr, $matches, PREG_OFFSET_CAPTURE);
		if($matches[0][1] === 0 && strlen($matches[0][0]) > 0) {
			$substr = strrev(substr($substr, strlen($matches[0][0])));
		} else {
			$substr = strrev($substr);
		}
		preg_match('/((>[^<>]+<|[' . $this->styleAgnosticCharacters . ']){1,})/is', $substr, $matches, PREG_OFFSET_CAPTURE);
		if($matches[0][1] === 0 && strlen($matches[0][0]) > 0) {
			$substr = substr($substr, strlen($matches[0][0]));
		}		
		return $substr;
	}
	
	function isStyleAgnostic($string) {
		if(ReTidy::isNode($string)) {
			$string = ReTidy::DOM_getNodeString($string);
		}
		preg_match('/((<[^<>]+>|[' . $this->styleAgnosticCharacters . ']|' . $this->spaceRegex . '){1,})/is', $string, $matches);
		if(strlen($matches[0]) === strlen($string)) {
			return true;
		}
		return false;
	}
	
	function isSpaceOrTag($var) {
		if(is_string($var)) {
			preg_match('/' . $this->spaceOrTag . '/is', $var, $space_matches);
			if(strlen($space_matches[0]) === strlen($var)) {
				return true;
			}
		}
		if(ReTidy::isNode($var)) {
			return ReTidy::isSpaceOrTag(ReTidy::tagless($var));
		}
		return false;
	}
	
	function isSpace($var) {
		if(is_string($var)) {
			preg_match('/(' . $this->spaceRegex . ')+/s', $var, $space_matches);
			if(strlen($space_matches[0]) === strlen($var)) {
				return true;
			}
		}
		if(ReTidy::isNode($var)) {
			return ReTidy::isSpace(ReTidy::tagless($var));
		}
		return false;
	}	
	
	protected function reorder_tags() {
		if (!is_array($this->config['reorder_tags']))
			return false;

		$c = 0;
		$regex = '(' . implode('|', $this->config['reorder_tags']) . ')';
		$regex = '/<' . $regex . '>([^<>]*)<' . $regex . '>([^<>]*)<\/\3>([^<>]*)<\/\1>([^<>]*)<\3>([^<>]*)<\/\3>/i';
		$this->code = preg_replace($regex, '<$3>$2<$1>$4</$1>$5$6$7</$3>', $this->code, -1, $c);
		$this->logMsgIf("reorder_tags", $c);

		return true;
	}

	protected function combine_br_tags ()
	{
		if (!is_array($this->config['combine_br_tags']))
			return false;

		$c = 0;
		$regex = '/<\/(' . implode('|', $this->config['combine_br_tags']) . ')>(\s+|(\s*<br\s*\/?>\s*)+)?<\1[^>]*>/i';
		$this->code = preg_replace($regex, ' ', $this->code, -1, $c);
		$this->logMsgIf("combine_br_tags", $c);

		return true;
	}

	protected function fix_img_pos ()
	{
		if (!$this->config['fix_img_pos'])
			return false;

		$c = 1;
		$ct = 0;
		while($c > 0)
		{
			$this->code = preg_replace('/>([^<]+)<img\s+([^>]+)>/i', '><img \2>\1', $this->code, -1, $c);
			$ct += $c;
		}
		$this->logMsgIf("fix_img_pos", $ct);

		return true;
	}

	protected function extend_quotes ()
	{
		if(!$this->config['extend_quotes'])
			return false;

		$ct = 0;
		$c = 1;
		$regex = '(\"|\'|&quot;|&#034;|&apos;|&#039;|&lsquo;|&rsquo;)';
		while($c > 0)
		{
			$this->code = preg_replace('/'.$regex.'\s*<([a-z0-9]+)([^>]*)>/i', '<\2\3>\1', $this->code, -1, $c);
			$ct += $c;
		}
		$c = 1;
		while($c > 0)
		{
			$this->code = preg_replace('/<\/([a-z0-9]+)>([\s!\.\?]*)'.$regex.'/i', '\2\3</\1>', $this->code, -1, $c);
			$ct += $c;
		}
		$this->logMsgIf("extend_quotes", $ct);

		return true;
	}

	protected function combine_broken_tags ()
	{
		if(!is_array($this->config['combine_broken_tags']))
			return false;

		$c = 0;
		$regex = '(' . implode('|', $this->config['combine_broken_tags']) . ')';
		$regex = '/([\p{Ll}a-z\d\p{N}])\s*<\/(' . $regex . ')>\s*<\2(\s+[^>]+)?>\s*([\p{Ll}a-z])/u';
		$this->code = preg_replace($regex, '\1 \5', $this->code, -1, $c);
		$this->logMsgIf("combine_broken_tags", $c);

		return true;
	}

	protected function hruler ()
	{
		if(!is_array($this->config['hruler']))
			return false;

		$c = 0;
		$regex = '(' . implode('|', $this->config['hruler']) . ')';
		$regex = '/<' . $regex . '[^>]*>(\s*[\p{P}\p{S}\p{Z}]\s*){3,}<\/\1>/isu';
		$this->code = preg_replace($regex, '<hr />', $this->code, -1, $c);
		$this->logMsg("hruler $c");

		return true;
	}
	
	protected function pre_word() {
		
		// microsoft word change tracking
		//$this->code = preg_replace('/<ins\s/is', '<ins stripme="y" ', $this->code);
		//$this->code = str_replace('<span class=msoIns>', '<span stripme="y">', $this->code);
		ReTidy::non_DOM_deleteme('<style[^>]*? id="dynCom"[^>]*?>');
		ReTidy::non_DOM_deleteme('<script language="JavaScript">');
		ReTidy::non_DOM_stripme('<ins\s[^>]*?>');
		ReTidy::non_DOM_stripme('<span\s+class=msoIns>');
		ReTidy::non_DOM_stripme('<span\s+class=msoDel>');
		$this->code = preg_replace('/<del\s/is', '<del deleteme="y" ', $this->code);
		$this->code = preg_replace('/<div([^<>]*?) class=msocomtxt/is', '<div$1 deleteme="y" ', $this->code);
		$this->code = preg_replace('/<span([^<>]*?)class=MsoCommentReference>/is', '<span$1 deleteme="y">', $this->code);
		$this->code = preg_replace('/<span([^<>]*?)style=\'[^\']*?display\s*:\s*none[^\']*?\'/is', '<span$1 deleteme="y" ', $this->code);
		$this->code = preg_replace('/<span([^<>]*?)style="[^"]*?display\s*:\s*none[^"]*?\"/is', '<span$1 deleteme="y" ', $this->code);
		
		$this->code = preg_replace('/<(w:\w+)[^<>]*?>(.*?)<\/\1>/is', '$2', $this->code); // will cause problems if there are nested tags with w: namespace
		
	//	// microsoft classes to delete
	//	$arrayMicrosoftClassesToDelete = array(
	//	'msoIns',
	//	'msoDel',
	//	);
	//	foreach($arrayMicrosoftClassesToDelete as $microsoftClass) {
	//		while(true) {
	//			$this->code = preg_replace('/class="([^"]*)' . ReTidy::preg_escape($microsoftClass) . '([^"]*)"/is', 'class="$1$2"', $this->code, -1, $countA);
	//			$this->code = str_replace(' class=' . ReTidy::preg_escape($microsoftClass), '', $this->code, $countB);
	//			if($countA === 0 && $countB === 0) {
	//				break;
	//			}				
	//		}
	//	}
		
		//$this->code = preg_replace('/\n/', 'XXX\n', $this->code);
		
		//<tr style='page-break-inside:avoid;height:11.25pt'> 
		//  <span lang=FR-CA style='font-size:9.0pt;font-family:"Times New Roman"; 
		//  color:black;layout-grid-mode:line'> 
		//  <td style='height:11.25pt;border:none' width=0 height=15></td> 
		//  </span> 
		// </tr> 

		// does this do anything?!?
		
		$this->code = str_replace('
', ' 
', $this->code);		
	}

	protected function word_TOC() {	
		$TOCArray = ReTidy::getTOCArray();
		if(sizeof($TOCArray) === 0) {
			return false;
		}
		foreach($TOCArray as $index => $value) {
			$TOC = $value[0];
			$heading_string = $value[1];
			$initial_toc_string = $toc_string = substr($TOC, strlen($heading_string));
			if($this->config["TOC_sub"] === "indent") {
				$arrayReplaces = array(
				'<p class="MsoToc1">' => '<p>',
				'<p class="MsoToc2">' => '<p class="indent1">',
				'<p class="MsoToc3">' => '<p class="indent1">',
				'<p class="MsoToc4">' => '<p>',
				'<p class="MsoToc5">' => '<p>',			
				'<p class="MsoTof">' => '<p>',			
				);
			} else {
				$arrayReplaces = array(
				'<p class="MsoToc1">' => '<p>',
				'<p class="MsoToc2">(.*?)<\/p>' => '<ul><li>$1</li></ul>',
				'<p class="MsoToc3">(.*?)<\/p>' => '<ul><li>$1</li></ul>',
				'<p class="MsoToc4">' => '<p>',
				'<p class="MsoToc5">' => '<p>',			
				'<p class="MsoTof">' => '<p>',
				);
			}
			foreach($arrayReplaces as $search => $replace) {
				$toc_string = preg_replace('/' . $search . '/is', $replace, $toc_string);
			}
			$this->code = str_replace($initial_toc_string, $toc_string, $this->code);
		}
	}
	
	protected function utf8_to_iso_8859_1() {
		// not used since the more generalized convert_to() function was written and sweeper handles character sets better now (2011-08-15).
		$result = preg_match('/<meta http\-equiv="[Cc]ontent\-[Tt]ype" content="text\/html;\s*charset\s*=\s*utf\-8"/is', $this->code, $encoding_matches);
		if($result) {
			$this->code = iconv("UTF-8", "CP1252" . "//TRANSLIT", $this->code);
			$this->code = htmlspecialchars($this->code);
			$this->code = htmlentities($this->code);
			$this->code = htmlspecialchars_decode($this->code);
			$this->code = htmlspecialchars_decode($this->code);
			$this->code = preg_replace('/<meta http\-equiv="[Cc]ontent\-[Tt]ype" content="text\/html;\s*charset\s*=\s*utf\-8"/is', '<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"', $this->code);
		}
	}
	
	protected function find_charset($code = false) {
		if($file === false) { // then check on the file being swept
			$code = $this->code;
		}
		$charset = ReTidy::find_charset_from_XML_tag($code);
		if($charset === false) {
			$charset = ReTidy::find_charset_from_meta_tag($code);
			if($charset === false) {
				$charset = ReTidy::detectCharset($code);
			}
		}
		return $charset;
	}
	
	protected function find_charset_from_XML_tag($code = false) {
		if($code === false) { // then check on the file being swept
			$code = $this->code;
		}
		if(preg_match_all('/<\?xml([^<>?]*?) encoding="([^"]*?)"([^<>?]*?)\?>/is', $code, $XML_matches, PREG_OFFSET_CAPTURE)) {
			$size = sizeof($XML_matches[0]);
			if($size > 1) {
				print("<h1 style=\"color: red;\">Did not find only one &lt;?xml ?&gt; declaration; instead, " . $size . " were found.</h1>\r\n");
				var_dump($XML_matches);exit(0);
			} else {
				$position = $XML_matches[0][0][1];
				if($position > 30) {
					print('<span style="color: red; font-weight: bold;">Found only one &lt;?xml ?&gt; declaration but it was not at the beginning of the document; instead it is at offset: ' . $position . '.</span><br>
');
				} else {
					return $XML_matches[2][0][0];
				}
			}
		}
		return false;
	}
	
	protected function find_charset_from_meta_tag($code = false) {
		if($code === false) { // then check on the file being swept
			$code = $this->code;
		}
		if(preg_match_all('/<meta http\-equiv=[\'"]{0,1}[Cc]ontent\-[Tt]ype[\'"]{0,1} content="text\/html;\s*charset\s*=\s*([^"]*?)\s*"/is', $code, $meta_matches)) {
			$size = sizeof($meta_matches[0]);
			if($size > 1) {
				print('<span style="color: red; font-weight: bold;">Did not find only one &lt;meta&gt; charset declaration; instead, ' . $size . ' were found.</span><br>
');
			} else {
				return $meta_matches[1][0];
			}
		}
		// it seems that in HTML5 a less syntactically complicated way of marking the character set is possible
		if(preg_match_all('/<meta [^<>]*?charset="([^"]*?)"/is', $code, $meta_matches)) {
			$size = sizeof($meta_matches[0]);
			if($size > 1) {
				print('<span style="color: red; font-weight: bold;">Did not find only one (HTML5) &lt;meta&gt; charset declaration; instead, ' . $size . ' were found.</span><br>
');
			} else {
				return $meta_matches[1][0];
			}
		}
		return false;
	}
	
	protected function convert_to($charset) {
		// we are appending //TRANSLIT to the output character set to allow for cases where there is no corresponding character in the output character set 
		// rather than simply stopping processing at a character it cannot convert.
		// revision (2011-08-15): use the XML declaration (if it exists) preferentially over the meta content type tag to determine the encoding
		$declared_charset = ReTidy::find_charset_from_XML_tag();
		if($declared_charset === false) {
			/*$this->code = '<?xml version="1.0" encoding="' . $charset . '"?>
' . $this->code;*/
		} else {
			$this->code = preg_replace('/<\?xml([^<>]*?) version="1.0"([^<>]*?) encoding="[^<>]*?"([^<>]*?)\?>/is', '<?xml$1 version="1.0"$2 encoding="' . $charset . '"$3?>', $this->code);
		}
		if($declared_charset === false) {
			$declared_charset = ReTidy::find_charset_from_meta_tag();
			if($declared_charset === false) {
				// at this point we're pretty desperate; although we shouldn't get here often
				$declared_charset = ReTidy::detectCharset();
				//$declared_charset = "iso-8859-1";
				//$declared_charset = "utf-8";
				if(ReTidy::is_HTML5()) {
					$this->code = preg_replace('/<head([^<>]*?)>/is', '<head$1>
<meta http-equiv="Content-Type" content="text/html; charset=' . $charset . '" />
', $this->code);
				} else {
					$this->code = preg_replace('/<head([^<>]*?)>/is', '<head$1>
<meta charset="' . $charset . '" />
', $this->code);
				}
			}
		}
		$this->code = preg_replace('/<meta http\-equiv=[\'"]{0,1}[Cc]ontent\-[Tt]ype[\'"]{0,1} content="text\/html;\s*charset\s*=\s*[^<>]*?\s*"/is', '<meta http-equiv="Content-Type" content="text/html; charset=' . $charset . '"', $this->code);
		$this->code = preg_replace('/<meta charset="[^"]*?"/is', '<meta charset="' . $charset . '"', $this->code);
		$temp_code = $this->code;
		$this->code = iconv($declared_charset, $charset . "//TRANSLIT", $this->code);
		if($this->code === false) {
			$this->code = mb_convert_encoding($temp_code, $charset, $declared_charset);
			if(strlen($this->code) === 0) {
				//print('$this->code5.5: ');var_dump($this->code);
				print('<span style="color: red;">Failed to convert from ' . $declared_charset . ' to ' . $charset . '.</span>');exit(0);
			}
		}
		//$this->code = $temp_code;
		//print('$this->code6: ');var_dump($this->code);
		//ReTidy::updateEncoding($charset);
	}
	
	protected function convert_to_utf8() {
		ReTidy::convert_to("utf-8");
	}
	
	protected function convert_to_iso_8859_1() {
		ReTidy::convert_to("iso-8859-1");
	}
	
	function clean_word_sections() {
		$this->code = preg_replace('/<div class="wordsection[0-9]+">/is', '<div stripme="y">', $this->code);
		ReTidy::post_dom();
	}
	
	protected function clean_indesign() {
		//print('$this->code: ' . $this->code);exit(0);
		$array_rxp = array(
		
		// page number references in the table of contents
		'<span class="toc-leader-dots[^"]*?">\s*<\/span>\s*[0-9ivxlcdmIVXLCDM]{1,}\s*<\/p>' => '</p>',
		
		'<p([^>]*?) class="h1"([^>]*?)>(.*?)<\/p>' => '<h1\1\2>\3</h1>',
		'<p([^>]*?) class="h2"([^>]*?)>(.*?)<\/p>' => '<h2\1\2>\3</h2>',
		'<p([^>]*?) class="h3"([^>]*?)>(.*?)<\/p>' => '<h3\1\2>\3</h3>',
		'<p([^>]*?) class="h4"([^>]*?)>(.*?)<\/p>' => '<h4\1\2>\3</h4>',
		'<p([^>]*?) class="h5"([^>]*?)>(.*?)<\/p>' => '<h5\1\2>\3</h5>',
		'<p([^>]*?) class="h6"([^>]*?)>(.*?)<\/p>' => '<h6\1\2>\3</h6>',
		
		'<p([^>]*?) class="head-1"([^>]*?)>(.*?)<\/p>' => '<h1\1\2>\3</h1>',
		'<p([^>]*?) class="head-2"([^>]*?)>(.*?)<\/p>' => '<h2\1\2>\3</h2>',
		'<p([^>]*?) class="head-3"([^>]*?)>(.*?)<\/p>' => '<h3\1\2>\3</h3>',
		'<p([^>]*?) class="head-4"([^>]*?)>(.*?)<\/p>' => '<h4\1\2>\3</h4>',
		'<p([^>]*?) class="head-5"([^>]*?)>(.*?)<\/p>' => '<h5\1\2>\3</h5>',
		'<p([^>]*?) class="head-6"([^>]*?)>(.*?)<\/p>' => '<h6\1\2>\3</h6>',
		
		//'<p([^>]*?) class="h1"([^>]*?)>(.*?)<\/p>' => '<h1\1\2>\3</h1>',
		'<p([^>]*?) class="section-heading"([^>]*?)>(.*?)<\/p>' => '<h2\1\2>\3</h2>',
		'<p([^>]*?) class="heading"([^>]*?)>(.*?)<\/p>' => '<h3\1\2>\3</h3>',
		'<p([^>]*?) class="subheading"([^>]*?)>(.*?)<\/p>' => '<h4\1\2>\3</h4>',
		//'<p([^>]*?) class="h5"([^>]*?)>(.*?)<\/p>' => '<h5\1\2>\3</h5>',
		//'<p([^>]*?) class="h6"([^>]*?)>(.*?)<\/p>' => '<h6\1\2>\3</h6>',
		
		'<p([^>]*?) class="toc-toc-main-section[^"]{0,}"([^>]*?)>(.*?)<\/p>' => '<li\1\2>\3</li>',
		'<p([^>]*?) class="toc-toc-heading[^"]{0,}"([^>]*?)>(.*?)<\/p>' => '<li\1\2>\3</li>',
		'<p([^>]*?) class="toc-toc-subsection[^"]{0,}"([^>]*?)>(.*?)<\/p>' => '<li\1\2>\3</li>',
		
		'<span([^>]*?) class="em"([^>]*?)>(.*?)<\/span>' => '<em\1\2>\3</em>',
		'<span([^>]*?) class="strong"([^>]*?)>(.*?)<\/span>' => '<strong\1\2>\3</strong>',
		'<span([^>]*?) class="em-strong"([^>]*?)>(.*?)<\/span>' => '<strong\1\2><em>\3</em></strong>',
		
		'<span([^>]*?) class="italic"([^>]*?)>(.*?)<\/span>' => '<em\1\2>\3</em>',
		'<span([^>]*?) class="bold"([^>]*?)>(.*?)<\/span>' => '<strong\1\2>\3</strong>',
		'<span([^>]*?) class="italic-bold"([^>]*?)>(.*?)<\/span>' => '<strong\1\2><em>\3</em></strong>',
		
		'<span([^>]*?) class="italic-body"([^>]*?)>(.*?)<\/span>' => '<em\1\2>\3</em>',
		'<span([^>]*?) class="bold-bocy"([^>]*?)>(.*?)<\/span>' => '<strong\1\2>\3</strong>',
		'<span([^>]*?) class="bold-body"([^>]*?)>(.*?)<\/span>' => '<strong\1\2>\3</strong>',		
		'<span([^>]*?) class="bold-italic"([^>]*?)>(.*?)<\/span>' => '<strong\1\2><em>\3</em></strong>',
		
		'<p([^>]*?) class="callout-heads"([^>]*?)>(.*?)<\/p>' => '<p><strong\1\2>\3</strong></p>',
		'<p([^>]*?) class="figure-head"([^>]*?)>(.*?)<\/p>' => '<p><strong\1\2>\3</strong></p>',
		
		//'<body>(.*?)<div id="([^"]*?)">' => '<body>\1<div stripme="y">',
		);
		
		$count = 0;
		foreach($array_rxp as $search => $replace) {
			//print('here385489960940<br>');
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $c);
			$count += $c;
		}
		
		$array_rep = array(
		//' class="story"' => ' stripme="y"',
		' class="toc-leader-dots"' => ' deleteme="y"',
		' class="toc-page-numbers"' => ' deleteme="y"',
		);
		
		foreach($array_rep as $search => $replace) {
			//print('here385489960941<br>');
			$this->code = str_replace($search, $replace, $this->code, $c);
			$count += $c;
		}
		
		ReTidy::non_DOM_stripme('<\w+(.*?) class="story"(.*?)>');
		ReTidy::non_DOM_stripme('<div id="([^"]*?)">');
		
		// Delete any classes in <li> tags?
		//var_dump($count);
		$this->logMsgIf('clean_indesign', $count);
	}
	
	protected function non_DOM_stripme($opening_tag_string) {
		// the opening tag string may be a regular expression
		preg_match_all('/' . $opening_tag_string . '/is', $this->code, $matches, PREG_OFFSET_CAPTURE);
		$size = sizeof($matches[0]) - 1;
		while($size > -1) {
			//print("matches[0][size][0]: ");var_dump($matches[0][$size][0]);
			preg_match('/<(\w+)/is', $matches[0][$size][0], $tagname_matches);
			$tagname = $tagname_matches[1];
			$OString = OM::getOString($this->code, '<' . $tagname, '</' . $tagname . '>', $matches[0][$size][1]);
			//print("strlen(matches[0][size][0]): ");var_dump(strlen($matches[0][$size][0]));
			$substr = substr($OString, strlen($matches[0][$size][0]), strlen($OString) - strlen($matches[0][$size][0]) - (strlen($tagname) + 3));
			//print("OString: ");var_dump($OString);
			//print("substr: ");var_dump($substr);
			//$this->code = str_replace($OString, $substr, $this->code);
			$this->code = substr($this->code, 0, $matches[0][$size][1]) . $substr . substr($this->code, $matches[0][$size][1] + strlen($OString));
			$size--;
		}
	}
	
	protected function non_DOM_deleteme($opening_tag_string) {
		// the opening tag string may be a regular expression
		preg_match_all('/' . $opening_tag_string . '/is', $this->code, $matches, PREG_OFFSET_CAPTURE);
		$size = sizeof($matches[0]) - 1;
		while($size > -1) {
			preg_match('/<(\w+)/is', $matches[0][$size][0], $tagname_matches);
			$tagname = $tagname_matches[1];
			$OString = OM::getOString($this->code, '<' . $tagname, '</' . $tagname . '>', $matches[0][$size][1]);
			$this->code = substr($this->code, 0, $matches[0][$size][1]) . substr($this->code, $matches[0][$size][1] + strlen($OString));
			$size--;
		}
	}
	
	protected function double_breaks_to_paragraphs() {
		$blockString = DTD::getBlock() . '|li|td|th|caption';
		$blockString = str_replace('p|', '', $blockString);
		//var_dump($blockString);exit(0);
		// this will probably limit this function's effect to <p> tags
		$blockArray = explode("|", $blockString);
		// ok, call all <br><br> not in lists or tables new paragraphs
		preg_match_all('/<br[^<>]*?>\s*<br[^<>]*?>/is', $this->code, $double_break_matches, PREG_OFFSET_CAPTURE);
		$size_minus_one = sizeof($double_break_matches[0]) - 1;
		while($size_minus_one > -1) {
			$double_break = $double_break_matches[0][$size_minus_one][0];
			$offset = $double_break_matches[0][$size_minus_one][1];
			$ancestryArray = OM::getAncestryArray($this->code, $offset);
			$do_the_replace = false;
			// we have to at least find a <p>
			foreach($ancestryArray as $ancestor) {
				$ancestorTagName = $ancestor[0];
				if($ancestorTagName === "p") {
					$do_the_replace = true;
				}
			}
			foreach($ancestryArray as $ancestor) {
				$ancestorTagName = $ancestor[0];
				foreach($blockArray as $block) {
					if($ancestorTagName === $block) {
						$do_the_replace = false;
						break;
					}
				}
			}
			if($do_the_replace) {
				$this->code = substr($this->code, 0, $offset) . '</p>
<p>' . substr($this->code, $offset + strlen($double_break));
			}
			$size_minus_one--;
		}
		return true;
	}
	
	function pre_PDF() {
		// #l6> li:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
		preg_match('/<style[^<>]{0,}>(.*?)<\/style>/is', $this->code, $matches);
		$initial_style_code = $style_code = $matches[1];
		$style_code = preg_replace('/[^\r\n>]+>[^\r\n>\{]+\{[^\{\}]+\}/is', '', $style_code);
		$this->code = str_replace($initial_style_code, $style_code, $this->code);
		$this->code = preg_replace('/<p[^<>]{0,}><br[^<>]{0,}\/><\/p>/is', '', $this->code);
	}
	
	function clean_PDF() {
		/*$this->code = str_replace(' xml:lang="EN-GB"', '', $this->code);
		$this->code = str_replace(' xml:lang="EN-CA"', '', $this->code);
		$this->code = str_replace(' xml:lang="EN-US"', '', $this->code);*/
		$this->code = str_replace('font-style: normal;', '', $this->code);
		$this->code = str_replace('text-decoration: none;', '', $this->code);
		$this->code = str_replace('overflow: visible;', '', $this->code);
		$this->code = preg_replace('/border-\w+-[^\:]+:[^;]+;/is', '', $this->code);
		$this->code = preg_replace('/padding-[^\:]+:[^;]+;/is', '', $this->code);
		$this->code = preg_replace('/text-indent:[^;]+;/is', '', $this->code);
		$this->code = preg_replace('/line-height:[^;]+;/is', '', $this->code);
		$this->code = preg_replace('/display:[^;]+;/is', '', $this->code);
		//$this->code = str_replace('text-align: left;', '', $this->code);
		// hyphenated words...
		$this->code = preg_replace('/(\w)- (\w)/is', '$1$2', $this->code);
		// footnotes
		$footnotes_code = '<hr>
';
		preg_match_all('/(<p[^<>]{0,}>.{0,100}?<img[^<>]+height="1".*?<\/p>)\s{0,}(<p[^<>]{0,}>.*?<\/p>)/is', $this->code, $footnote_matches);
		//print('$footnote_matches: ');var_dump($footnote_matches);
		// <p class=Default><a href="#_ftnref1" name="_ftn1" title="">[1]</a>  <i>R. v. Bentley</i>, 2017 ONCA 982</p>
		foreach($footnote_matches[0] as $footnote_index => $footnote_match) {
			$footnote_code = $footnote_matches[2][$footnote_index];
			$footnote_code = ReTidy::preg_replace_first('/<a name="bookmark[0-9]+">\s{0,}([0-9]+)\s{0,}<\/a>/is', '<a href="#_ftnref$1" name="_ftn$1" title="">[$1]</a>', $footnote_code); // so that clean_word recognizes it
			$footnotes_code .= $footnote_code . '
';
			$this->code = str_replace($footnote_matches[0][$footnote_index], '', $this->code);
		}
		$this->code = str_replace('</body>', $footnotes_code . '</body>', $this->code);
		// <a href="#bookmark0" class="s6">1</a>
		// <a href="#_ftn1" name="_ftnref1" title=""><span class=MsoFootnoteReference><span class=MsoFootnoteReference><span lang=EN-GB style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>[1]</span></span></span></a>
		$this->code = preg_replace('/<a href="#bookmark[0-9]+"[^<>]{0,}>([0-9]+)<\/a>/is', '<a href="#_ftn$1" name="_ftnref$1" title="">[$1]</a>', $this->code);
		// strip <p>s in <li>s; loop this since lists can be nested
		$closing_p_count = -1;
		while($closing_p_count != 0) {
			$this->code = preg_replace('/(<li[^<>]{0,}>.*?)<\/p>([^<>]*?<\/li>)/is', '$1$2', $this->code, -1, $closing_p_count);
		}
		$opening_p_count = -1;
		while($opening_p_count != 0) {
			$this->code = preg_replace('/(<li[^<>]{0,}>[^<>]*?)<p[^<>]{0,}>(.*?<\/li>)/is', '$1$2', $this->code, -1, $opening_p_count);
		}
		// would be simple if this code was ready
		/*
		if(!include_once('..' . DS . 'LOM' . DS . 'O.php')) {
			print('<a href="https://www.phpclasses.org/package/10594-PHP-Extract-information-from-XML-documents.html">LOM</a> is required');exit(0);
		}
		$O = new O($this->code);
		$lis = $O->_('li');
		print('$lis: ');var_dump($lis);*/
		
		ReTidy::style_cdata();
	
		ReTidy::dom_init();
		ReTidy::DOM_stylesheets_to_styles();
		ReTidy::dom_save();

	//	ReTidy::post_dom();
		
	}
	
	function clean_excel() {
		//ReTidy::warning_once('what to do about input being in .xml format when sweeper doesn\'t work on .xml files?');
		//ReTidy::fatal_error('LOM takes too long...');
		// probably do stuff that regex can do well with regex (strip tags, strip attributes)
		// what if a tag with certain tag name is nested within one with the same tagname?
		// also have to get abbreviations completely working again; MGERC annual report is a good document for this
		// working from the file created by save excel as HTML (.mht, .mhtml) probably works equally well but working with XML is arguably more interesting
		// probably rare, but text that is too light to be intended to be seen (instead it's intended for things like spacing)
		// we could compare to <Interior ss:Color="#D9D9D9" ss:Pattern="Solid"/> in <Style> if needed
		// <Font html:Color="#D9D9D9">jjjj</Font>
		preg_match_all('/<Font html:Color="#([^"]+)">([^<>]+)<\/Font>/is', $this->code, $matches);
		foreach($matches[0] as $index => $value) {
			$color_code = $matches[1][$index];
			$red = hexdec(substr($color_code, 0, 2));
			$green = hexdec(substr($color_code, 2, 2));
			$blue = hexdec(substr($color_code, 4, 2));
			if($red > 208 && $green > 208 && $blue > 208) {
				$this->code = str_replace($value, '', $this->code);
			}
		}
		
		preg_match_all('/<(' . $this->tagname_regex . ')/is', $this->code, $tagname_matches);
		$tagnames = array_unique($tagname_matches[1]);
		foreach($tagnames as $index => $tagname) {
			if($tagname === 'Style' || $tagname === 'Styles' || $tagname === 'Font' || $tagname === 'Alignment' || $tagname === 'NumberFormat' || $tagname === 'Cell' || $tagname === 'Row'
			 || $tagname === 'B' || $tagname === 'I') { // stuff we want to keep for the moment
				continue;
			}
			$this->code = preg_replace('/<' . $tagname . '([^\w\-:][^<>]{0,}\/>|\/>)/is', '', $this->code); // self-closing tags
			$this->code = preg_replace('/<' . $tagname . '([^\w\-:][^<>]{0,}>|>)(.*?)<\/' . $tagname . '>/is', '$2', $this->code);
		}
		//return;
		//$this->code = str_replace('<Data', '<p', $this->code);
		//$this->code = str_replace('</Data', '</p', $this->code);
		//return;
		// whitespace
		
		// have to apply styles from ss:StyleID
		// <Cell ss:StyleID="s103">Augmentation des avantages sociaux futurs</Cell>
		if(!include('..' . DS . 'LOM' . DS . 'O.php')) {
			print('<a href="https://www.phpclasses.org/package/10594-PHP-Extract-information-from-XML-documents.html">LOM</a> is required');exit(0);
		}
		$O = new O($this->code);
		$styles = $O->_('Styles');
		//print('$styles: ');var_dump($styles);
		$cells = $O->get_tagged('Cell');
		//print('$cells: ');var_dump($cells);
		$counter = sizeof($cells) - 1;
		while($counter > -1) {
		//foreach($cells as $cell) {
			$cell = $cells[$counter];
			if(strlen($O->tagless($cell)) === 0) {
				//print('$cell, $O->code before delete: ');$O->var_dump_full($cell, $O->code);
				//print('$cell before delete: ');$O->var_dump_full($cell);
				$O->delete($cell);
				//print('$O->code after delete: ');$O->var_dump_full($O->code);
				//continue;
			} else {
				
				//print('$cell before: ');var_dump($cell);
				// <Cell ss:StyleID="s231"   <Style ss:ID="s311">
				$cell_style = $O->_('Style@ss:ID=' . $O->get_attribute_value('ss:StyleID', $cell), $styles);
				//print('$cell_style: ');var_dump($cell_style);
				$cell_number_format = $O->_('NumberFormat', $cell_style);
				$new_cell_datum = $cell_datum = $O->tagless($cell);
				//print('$cell_datum, $cell_number_format: ');var_dump($cell_datum, $cell_number_format);
				if(sizeof($cell_number_format) > 0 && strlen($cell_datum) > 0) {
					//$cell = $O->set($O->LOM_index_from_offset($cell[1] + strpos($cell[0], '>') + 1), ReTidy::format_excel_number($cell_datum, $O->get_attribute('ss:Format', $cell_number_format)));
					//$cell = $O->set($cell[1] + strpos($cell[0], '>') + 1, ReTidy::format_excel_number($cell_datum, $O->get_attribute('ss:Format', $cell_number_format)));
					$new_cell_datum = ReTidy::format_excel_number($new_cell_datum, $O->get_attribute('ss:Format', $cell_number_format));
					$new_cell_datum = preg_replace('/\( ([0-9])/is', '($1', $new_cell_datum);
					$new_cell_datum = preg_replace('/([0-9]) \)/is', '$1)', $new_cell_datum);
				}
				//print('$new_cell_datum after formatting number: ');var_dump($new_cell_datum);
				// <Alignment ss:Horizontal="Right" ss:Vertical="Center"/>
				$cell_alignment = $O->_('Alignment', $cell_style);
				//print('$cell_alignment: ');var_dump($cell_alignment);
				if(sizeof($cell_alignment) > 0) {
					$horizontal_alignment = strtolower($O->get_attribute('ss:Horizontal', $cell_alignment));
					if(strlen($horizontal_alignment) > 0) {
						$cell = $O->add_attribute('align', $horizontal_alignment, $cell);
					}
					$vertical_alignment = strtolower($O->get_attribute('ss:Vertical', $cell_alignment));
					if(strlen($vertical_alignment) > 0) {
						$cell = $O->add_attribute('valign', $vertical_alignment, $cell);
					}
				}
				$font_tag = $O->_('Font', $cell_style);
				if($O->get_attribute('ss:Italic', $font_tag) == 1) { // excel seems to use binary 0 or 1 for the attribute value
					$new_cell_datum = '<em>' . $new_cell_datum;
					$new_cell_datum = $new_cell_datum . '</em>';
				}
				if($O->get_attribute('ss:Bold', $font_tag) == 1) { // excel seems to use binary 0 or 1 for the attribute value
					$new_cell_datum = '<strong>' . $new_cell_datum;
					$new_cell_datum = $new_cell_datum . '</strong>';
				}
				//print('$O->get_attribute_value($cell, \'ss:StyleID\'), $cell_style, $font_tag, $cell_number_format, $new_cell_datum: ');var_dump($O->get_attribute_value('ss:StyleID', $cell), $cell_style, $font_tag, $cell_number_format, $new_cell_datum);
				if($new_cell_datum != $cell_datum) {
					//$cell = $O->set($cell[1], $new_cell_datum);
					$O->code = substr($O->code, 0, $cell[1]) . substr($cell[0], 0, strpos($cell[0], '>') + 1) . $new_cell_datum . '</Cell>' . substr($O->code, $cell[1] + strlen($cell[0]));
				}
				//print('$cell after set: ');var_dump($cell);
				// <NumberFormat ss:Format="#\ ###\ ##0\ ;\(#\ ###\ ##0\);\-\ \ "/>
				
				//if($cell_datum === '-22317') { // debug
				//	print('strpos($this->code, \'(22 317)\'): ');var_dump(strpos($this->code, '(22 317)'));break;exit(0);
				//}
				//print('$cell after styling: ');var_dump($cell);
				
			}
			$counter--;
		}
		$this->code = $O->tostring($O->LOM);
		
		//return;
		
		foreach(array('Style', 'Styles', 'Alignment', 'NumberFormat') as $index => $tagname) {
			$this->code = preg_replace('/<' . $tagname . '([^\w\-:][^<>]{0,}\/>|\/>)/is', '', $this->code); // self-closing tags
			$this->code = preg_replace('/<' . $tagname . '([^\w\-:][^<>]{0,}>|>)(.*?)<\/' . $tagname . '>/is', '$2', $this->code);
		}
		//foreach(array('StyleID', 'Index', 'Formula') as $attribute_to_strip) {
		//	$this->code = preg_replace('/ ss:' . $attribute_to_strip . '="[^"]+"/is', '', $this->code);
		//}
		$this->code = preg_replace('/<Row>(.*?)<\/Row>/is', '', $this->code);
		//return;
		// as for getting HTML tables out; that would be the work
		// MergeDown? MergeAcross? ss:Italic, ss:Bold etc.
		$O = new O($this->code);
		//$styles = $O->_('Style');
		//print('$styles: ');var_dump($styles);
		$rows = $O->_('Row');
		//print('$rows: ');$O->var_dump_full($rows);
		//print('$rows[2][0]: ');$O->var_dump_full($rows[2][0]);
		$counter = sizeof($rows) - 1;
		$biggest_MergeAcross = -1;
		while($counter > -1) {
			if(strpos($rows[$counter][0], '<Row>') !== false) { // these define dimensions or something; see above
		//		$O->delete($rows[$counter]);
			} else {
				$MergeAcross = $O->get_attribute('ss:MergeAcross', $O->get_tagged('Cell', $rows[$counter]));
				if($MergeAcross > $biggest_MergeAcross) {
					$biggest_MergeAcross = $MergeAcross;
				}
			}
			$counter--;
		}
		$in_a_table = false;
		$counter = sizeof($rows) - 1;
		while($counter > -1) {
		//	if(strpos($rows[$counter][0], '<Row>') !== false) { // these define dimensions or something; see above
		//		$O->delete($rows[$counter]);
		//	} else {
				$cells = $O->_('Cell', $rows[$counter]);
				//print('$in_a_table: ');var_dump($in_a_table);
				//print('$cells: ');$O->var_dump_full($cells);
				//print('$only_one_cell_with_data_in_this_row: ');var_dump($only_one_cell_with_data_in_this_row);
				//if($only_one_cell_with_data_in_this_row) {
				$MergeAcross = $O->get_attribute('ss:MergeAcross', $O->get_tagged('Cell', $rows[$counter]));
				//print('$cells, is_string($cells), $in_a_table, $O->get_tagged(\'Cell\', $rows[$counter]), $O->get_attribute(\'ss:MergeAcross\', $O->get_tagged(\'Cell\', $rows[$counter])): ');var_dump($cells, is_string($cells), $in_a_table, $O->get_tagged('Cell', $rows[$counter]), $O->get_attribute('ss:MergeAcross', $O->get_tagged('Cell', $rows[$counter])));
				if($in_a_table) {
					if(is_string($cells)) {
						if($MergeAcross === false || $MergeAcross === NULL || $MergeAcross > $biggest_MergeAcross - 2) {
							$O->delete($rows[$counter]);
							if($counter === 0) {
								
							} else {
								$O->new_('<table border="1" cellpadding="4" cellspacing="0">', $rows[$counter - 1]);
							}
							$in_a_table = false;
							$new_paragraph = '<p>' . $cells . '</p>';
							//$new_paragraph = $cells;
							//print('changing row to paragraph: ');var_dump($rows[$counter], $new_paragraph);exit(0);
							if($counter === 0) {
								
							} else {
								$O->new_($new_paragraph, $rows[$counter - 1]);
							}
						}
					} elseif(sizeof($cells) === 1) {
						if($MergeAcross === false || $MergeAcross === NULL || $MergeAcross > $biggest_MergeAcross - 2) {
							$O->delete($rows[$counter]);
							if($counter === 0) {
								
							} else {
								$O->new_('<table border="1" cellpadding="4" cellspacing="0">', $rows[$counter - 1]);
							}
							$in_a_table = false;
							$inner_code = substr($cells[0][0], strpos($cells[0][0], '>') + 1, ReTidy::strpos_last($cells[0][0], '<') - strpos($cells[0][0], '>') - 1);
							//print('$inner_code: ');var_dump($inner_code);
							$new_paragraph = '<p>' . $inner_code . '</p>';
							if($counter === 0) {
								
							} else {
								$O->new_($new_paragraph, $rows[$counter - 1]);
							}
						}
						//$tagless_cell_with_data_in_this_row = $O->tagless($cell_with_data_in_this_row);
						//print('$tagless_cell_with_data_in_this_row: ');var_dump($tagless_cell_with_data_in_this_row);
						//if(strlen($tagless_cell_with_data_in_this_row) === 0) {
					}
				} else {
					if(sizeof($cells) > 1) {
						if($counter === sizeof($rows) - 1) {
							$O->new_('</table>', $rows[$counter][1] + strlen($rows[$counter][0]));
						} else {
							$O->new_('</table>', $rows[$counter][1]);
						}
						$in_a_table = true;
					} elseif(is_string($cells)) {
						$O->delete($rows[$counter]);
						$new_paragraph = '<p>' . $cells . '</p>';
						if($counter === 0) {
							
						} else {
							$O->new_($new_paragraph, $rows[$counter - 1]);
						}
					} elseif(sizeof($cells) === 1) {
						$O->delete($rows[$counter]);
						$inner_code = substr($cells[0][0], strpos($cells[0][0], '>') + 1, ReTidy::strpos_last($cells[0][0], '<') - strpos($cells[0][0], '>') - 1);
						$new_paragraph = '<p>' . $inner_code . '</p>';
						if($counter === 0) {
							
						} else {
							$O->new_($new_paragraph, $rows[$counter - 1]);
						}
					} 
				}
		//	}
			$counter--;
		}
		//if($in_a_table) {
		//	$O->new_('<table border="1" cellpadding="4" cellspacing="0">', strpos($O->code, '<'));
		//}
		$this->code = $O->tostring($O->LOM);
		foreach(array('Font') as $index => $tagname) {
			$this->code = preg_replace('/<' . $tagname . '([^\w\-:][^<>]{0,}\/>|\/>)/is', '', $this->code); // self-closing tags
			$this->code = preg_replace('/<' . $tagname . '([^\w\-:][^<>]{0,}>|>)(.*?)<\/' . $tagname . '>/is', '$2', $this->code);
		}
		$this->code = str_replace('<Row', '<tr', $this->code);
		$this->code = str_replace('</Row>', '</tr>', $this->code);
		$this->code = str_replace('<Cell', '<td', $this->code);
		$this->code = str_replace('</Cell>', '</td>', $this->code);
		$this->code = preg_replace('/\s{2,}/is', ' ', $this->code);
		$this->code = str_replace('> <', '>
<', $this->code);
		$this->code = str_replace('</p><p>', '</p>
<p>', $this->code);
		$this->code = str_replace('&#10;', '<br>', $this->code);
		$this->code = preg_replace('/ ss:' . $this->attributename_regex . '="[^"]+"/is', '', $this->code);
		$this->code = preg_replace('/<\?[^<>\?]+\?>/is', '', $this->code); // programming instructions
		// ugly hack
		$this->code = substr($this->code, strpos($this->code, '<')); // stuff before the first tag
		$this->code = substr($this->code, 0, ReTidy::strpos_last($this->code, '>')); // stuff after the last tag
		if($in_a_table) {
			$this->code = '<html><head><title><title></head><body><table border="1" cellpadding="4" cellspacing="0">' . $this->code . '</body></html>';
		} else {
			$this->code = '<html><head><title><title></head><body>' . $new_paragraph . $this->code . '</body></html>';	
		}
		$this->code = str_replace('<table border="1" cellpadding="4" cellspacing="0"><tr>
</tr>
</table><p>', '<p>', $this->code); // pretty ugly
		$this->code = str_replace('<tr>
</tr>
</table><p>', '<p>', $this->code); // pretty ugly
		$this->code = str_replace('</p><table border="1" cellpadding="4" cellspacing="0"><p>', '</p>
<p>', $this->code); // pretty ugly
		// cell alignment
		preg_match_all('/<td[^<>]{0,}>(.*?)<\/td>/is', $this->code, $data_cell_matches);
		foreach($data_cell_matches[0] as $index => $value) {
			if(ReTidy::isNumberDatum(ReTidy::tagless($data_cell_matches[1][$index]))) {
				$this->code = str_replace($value, str_replace('<td', '<td align="right"', $value), $this->code);
			}
		}
		// keep the last one
		$this->code = preg_replace('/<(\w+)( align="[^"]+")([^<>]+)( align="[^"]+")([^<>]{0,})>/is', '<$1$3$4$5>', $this->code);
		$this->code = str_replace('</table><tr>
</tr>
<tr>
</tr></body>', '</table>
</body>', $this->code); // pretty ugly
		$this->code = str_replace('</p><tr>
</tr>', '</p>', $this->code); // pretty ugly
		$this->code = str_replace('<tr>
</tr>
<p>', '<p>', $this->code); // pretty ugly
		
	}
	
	function format_excel_number($number, $format) {
		print('$number, $format at the start of format_excel_number: ');var_dump($number, $format);
		if(!is_numeric($number)) {
			return $number;
		}
		$format = str_replace('&quot;', '', $format);
		/*if() {
			$format = str_replace('_', '', $format);
			$format = str_replace(')', '', $format);
		}*/
		if(strpos($number, '.') !== false && strpos($format, '.') !== false) {
			while(strlen($number) - strpos($number, '.') < strlen($format) - strpos($format, '.')) {
				$number .= 0;
			}
			while(strlen($number) - strpos($number, '.') > strlen($format) - strpos($format, '.')) {
				$number = substr($number, 0, strlen($number) - 1);
			}
		} elseif(strpos($number, '.') === false) {
			$zeroes = '';
			$zeroes_to_add = strlen($format) - strpos($format, '.') - 1;
			while($zeroes_to_add > 0) {
				$zeroes .= '0';
				$zeroes_to_add--;
			}
			$number .= '.' . $zeroes;
		}
		/*
		_-* #,##0.00_-;\-* #,##0.00_-;_-* &quot;-&quot;??_-;_-@_-
		#,##0;\(#,##0\)
		#,###\ ;\(#,###\);\-\ 
		#,###\ ;\(#,###\);\-\ 
		1000	#,###\ ;\(#,###\);\-\ 	1,000
		-1545	#\ ###\ ##0\ ;\(#\ ###\ ##0\);\-\ \ 	( 1 545)
		-21975	#,###\ ;\(#,###\);\-\ 	(21 975)
		*/
		if(strpos($format, ';') === false) {
			$positive_number_format = $format;
			$negative_number_format = $format;
			$zero_number_format = $format;
		} else {
			$exploded_format = explode(';', $format);
			$positive_number_format = $exploded_format[0];
			if(isset($exploded_format[1])) {
				$negative_number_format = $exploded_format[1];
			} else {
				$negative_number_format = $exploded_format[0];
			}
			if(isset($exploded_format[2])) {
				$zero_number_format = $exploded_format[2];
			} else {
				$zero_number_format = $exploded_format[0];
			}
			if(isset($exploded_format[3])) {
				$text_format = $exploded_format[3];
			}
		}
		if($number == 0) {
			return str_replace('\\', '', $zero_number_format);
		} elseif($number < 0) {
			//$negative_number_format = str_replace('\\', '', $negative_number_format);
			$reversed_format = strrev($negative_number_format);
			$number = str_replace('-', '', $number);
		} else {
			//$positive_number_format = str_replace('\\', '', $positive_number_format);
			$reversed_format = strrev($positive_number_format);
		}
		$reversed_number = strrev($number);
		$number_counter = 0;
		$format_counter = 0;
		$formatted_number = '';
		print('$reversed_number, $reversed_format: ');var_dump($reversed_number, $reversed_format);
		while($number_counter < strlen($reversed_number) || $format_counter < strlen($reversed_format)) {
			print('$number_counter, $format_counter: ');var_dump($number_counter, $format_counter);
			if($number_counter > 100 || $format_counter > 100) { // debug
				print('$number, $format, $formatted_number: ');var_dump($number, $format, $formatted_number);exit(0);
			}
			if($reversed_format[$format_counter] === '0') {
				if(isset($reversed_number[$number_counter])) {
					$formatted_number = $reversed_number[$number_counter] . $formatted_number;
				} else {
					$formatted_number = '0' . $formatted_number;
				}
				$number_counter++;
			} elseif($reversed_format[$format_counter] === '#') {
				if(isset($reversed_number[$number_counter])) {
					$formatted_number = $reversed_number[$number_counter] . $formatted_number;
				}
				$number_counter++;
				// due to broken excel number formats
				//print('$reversed_format, substr($reversed_format, $format_counter): ');var_dump($reversed_format, substr($reversed_format, $format_counter));
				if(strpos(substr($reversed_format, $format_counter + 1), '#') === false) {
					while($number_counter < strlen($reversed_number)) {
						$formatted_number = $reversed_number[$number_counter] . $formatted_number;
						$number_counter++;
						/*$format_counter++;
						if($format_counter === strlen($reversed_format)) {
							break 2;
						}*/
					}
				}
			} elseif($reversed_format[$format_counter] === '.') {
				$formatted_number = '.' . $formatted_number;
				$number_counter++;
			} elseif($reversed_format[$format_counter] === '$') {
				$formatted_number = '$' . $formatted_number;
			} elseif($reversed_format[$format_counter + 1] === '\\') {
				$formatted_number = $reversed_format[$format_counter] . $formatted_number;
				$format_counter++;
			} else {
				if(isset($reversed_number[$number_counter])) {
					$formatted_number = $reversed_format[$format_counter] . $formatted_number;
				}
			}
			$format_counter++;
		}
		print('$formatted_number at the end of format_excel_number: ');var_dump($formatted_number);
		return $formatted_number;
	}
	
	protected function clean_word() {

		// first appearance (2012-01-17); word text boxes
		preg_match_all('/<img[^<>]*? alt="Text Box:\s*([^"]*?)"[^<>]*?>/is', $this->code, $text_box_matches, PREG_OFFSET_CAPTURE);
		$counter = sizeof($text_box_matches[0]) - 1;
		while($counter > -1) {
			$offset = $text_box_matches[0][$counter][1];
			$text = $text_box_matches[1][$counter][0];
			$text = '<p>' . str_replace('&#13;&#10;', '</p>
<p>', $text) . '</p>';
			$this->code = substr($this->code, 0, $offset) . $text . substr($this->code, $offset + strlen($text_box_matches[0][$counter][0]));
			$counter--;
		}
		
		// although at least firefox seems smart enough to not display them, 
		// some versions of word may use soft hyphens for print layout or some such nonsense
		// is this a candidate for general (basic) usage?
		$this->code = str_replace('&shy;', '', $this->code);
		// this needs revision for array("­", "&#173;", "&#xad;", "&shy;"); and the fact that soft hyphens are misused by document authors (specific case: they show in RTF files but not in firefox)
		
		ReTidy::decode_for_DOM_all_character_entities(); // since much of the clean_word work is removing styles
		
		// should we simply eliminate all names and ids (since the structure function will generate those which are needed)?
		// seems we should except for footnotes: _ftnref _ftn _ednref _edn
		$this->code = preg_replace('/ id="([^_][^"]*?|_[^fe][^"]*?|_f[^t][^"]*?|_e[^d][^"]*?|_ft[^n][^"]*?|_ed[^n][^"]*?)"/is', '', $this->code);
		$this->code = preg_replace('/(<a[^<>]*?) name="([^_][^"]*?|_[^fe][^"]*?|_f[^t][^"]*?|_e[^d][^"]*?|_ft[^n][^"]*?|_ed[^n][^"]*?)"([^<>]*?>)/is', '$1$3', $this->code);
		
		
		// often in word documents the lang attributes are wrong... so:
		$this->code = preg_replace('/ lang="EN[^"]*"/', '', $this->code);
		$this->code = preg_replace('/ xml:lang="EN[^"]*"/', '', $this->code);
		$this->code = preg_replace('/ lang="FR[^"]*"/', '', $this->code);
		$this->code = preg_replace('/ xml:lang="FR[^"]*"/', '', $this->code);
		
		// white background
		$this->code = preg_replace('/ class="([^"]*)whiteBG([^"]*)"/is', ' class="$1$2"', $this->code);
		// parks canada specific:
		$this->code = preg_replace('/ class="([^"]*)backTop([^"]*)"/is', ' class="$1alignRight$2"', $this->code);		
		
		// topPage; these should not exist (since documents in their original format shall not have links to the top)
		// but they sometimes come from styles to classes. On tags other than spans they style the alignment.
		$this->code = preg_replace('/<span([^>]*)class="([^"]*)topPage([^"]*)"/is', '<span$1class="$2$3"', $this->code);
		
		// word document section <div>s
		//$this->code = preg_replace('/<div style="page\s*:\s*[^;]+;">/is', '<div stripme="y">', $this->code);
		ReTidy::non_DOM_stripme('<div style="page\s*:\s*[^;]+;">');
		
		// remove style information declarations(?) or qualifications(?) like !msnorm and !important? 
		// Nah, there is no need until word is seen to use !important (it could also be in government stylesheets so there is the remote chance that we
		// would like to keep it). Definately get rid of !msnorm though.
		$arrayStyleInformationPiecesToDelete = array(
		'!msorm',
		);
		foreach($arrayStyleInformationPiecesToDelete as $styleInformationPieceToDelete) {
			$styleInformationPieceToDeleteCount = -1;
			while($styleInformationPieceToDeleteCount != 0) {
				$this->code = preg_replace('/style="([^"]*?)' . $styleInformationPieceToDelete . '([^"]*?)"/is', 'style="$1$2"', $this->code, -1, $styleInformationPieceToDeleteCount);
			}
		}
		
		// blockquote
		preg_match_all('/<p[^<>]*style=[^<>]*(margin-right\s*:\s*([^;\'"]*)[;\'"])[^<>]*(margin-left\s*:\s*([^;\'"]*)[;\'"])[^<>]*>(.*?)<\/p>/is', $this->code, $p_matches2);
		foreach($p_matches2[0] as $index => $value) {
			preg_match('/([0-9\.]*)in/', $p_matches2[2][$index], $margin_right_matches);
			preg_match('/([0-9\.]*)in/', $p_matches2[4][$index], $margin_left_matches);
			if($margin_right_matches[1] > 0.4 && $margin_left_matches[1] > 0.4) {
				$original = $new = $p_matches2[0][$index];
				$new = str_replace($p_matches2[1][$index], '', $new);
				$new = str_replace($p_matches2[3][$index], '', $new);
				$new = str_replace('<p', '<div', $new);
				$new = str_replace('</p>', '</div>', $new);
				$new = "<blockquote>" . $new . "</blockquote>";
				$this->code = str_replace($original, $new, $this->code);
			}
		}
		
		// onmouseover, onmouseout; attributes to delete
		$arrayAttributesToDelete = array(
		'onmouseover',
		'onmouseout',
		);
		foreach($arrayAttributesToDelete as $attributeToDelete) {
			$this->code = preg_replace('/' . $attributeToDelete . '="([^"]*)"/is', '', $this->code);
		}
		
		// microsoft styles to delete
		$arrayMicrosoftStylesToDelete = array(
		'page-break-before',
		'page-break-after',
		'page-break-inside',
		'text-autospace',
		'text-transform',		
		//'border',
		'border-left', // (2011-11-07)
		'border-right', // (2011-11-07)
		'border-bottom', // (2011-11-07)
		'border-top', // (2011-11-07)
		'border-collapse',
		'margin', //// notice that we may in some cases want to keep margins (as an indication of indentation)
		'margin-left', ////
		'margin-right', ////
		'margin-top', ////
		'margin-bottom', ////							
		'padding',
		'padding-left',
		'padding-right',
		'padding-top',
		'padding-bottom',
		'font',
		'font-size', //// notice that we may in some cases want to keep font-size
		'font-family',
		//'font-style', // font-style: italic;
		//'text-decoration', // text-decoration: underline;
		'line-height',
		'layout-grid-mode',
		'page',
		'text-indent', //// notice that we may in some cases want to keep text-indent
		'font-variant', //// this may have to be amended in the future (if some document uses small caps without capitalizing those first letters that need to be capitalized)
		'mso-style-name',
		'mso-style-link',
		'z-index',
		'position',
		// we cannot enable the following and keep other style information that these are substrings of
		'top',
		'right',
		'bottom',
		'left',
		'letter-spacing',
		);
		// for this we assume that there are no embedded stylesheets
		foreach($arrayMicrosoftStylesToDelete as $microsoftStyle) {
			while(true) {
				$this->code = preg_replace('/style="([^"]*)' . ReTidy::preg_escape($microsoftStyle) . '\s*:\s*[^;"]*;\s*([^"]*)"/is', 'style="$1$2"', $this->code, -1, $countA);
				$this->code = preg_replace('/style="([^"]*)' . ReTidy::preg_escape($microsoftStyle) . '\s*:\s*[^;"]*"/is', 'style="$1"', $this->code, -1, $countB);
				if($countA === 0 && $countB === 0) {
					break;
				}				
			}
		}
		
		if($this->config['strict_accessibility_level'] > 0) { // then just make it grey
			while(true) {
				$this->code = preg_replace('/style="([^"]*)' . ReTidy::preg_escape('color') . '\s*:\s*[^;"]*;\s*([^"]*)"/is', 'style="$1$2"', $this->code, -1, $countA);
				$this->code = preg_replace('/style="([^"]*)' . ReTidy::preg_escape('color') . '\s*:\s*[^;"]*"/is', 'style="$1"', $this->code, -1, $countB);
				if($countA === 0 && $countB === 0) {
					break;
				}				
			}
		}
		
		$arrayMicrosoftStylesWithValuesToDelete = array(
		//'color' => array('black', 'windowtext'), // these can sometimes override other colours that we keep so ideally we would like to keep these in but style attributes for colour...
		'text-align' => array('justify'),
		'font-weight' => array('normal', 'normal !msorm', 'normal !msnorm'), 
		// we take this out although it can usefully cascade other styles
		// which brings up the point that these all probably can... ;(
		//'font-variant' => array('normal', 'normal!important', 'normal !important', 'small-caps'),
		'background' => array('white', '#FFFFFF'),
		'background-color' => array('white', '#FFFFFF'),
		);
		foreach($arrayMicrosoftStylesWithValuesToDelete as $style => $value) {
			foreach($value as $information) {
				while(true) {
					$this->code = preg_replace('/style="([^"]*)' . ReTidy::preg_escape($style) . '\s*:\s*' . ReTidy::preg_escape($information) . ';\s*([^"]*)"/is', 'style="$1$2"', $this->code, -1, $countC);
					$this->code = preg_replace('/style="([^"]*)' . ReTidy::preg_escape($style) . '\s*:\s*' . ReTidy::preg_escape($information) . '"/is', 'style="$1"', $this->code, -1, $countD);
					if($countC === 0 && $countD === 0) {
						break;
					}
				}
			}
		}
		
		$arrayMicrosoftStylesWithValuesOnTagsToDelete = array(
		'text-align' => array('left' => array('p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'),),
		'font-weight' => array('bold' => array('h1', 'h2', 'h3', 'h4', 'h5', 'h6'),),
		'vertical-align' => array( 
		// we should be careful here not to remove any styles that might be used to identify footnotes; although
		// I do not know of any that are currently (2011-11-28) used
		'baseline' => array('span'),
		'sub' => array('span'),
		'super' => array('span'),
		'top' => array('span'),
		'text-top' => array('span'),
		'middle' => array('span'),
		'bottom' => array('span'),
		'text-bottom' => array('span'),
		'inherit' => array('span'),
		),

		);
		foreach($arrayMicrosoftStylesWithValuesOnTagsToDelete as $property => $stylings) {
			foreach($stylings as $styling => $tags) {
				$tagsString = implode("|", $tags);
				while(true) {
					$this->code = preg_replace('/<(' . $tagsString . ')([^<>]*) style="([^"]*)' . ReTidy::preg_escape($property) . '\s*:\s*' . ReTidy::preg_escape($styling) . ';\s*([^"]*)"/is', '<$1$2 style="$3$4"', $this->code, -1, $countE);
					$this->code = preg_replace('/<(' . $tagsString . ')([^<>]*) style="([^"]*)' . ReTidy::preg_escape($property) . '\s*:\s*' . ReTidy::preg_escape($styling) . '"/is', '<$1$2 style="$3"', $this->code, -1, $countF);
					if($countE === 0 && $countF === 0) {
						break;
					}
				}
			}
		}
		
		// pseudo-elements
		// <a style=":visited { color: purple; }">
		$countE = -1;
		while($countE !== 0) {
			//print("doing pseudo-elements<br>\r\n");
			$this->code = preg_replace('/style="([^"]{0,}):\w+\s*\{[^\{\}]{0,}\}([^"]*)"/is', 'style="$1$2"', $this->code, -1, $countE);			
		}
		
		// <hr> with width
		$this->code = preg_replace('/<hr([^<>]*) width="[^"]*"([^<>]*)\/>/is', '<hr$1$2/>', $this->code);
		
		// microsoft using operating system independant CSS...
		// I guess for this we assume that we are using windows.
		$this->code = preg_replace('/style="([^"]*)border\s*:\s*solid\s+windowtext\s+1.0pt\s*(;?)([^"]*)"/is', 'style="$1border: 1px solid black$2$3"', $this->code);
		
		// superscript using CSS
		//$this->code = preg_replace('/(<(\w*)[^<>]* style="[^"]*)vertical-align: super\s*(;?)([^"]*"[^<>]*>.*?<\/\2>)/is', '<sup>$1$4</sup>', $this->code, -1, $countC);
		$this->code = preg_replace('/<(\w+[^<>]* style="[^"]*)vertical-align: super\s*(;?[^"]*"[^<>]*)>/is', '<$1$2 newtag="sup">', $this->code);
		
		// clean up stupidity generated by tidy
		$this->code = preg_replace('/<div([^<>]*?) start="[^"]*?"([^<>]*?)>/is', '<div$1$2>', $this->code);
		$this->code = preg_replace('/<div([^<>]*?) type="[^"]*?"([^<>]*?)>/is', '<div$1$2>', $this->code);
		
		ReTidy::post_dom();
		// remove empty <a> tags; aside from general cleanup, to avoid the regular expression recursion limit of 100 (for the ridiculous
		// case of something like that many anchors at the same spot...
		//$this->code = str_replace('<a></a>', '', $this->code);
		$this->code = preg_replace('/<a>([^<>]*?)<\/a>/is', '$1', $this->code);
	//	ReTidy::extra_space();
		
		// lists where each list element has a <ul>
		if(ReTidy::is_XHTML()) {
			$this->code = preg_replace('/<\/li>\s*<\/ul>\s*<ul( [^<>]*)?>/is', '<br /><br /></li>', $this->code);
		} else {
			$this->code = preg_replace('/<\/li>\s*<\/ul>\s*<ul( [^<>]*)?>/is', '<br><br></li>', $this->code);
		}
		
		// empty text blocks; notice that we would not want to do this generally
		$this->code = preg_replace('/<(p|h1|h2|h3|h4|h5|h6|li)( [^<>]*){0,1}>&nbsp;<\/\1>/is', '', $this->code);
		// some sort of full-width break from word that we do not want
		$this->code = preg_replace('/<br [^<>]*clear\s*=\s*["\']*all["\']*[^<>]*\/>/is', '', $this->code);
		// force a border onto tables because word html uses border on cells rather than on the table
		$this->code = preg_replace('/<table([^<>]*) border="0"/is', '<table$1 border="1"', $this->code);
		// despan anchors
		preg_match_all('/(<a ([^<>]*)[^\/<>]>)(.*?)(<\/a>)/is', $this->code, $anchor_matches);
		foreach($anchor_matches[0] as $index => $value) {
			if(strpos($anchor_matches[2][$index], "href=") === false) {
				if(strpos($anchor_matches[2][$index], "name=") !== false || strpos($anchor_matches[2][$index], "id=") !== false) {
					$this->code = str_replace($anchor_matches[1][$index] . $anchor_matches[3][$index] . $anchor_matches[4][$index], $anchor_matches[1][$index] . $anchor_matches[4][$index] . $anchor_matches[3][$index], $this->code);
				}
			}
		}
		
		// simplify lists that unnecessarily have a list for each list item
		preg_match_all('/<ol([^<>]*?)>(.*?)<\/ol>/is', $this->code, $ol_matches, PREG_OFFSET_CAPTURE);
		$size = sizeof($ol_matches[0]) - 1;
		while($size > -1) {
			preg_match('/ start="([^"]*?)"/is', $ol_matches[0][$size][0], $start_matches);
			preg_match('/ type="([^"]*?)"/is', $ol_matches[0][$size][0], $type_matches);
			$start = $start_matches[1];
			$type = $type_matches[1];
			$combine_string = "";
			while(true) {
				$end_of_previous_offset = $ol_matches[0][$size - 1][1] + strlen($ol_matches[0][$size - 1][0]);
				$end_of_current_offset = $ol_matches[0][$size][1] + strlen($ol_matches[0][$size][0]);
				$combine_string = substr($this->code, $end_of_previous_offset, $end_of_current_offset - $end_of_previous_offset) . $combine_string;
				preg_match('/ type="([^"]*?)"/is', $ol_matches[0][$size - 1][0], $type_matches2);
				$type2 = $type_matches2[1];
				if($type !== $type2) {
					break;
				}
				preg_match('/ start="([^"]*?)"/is', $ol_matches[0][$size - 1][0], $start_matches2);
				$start2 = $start_matches2[1];
				if(!is_numeric($start2) || $start2 >= $start) {
					break;
				}
				ReTidy::preg_match_last('/<[^<>]+>/is', substr($this->code, 0, $ol_matches[0][$size][1]), $last_tag_piece_matches);
				if($last_tag_piece_matches[0] !== "</ol>") {
					break;
				}
				$start = $start2;
				$size--;
			}
			$cleaned_combine_string = $combine_string;
			$cleaned_combine_string = preg_replace('/<\/ol>\s*<ol[^<>]*?>/is', '', $cleaned_combine_string);
			$this->code = str_replace($combine_string, $cleaned_combine_string, $this->code);
			$size--;
		}
		
		ReTidy::clean_redundant_sufficient_inline();
		ReTidy::double_breaks_to_paragraphs();
		ReTidy::encode_for_DOM_all_character_entities(); // re-encode character entities that were decoded at the start of this function
		//$this->code = preg_replace('/(&nbsp;|&#160;|&#xA0;){3,}/is', '&nbsp;&nbsp;', $this->code); // added 2015-06-04
		ReTidy::mitigate_consecutive_non_breaking_spaces(); // plz
	}
	
	protected function mitigate_consecutive_non_breaking_spaces() {
		$offset = 0;
		$new_code = '';
		$parsing_non_breaking_spaces = false;
		$non_breaking_space_counter = 0;
		$non_breaking_spaces_string = '';
		while($offset < strlen($this->code)) {
			if(substr($this->code, $offset, 6) === '&nbsp;' || substr($this->code, $offset, 6) === '&#160;' || substr($this->code, $offset, 6) === '&#xA0;' || substr($this->code, $offset, 6) === '&#xa0;') {
				$parsing_non_breaking_spaces = true;
				$non_breaking_spaces_string .= '&#160;';
				$offset += 6;
				$non_breaking_space_counter++;
				continue;
			} elseif($parsing_non_breaking_spaces) {
				$parsing_non_breaking_spaces = false;
				if($non_breaking_space_counter > 1) {
					$new_code .= '&#160;';
				} else {
					$new_code .= $non_breaking_spaces_string;
				}
				$non_breaking_spaces_string = '';
			}
			$new_code .= $this->code[$offset];
			$offset++;
		}
		$this->code = $new_code;
	}
	
	protected function clean_redundant_sufficient_inline() {
		// combine_inline really should be able to handle this sort of thing... there is something to be said for the fact that we would not want to do this generally; only when cleaning a file generated by a 
		// dirty generator (word). the point is it cannot be done on <span>s since they are not inherently sufficient for a sort of styling (and perhaps that is why this was overlooked).
		// notice also that this only treats simple cases (tags without attributes) of which there may be a fair number.
		// this array is ordered so that tag names that are substrings of other tag names are done last (b)
		$sufficient_inlines = array('big', 'small', 'em', 'strong', 'sub', 'sup', 'strike', 'blink', 'i', 'b', 'u');
		foreach($sufficient_inlines as $sufficient_inline) {
			$opening_part = '<' . $sufficient_inline;
			$closing_part = '</' . $sufficient_inline . '>';
			$strlen_opening_part = strlen($opening_part);
			$strlen_closing_part = strlen($closing_part);
			$OStrings = OM::getAllOstrings($this->code, $opening_part, $closing_part);
			$index = sizeof($OStrings) - 1;
			while($index > -1) {
				$OString = $OStrings[$index][0];
				//print('$OString: ');var_dump($OString);
				if($OString[strlen($opening_part)] !== ' ' && $OString[strlen($opening_part)] !== '>') { // then we are catching the wrong tag
					//print('wrong $OString: ');var_dump($OString);
				} else {
					$offset = $OStrings[$index][1];
					$initial_substr = $substr = substr($OString, $strlen_opening_part, strlen($OString) - $strlen_opening_part - $strlen_closing_part);
					$substr = str_replace('<' . $sufficient_inline . '>', '', $substr, $count1);
					$substr = str_replace($closing_part, '', $substr, $count2);
					if($count1 > 0 || $count2 > 0 && $count1 === $count2) {
						$cleaned_OString = $opening_part . $substr . $closing_part;
						//$this->code = substr($this->code, 0, $offset) . $cleaned_OString . substr($this->code, $offset + strlen($OString));
						$this->code = str_replace($OString, $cleaned_OString, $this->code);
					}
				}
				$index--;
			}
		}
	}
	
	protected function get_order_indicator_of_list($list_string) {
		// notice that this function does not add the space or period onto the order indicator
		preg_match('/ type="([^"]*?)"/is', $list_string, $type_match);
		preg_match('/ start="([^"]*?)"/is', $list_string, $start_match);
		$type = $type_match[1];
		$start = $start_match[1];
		if($type === "1") {
			return $start;
		} elseif($type === "A") {
			return ReTidy::decimal_to_alphabetical($start);
		} elseif($type === "a") {
			return strtolower(ReTidy::decimal_to_alphabetical($start));
		} elseif($type === "I") {
			return ReTidy::decimal_to_roman_numeral($start);
		} elseif($type === "i") {
			return strtolower(ReTidy::decimal_to_roman_numeral($start));
		} else {
			print("<span style=\"color: red;\"> should never get here (get_order_indicator_of_list) 238384905484749</span><br>\r\n");
			print("list_string: ");var_dump($list_string);
			print("type: ");var_dump($type);
			print("start: ");var_dump($start);
		}
	}
	
	protected function delete_empty_styles($string) {
		$arrayRxp = array(
		'([^"]*?)(\s*;\s*){2,}' => '$1; ',
		);
		foreach($arrayRxp as $search => $replace) {
			$string = preg_replace('/' . $search . '/is', $replace, $string);
		}
		return $string;
	}

	protected function delete_all_empty_styles() {
		$count = $c = 0;
		$arrayRxp = array(
		'style="(\s*;\s*)+([^"]*)"' => 'style="$2"',
		'style="([^"]*?)(\s*;\s*){2,}"' => 'style="$1;"',
		'style="([^"]*?)(\s*;\s*){2,}([^"]*)"' => 'style="$1; $3"',
		);
		foreach($arrayRxp as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $c);
			$count += $c;
		}
		$this->logMsgIf("delete_all_empty_styles", $count);
	}
	
	protected function extra_space() {
		$nbsp_string = '&#xA0;|&#160;|&nbsp;|' . html_entity_decode('&nbsp;');
		//$nbsp_and_space_string = '&#xA0;|&#160;|&nbsp;|' . html_entity_decode('&nbsp;') . '|\s';
		//$this->code = str_replace('<p>&nbsp;</p>', '', $this->code);
		$this->code = preg_replace('/<(p|h[1-6])[^<>]*?>(' . $this->spaceRegex . ')+<\/\1>/is', '', $this->code);
		$blockString = $blockString2 = DTD::getBlock() . "|tr|th|td|li";
		$count = $c = 0;
		
		$arrayRxp = array(
		
		// many consequent non-breaking spaces
		'(' . $this->spaceRegex . '){1,}\s' => ' ',
		'\s(' . $this->spaceRegex . '){1,}' => ' ',
		// sentence double-spacing to single-spacing
		'([\.:;\'+=!?\(\)\{\}\[\]])(' . $nbsp_string . ')\s{1,}([A-Z])' => '$1 $3',
		
		// this needs work
		// extra space at the ends of block tags
		
		
		//$this->code = preg_replace('/<((' . $blockString . ')( [^<>]*){0,1})>(.*?)(' . $this->spaceRegex . ')+(<[^<>]*>)*<\/\2>/is', '<$1>$4$6</$2>', $this->code);
		// this version should work for tags with attributes.
		'(' . $this->spaceRegex . ')+(' . $nbsp_string . ')' => '$2',
		'(&#xA0;|&#160;|&nbsp;)(' . $this->spaceRegex . ')+' => '$2',
		'([^>]\s*)(' . $this->spaceRegex . ')+((\s*<\/\w*>)*)<\/(' . $blockString . ')>' => '$1$3</$5>',
		'(<\/\w*>\s*)(' . $this->spaceRegex . ')+(\s*)<\/(' . $blockString . ')>' => '$1$3</$4>',
		
		//$this->code = preg_replace('/<(' . $blockString . ')>(.*?)(' . $this->spaceRegex . ')+(<[^<>]*>)*<\/\1>/is', '<$1>$2$4</$1>', $this->code);
		'<(' . $blockString2 . ')(\s[^<>]+){0,1}>\s*(<[^<>]+>\s*?)(' . $this->spaceRegex . ')+([^<])' => '<$1$2>$3$5',
		'<(' . $blockString2 . ')(\s[^<>]+){0,1}>\s*(' . $this->spaceRegex . ')+([^<])' => '<$1$2>$4',
		//$this->code = preg_replace('/<((' . $blockString . ')( [^<>]*){0,1})>(.*?)(' . $this->spaceRegex . ')+(<[^<>]*>)*<\/\2>/is', '<$1>$4$6</$2>', $this->code);	
		
		// extra line breaks at the ends of table cells
		'(<br\s*\/>\s*)+<\/(th|td)>' => '</$2>',
		
		);
		foreach($arrayRxp as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $c);
			$count += $c;
		}
		$this->logMsgIf("extra_space", $count);
	}
	
	protected function DOM_double_quotes_in_attributes() {
		// double quotes in attributes...
		$query = '//@*';
		$attributes = $this->xpath->query($query);
		foreach($attributes as $attribute) {
			if(strpos($attribute->nodeValue, '"') !== false) {
				$attribute->nodeValue = str_replace('"', '\'', $attribute->nodeValue);
			}
		}
	}
	
	protected function DOM_primalize_anchors() {
		// put anchors at the beginning of their block
		$blockString = DTD::getBlock() . "|tr|th|td|li";
		$blockString2 = "|" . $blockString;
		$blockString2 = str_replace('|', '|//' . ReTidy::get_html_namespace(), $blockString2);
		$blockString2 = substr($blockString2, 1);
		$query = $blockString2;
		$blocks = $this->xpath->query($query);
		foreach($blocks as $block) {
			$firstChild = $block->firstChild;
			$as = $this->xpath->query(ReTidy::get_html_namespace() . 'a[@name]', $block);
			if(sizeof($as) > 0) {
				foreach($as as $a) {
					// ignore footnotes
					$name_attribute = ReTidy::getAttribute($a, "name");
					if(strpos($name_attribute->nodeValue, "note") !== false || strpos($name_attribute->nodeValue, "_ftnref") !== false) {
						continue;
					}
					if($a != $firstChild) {
						$new_node = $a->cloneNode(true);
						$a->setAttribute("stripme", "y");
						ReTidy::DOM_strip_node($a);
						$block->insertBefore($new_node, $firstChild);
					}
				}
			}
		}
	}
	
	protected function isProbablyAYear($num) {
		return ($num > 1900 && $num < 2100);
	}
	
	protected function disambiguateBetweenRomanNumeralsAndLetters($order_indicator) {
		if(ReTidy::isAmbiguousBetweenRomanNumeralsAndLetters($order_indicator)) {
			return "roman_numeral";
		} else {
			return "letter";
		}
	}
	
	protected function isAmbiguousBetweenRomanNumeralsAndLetters($order_indicator) {
		$order_indicator = preg_replace('/[^a-z]/is', '', $order_indicator);
		if(stripos($order_indicator, "M") !== false && substr_count(strtoupper($order_indicator), "M") === strlen($order_indicator)) {
			return true;
		} elseif(stripos($order_indicator, "D") !== false && substr_count(strtoupper($order_indicator), "D") === strlen($order_indicator)) {
			return true;
		} elseif(stripos($order_indicator, "C") !== false && substr_count(strtoupper($order_indicator), "C") === strlen($order_indicator)) {
			return true;
		} elseif(stripos($order_indicator, "L") !== false && substr_count(strtoupper($order_indicator), "L") === strlen($order_indicator)) {
			return true;
		} elseif(stripos($order_indicator, "X") !== false && substr_count(strtoupper($order_indicator), "X") === strlen($order_indicator)) {
			return true;
		} elseif(stripos($order_indicator, "V") !== false && substr_count(strtoupper($order_indicator), "V") === strlen($order_indicator)) {
			return true;
		} elseif(stripos($order_indicator, "I") !== false && substr_count(strtoupper($order_indicator), "I") === strlen($order_indicator)) {
			return true;
		}
		return false;
	}
	
	protected function alphabetical_to_decimal($alpha) {
		// we have many assumptions; such as big endianness...
		$strlen = strlen($alpha);
		if($strlen > 2) {
			ReTidy::warning("I (alphabetical_to_decimal) give up; length (" . $strlen . ") of letters (" . $alpha . ") too large!");
		}
		$counter = 0;
		$sum = 0;
		while($counter < $strlen) {
			$ord = ord($alpha[$counter]);
			if($ord > 64 && $ord < 91) {
				$sum += ($ord - 64) * pow(26, $strlen - $counter - 1);
			} elseif($ord > 96 && $ord < 123) {
				$sum += ($ord - 96) * pow(26, $strlen - $counter - 1);
			} else {
				print("I (alphabetical_to_decimal) give up; this character (" . $alpha[$counter] . ") does not fall into the ranges I know how to work with!<br>\r\n");
			}
			$counter++;
		}
		return $sum;
	}
	
	protected function decimal_to_alphabetical($num, $case = "upper") {
		// generalizing this function is certainly doable but probably unnecessary
		if($num > 1235) {
			print("I (decimal_to_alphabetical) give up; number (" . $num . ") too large!<br>\r\n");
		}
		$num = $num - 1;
		$wholes = bcdiv($num, 26);
		$modulus = bcmod($num, 26);
		if($wholes > 0) {
			if($modulus === 0) {
				$alpha = chr(65 + $wholes);
			} else {
				$alpha = chr(64 + $wholes) . chr(65 + $modulus);
			}
		} else {
			$alpha = chr(65 + $modulus);
		}
		if($case === "lower") {
			return strtolower($alpha);
		} else {
			return $alpha;
		}
	}
	
	protected function decimal_to_roman_numeral($num) {
		$n = intval($num);
		$res = '';
		$roman_numerals = array(
			'M'  => 1000,
			'CM' => 900,
			'D'  => 500,
			'CD' => 400,
			'C'  => 100,
			'XC' => 90,
			'L'  => 50,
			'XL' => 40,
			'X'  => 10,
			'IX' => 9,
			'V'  => 5,
			'IV' => 4,
			'I'  => 1
		);
		foreach($roman_numerals as $roman => $number) {
			$matches = intval($n / $number);
			$res .= str_repeat($roman, $matches);
			$n = $n % $number;
		}
		return $res;
	}
	
	protected function roman_numeral_to_decimal($numeral) {
		$res = 0;
		$roman_numerals = array(
			'CM' => 900,
			'CD' => 400,
			'XC' => 90,
			'XL' => 40,
			'IX' => 9,
			'IV' => 4,
			'M'  => 1000,
			'D'  => 500,
			'C'  => 100,
			'L'  => 50,
			'X'  => 10,
			'V'  => 5,
			'I'  => 1
		);
		foreach($roman_numerals as $roman => $number) {
			$numeral = str_ireplace($roman, '', $numeral, $count);
			$res += $count * $number;
		}
		return $res;
	}
	
	function reverse_preg_pattern($string) {
		preg_match('/\/(.*?)\/(.*)/', $string, $matches);
		$expression = $matches[1];
		$modifiers = $matches[2];
		$expression = strrev($expression);
		$expression = preg_replace('/(.)\\\\/', '\\\\$1', $expression);
		// would need to hereafter at least fix position of quantifiers.
		return '/' . $expression . '/' . $modifiers;
	}
	
	//function preg_match_last($pattern, $subject, &$matches, $flags = "", $offset = 0) {
	// offset and flags are not supported now (2009-08-26)
	// flags resupported? (2011-12-02) naw...
	function preg_match_last($pattern, $subject, &$matches/*, $flags = false*/) {
		//if($flags === false) {
			preg_match_all($pattern, $subject, $matches2);
			$matches = array();
			foreach($matches2 as $index => $value) {
				$matches[$index] = $value[sizeof($value) - 1];
			}
		//} else {
		//	preg_match_all($pattern, $subject, $matches2, $flags);
		//	$matches = array();
		//	foreach($matches2 as $index => $value) {
		//		$matches[$index] = $value[sizeof($value) - 1];
		//	}
		//}
	}
	
	protected function mark_TOC() {
		// mark the table of contents so that, for examples, combine_inline and DOM_word_lists do not act on it.
		$TOCArray = ReTidy::getTOCArray();
		if(sizeof($TOCArray) === 0) {
			return false;
		}
		foreach($TOCArray as $index => $value) {
			$TOC = $value[0];
			$this->code = str_replace($TOC, '<div id="XXX9o9TOCdiv9o9XXX">' . $TOC . '</div>', $this->code);
		}
		ReTidy::tidy_code();
	}
	
	protected function unmark_TOC() {
		ReTidy::non_DOM_stripme('<div id="XXX9o9TOCdiv9o9XXX">');
	}
	
	function mb_preg_match($pattern, $subject, &$matches, $flags = null, $offset = 0, $encoding = null) {
		if(is_null($encoding)) {
			$encoding = mb_internal_encoding();
		}
		$offset = strlen(mb_substr($subject, 0, $offset, $encoding));
		$result = preg_match($pattern, $subject, $matches, $flags, $offset);
		if($result && ($flags & PREG_OFFSET_CAPTURE)) {
			foreach($matches as &$ha_subpattern) {
				$ha_subpattern[1] = mb_strlen(substr($subject, 0, $ha_subpattern[1]), $encoding);
			}
		}
		return $result;
	}
	
	protected function word_lists() {
		//print('$this->tidyer_DOM: ');var_dump($this->tidyer_DOM);
		$left_quotes = explode('|', $this->leftQuotes);
		$looking_for_text = true;
		foreach($this->tidyer_DOM as $index => $value) {
			if($this->tidyer_DOM[$index][0] === 1 && $this->tidyer_DOM[$index][1][2] === 0) { // opening tag
				if($this->tidyer_DOM[$index][1][3]) { // opening block
				
				} elseif($this->tidyer_DOM[$index][1][0] === 'a') {
					// footnotes
					//print('$this->tidyer_DOM[$index][1][1]: ');var_dump($this->tidyer_DOM[$index][1][1]);
					foreach($this->tidyer_DOM[$index][1][1] as $attribute_index => $attribute_value) { // check the attributes
						if(strpos($attribute_value[1], '_ftn') !== false) {
							$looking_for_text = false;
							continue 2;
						}
					}
				}
				$looking_for_text = true; // look for first relevant text
			} /*elseif($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][2] === 2 && $this->tidyer_DOM[$counter][1][3]) { // closing block
			
			} */elseif($looking_for_text && $value[0] === 0) { // text
				//print('$value: ');var_dump($value);
				$value[1] = ReTidy::trim_nbsp($value[1]);
				if(ReTidy::isSpace($value[1])) {
					continue;
				}
				//print('$value[1][0]: ');var_dump($value[1][0]);
				foreach($left_quotes as $left_quote) {
					if(strpos($value[1], $left_quote) === 0) {
						continue 2;
					}
				}
				$looking_for_text = false;
				// definition of an order indicator
				ReTidy::mb_preg_match('/' . $this->order_indicator_regex_with_complex_number_without_space . '/is', $value[1], $order_indicator_matches, PREG_OFFSET_CAPTURE);
				// should roman_numerals be moved ahead of numbers since they are a subset? it is tricky since if the program
				// come across "i. blah..." (as the first item in a list), how does it know whether it is a lettered or numbered list?
				$order_indicator = $order_indicator_matches[1][0];
				$order_indicator_offset = $order_indicator_matches[1][1];
				//$space = $order_indicator_matches[7][0];
				if($order_indicator_offset === 0) {
					//print('Found one!');
				} else {
					continue;
				}
				if(strlen($order_indicator) === 0) {
					continue;
				}
				//print('$order_indicator: ');var_dump($order_indicator);
				//if(strpos($order_indicator, "&") === false && strlen($order_indicator) > 6) {
				//	break;
				//}
				//$after_order_indicator = substr($tagless, strlen($order_indicator));
				//print('here39858905696797<br>');
				$counter = $index - 1;
				while($counter > -1) {
					//print('here39858905696798<br>');
					if($this->tidyer_DOM[$counter][0] === 1 && $this->tidyer_DOM[$counter][1][3]) { // is block tag
						//print('here39858905696799<br>');
						if($this->tidyer_DOM[$counter][1][0] === 'p' && $this->tidyer_DOM[$counter][1][2] === 0) { // opening paragraph
							//print('here39858905696800<br>');
							$counter2 = $index + 1;
							while($counter2 < sizeof($this->tidyer_DOM)) {
								//print('here39858905696801<br>');
								if($this->tidyer_DOM[$counter2][1][0] === 'p' && $this->tidyer_DOM[$counter2][1][2] === 1) { // closing paragraph
									//print('here39858905696802<br>');
									foreach($this->array_order_indicator_types as $order_indicator_type_index => $order_indicator_type_value) {
										if($order_indicator === $order_indicator_matches[$order_indicator_type_index][0]) {
											$order_indicator_type = $order_indicator_type_value;
											break;
										}
									}
									// ordered lists in unordered lists or vica versa shall be problems...
									if($order_indicator_type === "number") {
										preg_match('/[0-9]+/', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
										$possible_order_indicator = intval($matches590[0][0]);
										$offset = $matches590[0][1];
										$order_indicator_string = ' order_indicator="' . $order_indicator . '" list_type="number" start_value="' . $possible_order_indicator . '"';
									} elseif/*($order_indicator_type === "complex number") { // if they have complex order indicators, then they would not become simple lists anyway.
									//	print("order indicator: ");var_dump($order_indicator);
									//	print("encountered complex number order indicator 32890325890425");exit(0);
									//}
									elseif*/($order_indicator_type === "letter") {
										preg_match('/[a-z]+/i', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
										$possible_order_indicator = $matches590[0][0];
										$i = 97;
										while($i < 123) {
											if($possible_order_indicator === chr($i)) {
												$possible_order_indicator = $i - 96;
												break;
											}
											$i++;
										}
										$offset = $matches590[0][1];
										$order_indicator_string = ' order_indicator="' . $order_indicator . '" list_type="letter" start_value="' . $possible_order_indicator . '"';
									} elseif($order_indicator_type === "roman_numeral") {
										preg_match('/[ivxlc]+/i', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
										$possible_order_indicator = ReTidy::roman_numeral_to_decimal($matches590[0][0]);
										$offset = $matches590[0][1];
										$order_indicator_string = ' order_indicator="' . $order_indicator . '" list_type="roman_numeral" start_value="' . $possible_order_indicator . '"';
									} else {
										//print("order indicator: ");var_dump($order_indicator);
										$order_indicator_string = ' order_indicator="' . $order_indicator . '" list_type="bullet"';
									}
									
									// turn this paragraph into a list item
									$this->tidyer_DOM[$counter][1][0] = 'li' . $order_indicator_string;
									$this->tidyer_DOM[$counter2][1][0] = 'li';
									continue 3;
								}
								$counter2++;
							}
						} elseif($this->tidyer_DOM[$counter][1][0] === 'li' && $this->tidyer_DOM[$counter][1][2] === 0) { // opening li
							//print('here39858905696800a<br>');
							$counter2 = $index + 1;
							while($counter2 < sizeof($this->tidyer_DOM)) {
								//print('here39858905696801a<br>');
								if($this->tidyer_DOM[$counter2][1][0] === 'li' && $this->tidyer_DOM[$counter2][1][2] === 1) { // closing li
									//print('here39858905696802a<br>');
									foreach($this->array_order_indicator_types as $order_indicator_type_index => $order_indicator_type_value) {
										if($order_indicator === $order_indicator_matches[$order_indicator_type_index][0]) {
											$order_indicator_type = $order_indicator_type_value;
											break;
										}
									}
									// ordered lists in unordered lists or vica versa shall be problems...
									if($order_indicator_type === "number") {
										preg_match('/[0-9]+/', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
										$possible_order_indicator = intval($matches590[0][0]);
										$offset = $matches590[0][1];
										$order_indicator_string = ' preexisting_list="true" order_indicator="' . $order_indicator . '" list_type="number" start_value="' . $possible_order_indicator . '"';
									} elseif/*($order_indicator_type === "complex number") { // if they have complex order indicators, then they would not become simple lists anyway.
									//	print("order indicator: ");var_dump($order_indicator);
									//	print("encountered complex number order indicator 32890325890425");exit(0);
									//}
									elseif*/($order_indicator_type === "letter") {
										preg_match('/[a-z]+/i', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
										$possible_order_indicator = $matches590[0][0];
										$i = 97;
										while($i < 123) {
											if($possible_order_indicator === chr($i)) {
												$possible_order_indicator = $i - 96;
												break;
											}
											$i++;
										}
										$offset = $matches590[0][1];
										$order_indicator_string = ' preexisting_list="true" order_indicator="' . $order_indicator . '" list_type="letter" start_value="' . $possible_order_indicator . '"';
									} elseif($order_indicator_type === "roman_numeral") {
										preg_match('/[ivxlc]+/i', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
										$possible_order_indicator = ReTidy::roman_numeral_to_decimal($matches590[0][0]);
										$offset = $matches590[0][1];
										$order_indicator_string = ' preexisting_list="true" order_indicator="' . $order_indicator . '" list_type="roman_numeral" start_value="' . $possible_order_indicator . '"';
									} else {
										//print("order indicator: ");var_dump($order_indicator);
										$order_indicator_string = ' preexisting_list="true" order_indicator="' . $order_indicator . '" list_type="bullet"';
									}
									
									// add info to a list item
									$this->tidyer_DOM[$counter][1][0] = 'li' . $order_indicator_string;
									$this->tidyer_DOM[$counter2][1][0] = 'li';
									continue 3;
								}
								$counter2++;
							}
						} else {
							continue 2;
						}
					}
					$counter--;
				}
			}
		}
		// now put <ol> or <ul> around the <li>s
		//print('$this->tidyer_DOM: ');var_dump($this->tidyer_DOM);
		$new_tidyer_DOM = array();
		$list_DOM = array();
		$list_type_being_worked_on = false;
		$start_value_being_worked_on = false;
		//print('here454845954609<br>');
		$index = 0;
		//print('$this->tidyer_DOM3: ');var_dump($this->tidyer_DOM);
		while($index < sizeof($this->tidyer_DOM)) {
			//print('here454845954610<br>');
			while(substr($this->tidyer_DOM[$index][1][0], 0, 2) === 'li' && $this->tidyer_DOM[$index][1][2] === 0 && $index < sizeof($this->tidyer_DOM)) { // opening tag beginning with li
				//print('here454845954611<br>');
				//print('$this->tidyer_DOM[$index]0: ');var_dump($this->tidyer_DOM[$index]);
				$order_indicator_found = OM::getOStringContents($this->tidyer_DOM[$index][1][0], 'order_indicator="', '"');
				if($order_indicator_found === false) { // seems to be for pre-existing lists where no order indicator was found...
					
				} else {
					//print('$order_indicator_found: ');var_dump($order_indicator_found);
					$list_type_found = OM::getOStringContents($this->tidyer_DOM[$index][1][0], 'list_type="', '"');
					$start_value_found = OM::getOStringContents($this->tidyer_DOM[$index][1][0], 'start_value="', '"');
					$preexisting_list_found = OM::getOStringContents($this->tidyer_DOM[$index][1][0], 'preexisting_list="', '"');
					//print('$preexisting_list_found: ');var_dump($preexisting_list_found);
					if($list_type_being_worked_on === false) {
						$list_type_being_worked_on = $list_type_found;
						$start_value_being_worked_on = $start_value_found;
						//print('$list_type_being_worked_on: ');var_dump($list_type_being_worked_on);
					} elseif($list_type_being_worked_on !== $list_type_found) {
						// default to <ul>
						ReTidy::warning('List with multiple or confusing order indicator types found!');
						//print('$list_type_being_worked_on, $list_type_found: ');var_dump($list_type_being_worked_on, $list_type_found);
						$list_type_being_worked_on = 'bullet';
						$start_value_being_worked_on = false;
					}
					$this->tidyer_DOM[$index][1][0] = 'li';
					// remove the order indicator
					// pretty bad hack but sufficient for most cases?
					$index2 = $index;
					//while(($this->tidyer_DOM[$index2][0] !== 0 || strlen($this->tidyer_DOM[$index2][1]) === 0) && $index2 < sizeof($this->tidyer_DOM)) { // text
					//	$index2++;
					//}
					while($index2 < sizeof($this->tidyer_DOM)) {
						//print('$this->tidyer_DOM[$index2][1], $order_indicator_found: ');var_dump($this->tidyer_DOM[$index2][1], $order_indicator_found);
						if($this->tidyer_DOM[$index2][0] !== 0) {
							
						} elseif(strpos($this->tidyer_DOM[$index2][1], $order_indicator_found) === 0) {
							break;
						}
						$index2++;
					}
					//print('$index2, sizeof($this->tidyer_DOM): ');var_dump($index2, sizeof($this->tidyer_DOM));
					//print('supposedly order indicator: $this->tidyer_DOM[$index2]: ');var_dump($this->tidyer_DOM[$index2]);
					//if($this->tidyer_DOM[$index2][1][0] === '&') {
					//	//print('here454845954610<br>');
					//	$this->tidyer_DOM[$index2][1] = mb_substr($this->tidyer_DOM[$index2][1], strpos($this->tidyer_DOM[$index2][1][0], ';') + 1);
					//} else {
					//	//print('here454845954611<br>');
					//	$this->tidyer_DOM[$index2][1] = mb_substr($this->tidyer_DOM[$index2][1], 1);
					//}
					//print('substr($this->tidyer_DOM[$index2][1], strlen($order_indicator_found)): ');var_dump(substr($this->tidyer_DOM[$index2][1], strlen($order_indicator_found)));
					$this->tidyer_DOM[$index2][1] = substr($this->tidyer_DOM[$index2][1], strlen($order_indicator_found));
					//print('$this->tidyer_DOM[$index]1: ');var_dump($this->tidyer_DOM[$index]);
				}
				$list_DOM[] = $this->tidyer_DOM[$index];
				$index++;
				while($index < sizeof($this->tidyer_DOM)) { // get the index for the next opening block tag
					//print('here454845954612<br>');
					if($this->tidyer_DOM[$index][0] === 1 && $this->tidyer_DOM[$index][1][2] === 0 && $this->tidyer_DOM[$index][1][3]) {
						break;
					}
					//print('$this->tidyer_DOM[$index]2: ');var_dump($this->tidyer_DOM[$index]);
					$list_DOM[] = $this->tidyer_DOM[$index];
					$index++;
				}
			}
			if($list_type_being_worked_on !== false) {
				//print('baaaa1<br>');
				$attributes_array = array();
				if($start_value_being_worked_on !== false) {
					$attributes_array[] = array('start', $start_value_being_worked_on);
				}
				if($list_type_being_worked_on === 'number') {
					$tag_array = array('ol', $attributes_array, 0, true);
				} elseif($list_type_being_worked_on === 'letter') {
					$attributes_array[] = array('type', 'a');
					$tag_array = array('ol', $attributes_array, 0, true);
				} elseif($list_type_being_worked_on === 'roman_numeral') {
					$attributes_array[] = array('type', 'i');
					$tag_array = array('ol', $attributes_array, 0, true);
				} else {
					//print('$list_type_being_worked_on: ');var_dump($list_type_being_worked_on);
					$tag_array = array('ul', $attributes_array, 0, true);
				}
				if(!($preexisting_list_found === 'true')) {
					$new_list_DOM = array(array(1, $tag_array));
					foreach($list_DOM as $list_index => $list_value) {
						//print('$list_DOM[$list_index]2: ');var_dump($list_DOM[$list_index]);
						$new_list_DOM[] = $list_DOM[$list_index];
					}
					if($list_type_being_worked_on !== false) {
						if($list_type_being_worked_on === 'number') {
							//print('here34050866097609<br>');
							$new_list_DOM[] = array(1, array('ol', array(), 1, true));
						} elseif($list_type_being_worked_on === 'letter') {
							//print('here34050866097610<br>');
							$new_list_DOM[] = array(1, array('ol', array(), 1, true));
						} elseif($list_type_being_worked_on === 'roman_numeral') {
							//print('here34050866097611<br>');
							$new_list_DOM[] = array(1, array('ol', array(), 1, true));
						} else {
							//print('here34050866097612<br>');
							$new_list_DOM[] = array(1, array('ul', array(), 1, true));
							//print('um: ');var_dump(array(1, array('ul', '', 1, true)));
						}
					}
					$list_DOM = $new_list_DOM;
				}
				$list_type_being_worked_on = false;
				$start_value_being_worked_on = false;
			}
			if(sizeof($list_DOM) > 0) {
				//print('baaaa2<br>');
				//print('$list_DOM: ');var_dump($list_DOM);
				//$list_DOM_code = ReTidy::generate_code_from_tidyer_DOM_like_array($list_DOM);
				//print('$list_DOM_code: ' . $list_DOM_code);
				foreach($list_DOM as $list_index => $list_value) {
					//print('$list_DOM[$list_index]: ');var_dump($list_DOM[$list_index]);
					$new_tidyer_DOM[] = $list_DOM[$list_index];
				}
				$list_DOM = array();
			}
			//print('$this->tidyer_DOM[$index]5: ');var_dump($this->tidyer_DOM[$index]);
			if(isset($this->tidyer_DOM[$index][0])) { // hack alert				
				$new_tidyer_DOM[] = $this->tidyer_DOM[$index];
			}
			$index++;
		}
		//print('$new_tidyer_DOM: ');var_dump($new_tidyer_DOM);
		$this->tidyer_DOM = $new_tidyer_DOM;
		return true;
	}
	
	protected function DOM_word_lists() {
		$array_p_skips = array();
		$query = '//' . ReTidy::get_html_namespace() . 'p';
		$ps = $this->xpath->query($query);
		$query = '//' . ReTidy::get_html_namespace() . 'div[@id="XXX9o9TOCdiv9o9XXX"]//' . ReTidy::get_html_namespace() . 'p';
		$ps_in_TOC = $this->xpath->query($query);
		foreach($ps as $p) {
			foreach($ps_in_TOC as $p_in_TOC) {
				if($p === $p_in_TOC) {
					continue 2;
				}
			}
			//var_dump(ReTidy::DOM_getNodeString($p));print("<br>\r\n");
			$array_post_proc = array();
			$begin_markers = array();
			$end_markers = array();
			foreach($array_p_skips as $skip_index => $p_skip) {
				if($p_skip === $p) {
					unset($array_p_skips[$skip_index]);
					continue;
				}
			}
			// here we assign lists based on the putative order indicators.
			$working_p = $p;
			$margin_lefts = array();
			$look_for_order = false;
			$saved_possible_order_indicator = false;
			$last_possible_order_indicator = false;
			unset($start_value);
			while(ReTidy::isNode($working_p) && $working_p->nodeName === "p") {
				//$tagless = utf8_decode(ReTidy::tagless($working_p));
				$tagless = ReTidy::tagless($working_p);
				// them to single-byte so that they may be considered bullets.
				//$tagless = ReTidy::tagless($working_p);
				if(ReTidy::isSpace($tagless)) {
					break;
				}
				// definition of an order indicator
				preg_match('/' . $this->order_indicator_regex . '/is', $tagless, $order_indicator_matches, PREG_OFFSET_CAPTURE);
				// should roman numerals be moved ahead of numbers since they are a subset? it is tricky since if the program
				// come across "i. blah..." (as the first item in a list), how does it know whether it is a lettered or numbered list?
				$order_indicator = $order_indicator_matches[1][0];
				$order_indicator_offset = $order_indicator_matches[1][1];
				$space = $order_indicator_matches[7][0];
				//var_dump($order_indicator);print("<br>\r\n");
				if($order_indicator_offset === 0) {
					
				} else {
					break;
				}
				if(strlen($order_indicator) === 0) {
					break;
				}
				//if(strpos($order_indicator, "&") === false && strlen($order_indicator) > 6) {
				//	break;
				//}
				$after_order_indicator = substr($tagless, strlen($order_indicator));
				preg_match('/([0-9\s\$\%]|&#xa0;|&#xA0;|&nbsp;|&#160;|and|){0,}/s', $after_order_indicator, $after_order_indicator_matches);
				if(strlen($after_order_indicator) === strlen($after_order_indicator_matches[0])) {
					if($working_p->parentNode->nodeName === "td" || $working_p->parentNode->nodeName === "th") {
						// we call this not something that needs to be listed.
						break;
					}
				}
				foreach($this->array_order_indicator_types as $order_indicator_type_index => $order_indicator_type_value) {
					if($order_indicator === $order_indicator_matches[$order_indicator_type_index][0]) {
						$order_indicator_type = $order_indicator_type_value;
						break;
					}
				}
				// ordered lists in unordered lists or vica versa shall be problems...
				if($order_indicator_type === "number") {
					preg_match('/[0-9]+/', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
					$possible_order_indicator = intval($matches590[0][0]);
					$offset = $matches590[0][1];
				}
				// if they have complex order indicators, then they would not become simple lists anyway.
				//if($order_indicator_type === "complex number") {
				//	print("order indicator: ");var_dump($order_indicator);
				//	print("encountered complex number order indicator 32890325890425");exit(0);
				//}
				if($order_indicator_type === "letter") {
					preg_match('/[a-z]+/i', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
					$possible_order_indicator = $matches590[0][0];
					$i = 97;
					while($i < 123) {
						if($possible_order_indicator === chr($i)) {
							$possible_order_indicator = $i - 96;
							break;
						}
						$i++;
					}
					$offset = $matches590[0][1];
				}
				if($order_indicator_type === "roman_numeral") {
					preg_match('/[ivxlc]+/i', $order_indicator, $matches590, PREG_OFFSET_CAPTURE);
					$possible_order_indicator = ReTidy::roman_numeral_to_decimal($matches590[0][0]);
					$offset = $matches590[0][1];
				}
				if($order_indicator_type === "number" || $order_indicator_type === "letter" || $order_indicator_type === "roman_numeral"/* || $order_indicator_type === "complex number"*/) {
					if($saved_possible_order_indicator === false) {
						$saved_possible_order_indicator = $possible_order_indicator;
						if($offset === 0) {
							$look_for_order = true;
							// eventually we shall need to handle other types of numbering as well
							if($possible_order_indicator === 1) {
								
							} else {
								$start_value = $possible_order_indicator;
							}							
						}
					} else {
						if($possible_order_indicator === $saved_possible_order_indicator) {
							$look_for_order = false;
						} else {
							if($look_for_order) {
								if($last_possible_order_indicator+1 == $possible_order_indicator) {
								
								} else {
									$look_for_order = false;
								}
							}
						}
					}
				}
				$last_possible_order_indicator = $possible_order_indicator;				
				$working_style_attribute = ReTidy::getAttribute($working_p, "style");
				preg_match_all('/text\-indent\s*:\s*\-[0-9\.]+(pt|in)(;){0,1}/s', $working_style_attribute->nodeValue, $working_style_matches);
				if(sizeof($working_style_matches[0]) > 0) {
					foreach($working_style_matches[0] as $index69 => $value69) {
						$working_style_attribute->nodeValue = str_replace($value69, '', $working_style_attribute->nodeValue);
					}
				}
				//preg_match('/margin\-left\s*:\s*([0-9\.\-]+)(pt|in)(;){0,1}/s', $working_style_attribute->nodeValue, $style_matches2);
				ReTidy::preg_match_last('/margin\-left\s*:\s*([0-9\.\-]+)(pt|in)(;){0,1}/s', $working_style_attribute->nodeValue, $style_matches2);
				//var_dump($style_matches2);exit(0);
				if(strlen($style_matches2[1]) > 0) {
					$left_margin = $style_matches2[1];
				} else {
					$left_margin = "0";
				}
				$is_new = true;
				foreach($margin_lefts as $margin_left) {
					if($left_margin == "0" || abs($margin_left - $left_margin) < 10) {
						$is_new = false;
						break;
					}
				}
				$added_a_begin = false;
				if($is_new) {
					if($look_for_order) {
						if(isset($start_value)) {
							if($order_indicator_type === "roman_numeral") {
								$begin_markers[] = array($working_p, 'XXX9o9NewTagBeginXXXol type="i" start="' . $start_value . '"9o9XXX');
							} elseif($order_indicator_type === "letter") {
								$begin_markers[] = array($working_p, 'XXX9o9NewTagBeginXXXol type="a" start="' . $start_value . '"9o9XXX');
							} else {
								$begin_markers[] = array($working_p, 'XXX9o9NewTagBeginXXXol start="' . $start_value . '"9o9XXX');
							}
						} else {
							if($order_indicator_type === "roman_numeral") {
								$begin_markers[] = array($working_p, 'XXX9o9NewTagBeginXXXol type="i"9o9XXX');
							} elseif($order_indicator_type === "letter") {
								$begin_markers[] = array($working_p, 'XXX9o9NewTagBeginXXXol type="a"9o9XXX');
							} else {
								$begin_markers[] = array($working_p, 'XXX9o9NewTagBeginXXXol9o9XXX');
							}
						}
					} else {
						$begin_markers[] = array($working_p, 'XXX9o9NewTagBeginXXXul9o9XXX');
					}
					$margin_lefts[] = $left_margin;
					$added_a_begin = true;
				}
				if($last_left_margin != $left_margin && !$added_a_begin) {
					foreach($margin_lefts as $index => $margin_left) {
						if(abs($margin_left - $left_margin) < 10) {
							unset($margin_lefts[$index]);
							if($look_for_order || $order_indicator_type === "number" || $order_indicator_type === "letter" || $order_indicator_type === "roman_numeral") {
								$end_markers[] = array($working_p, 'XXX9o9NewTagEndXXXol9o9XXX');
							} else {
								$end_markers[] = array($working_p, 'XXX9o9NewTagEndXXXul9o9XXX');
							}
							break;
						}
					}
				}
				$array_p_skips[] = $working_p;
				$array_post_proc[] = array($working_p, $space);
				$last_p = $working_p;
				$last_left_margin = $left_margin;
				$working_p = ReTidy::nextElement($working_p);
				if($working_p === false) {
					break;
				}
			}
			$size = sizeof($array_post_proc);
			//if($size > 1 || !$look_for_order) {
			if($size > 1) {
				// we do not want single item lists; this is an inaccurate but useful approximation
				// because we will not get heading or table headers as lists
				foreach($begin_markers as $begin_index => $begin_value) {
					$begin_p = $begin_value[0];
					$begin_marker = $begin_value[1];
					$begin_p->parentNode->insertBefore(new DOMText($begin_marker), $begin_p);
					unset($begin_markers[$begin_index]);
				}
				foreach($end_markers as $end_index => $end_value) {
					$end_p = $end_value[0];
					$end_marker = $end_value[1];
					$end_p->parentNode->insertBefore(new DOMText($end_marker), $end_p->nextSibling);
					unset($end_markers[$end_index]);
				}				
				foreach($array_post_proc as $post_proc_index => $value) {
					$p_skip = $value[0];
					$space = $value[1];
					// remove the order indicator
					$p_skip->insertBefore(new DOMText('XXX9o9DeleteNonTagsBegin9o9XXX'), $p_skip->firstChild);
					ReTidy::delete_me_end_in_first_node($p_skip, $space);
					$p_skip->setAttribute('newtag', 'li');
					unset($array_post_proc[$post_proc_index]);
				}
				foreach($margin_lefts as $index => $margin_left) {
					if($look_for_order || $order_indicator_type === "number" || $order_indicator_type === "letter" || $order_indicator_type === "roman_numeral") {
						$last_p->parentNode->insertBefore(new DOMText('XXX9o9NewTagEndXXXol9o9XXX'), $last_p->nextSibling);
					} else {
						$last_p->parentNode->insertBefore(new DOMText('XXX9o9NewTagEndXXXul9o9XXX'), $last_p->nextSibling);
					}
				}
			} else {
				$array_post_proc = array();
			}
		}
	}
	
	protected function delete_me_end_in_first_node($node, $space = " ") {
		if($node->nodeType === 1 && $node->hasChildNodes()) {
			foreach($node->childNodes as $child) {
				if(ReTidy::delete_me_end_in_first_node($child, $space)) {
					return true;
				}
			}
		}
		if($node->nodeType === 6) {
			print("bing576864769<br>\r\n");
			print("nodeType: ");var_dump($node->nodeType);print("<br>\r\n");
			print("nodeName: ");var_dump($node->nodeName);print("<br>\r\n");
			print("nodeValue: ");var_dump($node->nodeValue);print("<br>\r\n");
			print("bing576864770<br>\r\n");exit(0);
		}
		if($node->nodeType === 5 && $node->nodeName === "nbsp") {
			$node->parentNode->insertBefore(new DOMText("XXX9o9DeleteNonTagsEnd9o9XXX"), $node->nextSibling);
			return true;
		}		
		if($node->nodeType === 3 && strpos($node->nodeValue, $space) !== false) {
			$node->nodeValue = ReTidy::str_replace_first($space, "XXX9o9DeleteNonTagsEnd9o9XXX", $node->nodeValue);			
			return true;
		}
		return false;
	}
	
	protected function DOM_word_font_size() {
		// font-size
		$tags = $this->xpath->query('//' . ReTidy::get_html_namespace() . '*[contains(@style, "font-size")]');
		foreach($tags as $tag) {
			if(ReTidy::isEmpty($tag)) {
				continue;
			} else {
				// which is better to grab the style_attribute? xpath or DOM?
				$style_attribute = ReTidy::getAttribute($tag, "style");
				preg_match('/font\-size\s*:\s*([^;]*);/s', $style_attribute->nodeValue, $font_size_matches);
				if(strlen($font_size_matches[0]) > 0) {
					$font_size_styling = $font_size_matches[1];
					preg_match('/([0-9]*)\s*([^\s]*)/is', $font_size_styling, $font_size_styling_matches);
					$font_size_magnitude = $font_size_styling_matches[0];
					$font_size_unit = $font_size_styling_matches[1];
					if($font_size_unit = "pt") {
						// we must also consider a base font size I think.
						if($font_size_magnitude == 12) {
							// do nothing
						} elseif($font_size_magnitude < 15.5 && $font_size_magnitude > 12.5) {
							// theoretically we would like to eventually be able to determine headings from font size 
							// by intelligently setting font size bounds for headings.
							$tag->insertBefore(new DOMText('XXX9o9NewTagBeginXXXstrong9o9XXX'), $tag->firstChild);
							$tag->appendChild(new DOMText('XXX9o9NewTagEndXXXstrong9o9XXX'));
						}
					}
					$style_attribute->nodeValue = str_replace($font_size_matches[0], '', $style_attribute->nodeValue);
				}
			}
		}
	}
	
	protected function DOM_word_margin() {
		// consecutive <p>s with top and bottom margin ~= 0
		// change (word) single-spaced paragraphs to (HTML) double-spaced paragraphs.
		$query = '//' . ReTidy::get_html_namespace() . 'p | //' . ReTidy::get_html_namespace() . 'br[@clear="all"]';
		$ps = $this->xpath->query($query);
		$array_analyzed_ps = array();
		foreach($ps as $p) {
			$join_them = true;
			if($p->nodeName === "br") {
				$join_them = false;
			} else {
				//if(ReTidy::isEmpty($p)) {
				if(ReTidy::isStyleAgnostic($p)) {
					$join_them = false;
				} else {
					// which is better to grab the style_attribute? xpath or DOM?
					$style_attribute = ReTidy::getAttribute($p, "style");
					if($style_attribute) {
						//preg_match('/margin\s*:\s*([^;]*);/s', $style_attribute->nodeValue, $margin_matches);
						// updated (2011-10-05); it is possible for style attributes to have overriding style information
						ReTidy::preg_match_last('/margin\s*:\s*([^;]*);/s', $style_attribute->nodeValue, $margin_matches);
						if(strlen($margin_matches[0]) > 0) {
							$margin_styling = $margin_matches[1];
							preg_match('/[0-9]*/is', $margin_styling, $margin_magnitude_matches);
							if($margin_magnitude_matches[0] < 0.001) { // then it is negligeable
								
							} else {
								$join_them = false;
							}
							$style_attribute->nodeValue = str_replace($margin_matches[0], '', $style_attribute->nodeValue);
						}
						//preg_match('/margin\-top\s*:\s*[^;]*;/s', $style_attribute->nodeValue, $margin_top_matches);
						// updated (2011-10-05); it is possible for style attributes to have overriding style information
						ReTidy::preg_match_last('/margin\-top\s*:\s*[^;]*;/s', $style_attribute->nodeValue, $margin_top_matches);
						if(strlen($margin_top_matches[0]) > 0) {
							if($join_them) {
								$margin_top_styling = $margin_top_matches[1];
								preg_match('/[0-9]*/is', $margin_top_styling, $margin_top_magnitude_matches);
								if($margin_top_magnitude_matches[0] < 0.001) { // then it is negligeable
									
								} else {
									$join_them = false;
								}
							}
							$style_attribute->nodeValue = str_replace($margin_top_matches[0], '', $style_attribute->nodeValue);
						}
						//preg_match('/margin\-bottom\s*:\s*[^;]*;/s', $style_attribute->nodeValue, $margin_bottom_matches);
						// updated (2011-10-05); it is possible for style attributes to have overriding style information
						ReTidy::preg_match_last('/margin\-bottom\s*:\s*[^;]*;/s', $style_attribute->nodeValue, $margin_bottom_matches);
						if(strlen($margin_bottom_matches[0]) > 0) {
							if($join_them) {
								$margin_bottom_styling = $margin_bottom_matches[1];
								preg_match('/[0-9]*/is', $margin_bottom_styling, $margin_bottom_magnitude_matches);
								if($margin_bottom_magnitude_matches[0] < 0.001) { // then it is negligeable
									
								} else {
									$join_them = false;
								}
							}
							$style_attribute->nodeValue = str_replace($margin_bottom_matches[0], '', $style_attribute->nodeValue);
						}
					} else {
						$join_them = false;
					}
				}
			}
			if($join_them) {
				$array_analyzed_ps[] = array($p, true);
			} else {
				$array_analyzed_ps[] = array($p, false);
			}
		}
		
		$joining = false;
		foreach($array_analyzed_ps as $index => $value) {
			$p = $value[0];
			$join = $value[1];
			if($joining) {
				if($p->hasAttributes()) {
					$p->setAttribute('newtag', 'span');
				} else {
					$p->setAttribute('stripme', 'y');
					ReTidy::DOM_strip_node($p);
				}
				if($array_analyzed_ps[$index+1][1] && $array_analyzed_ps[$index+1][0] === ReTidy::nextElement($p)) {
					$p->appendChild(new DOMElement('br'));
					continue;
				} else {
					$joining = false;
					if(ReTidy::isNode($p->nextSibling)) {
						$p->parentNode->insertBefore(new DOMText('XXX9o9NewTagEndXXXp9o9XXX'), $p->nextSibling);
					} else {
						$p->parentNode->appendChild(new DOMText('XXX9o9NewTagEndXXXp9o9XXX'));
					}
					continue;
				}
			}
			if($join) {
				if($array_analyzed_ps[$index+1][1] && $array_analyzed_ps[$index+1][0] === ReTidy::nextElement($p)) {
					$joining = true;
					if($p->hasAttributes()) {
						$p->setAttribute('newtag', 'span');
					} else {
						$p->setAttribute('stripme', 'y');
						ReTidy::DOM_strip_node($p);
					}
					$p->parentNode->insertBefore(new DOMText('XXX9o9NewTagBeginXXXp9o9XXX'), $p);
					$p->appendChild(new DOMElement('br'));
				}
			}
		}

		// we may not want to always delete all margins...
		$style_attributes = $this->xpath->query('//@style');
		foreach($style_attributes as $style_attribute) {
			$style_attribute->nodeValue = preg_replace('/margin(\-right|\-left|\-top|\-bottom|)\s*:\s*([^;]*);/s', '', $style_attribute->nodeValue);
		}
	}
	
	protected function DOM_clean_word() {
		$style_attributes = $this->xpath->query('//@style');
		foreach($style_attributes as $style_attribute) {
			// font-weight bold
			// we could limit this replace to 1 although it seems unnecessary
			$style_attribute->nodeValue = preg_replace('/font\-weight\s*:\s*bold\s*;/is', '', $style_attribute->nodeValue, -1, $count);
			$parent = $style_attribute->parentNode;
			if($count > 0) {
				$parent->insertBefore(new DOMText('XXX9o9NewTagBeginXXXstrong9o9XXX'), $parent->firstChild);
				$parent->appendChild(new DOMText('XXX9o9NewTagEndXXXstrong9o9XXX'));
			}
			// border none
			preg_match_all('/border\s*:\s*((none)|(0[^;]+))\s*;/is', $style_attribute->nodeValue, $border_none_matches);
			if(sizeof($border_none_matches[0]) > 0) {
				$delete_border = true;
				foreach($border_none_matches[0] as $index => $value) {
					if($parent->nodeName === "a") {
						$images_in_a = $this->xpath->query('.//' . ReTidy::get_html_namespace() . 'img', $parent);
						foreach($images_in_a as $image_in_a) { $delete_border = false;	break 2; }
					}
				}
				if($delete_border) {
					foreach($border_none_matches[0] as $index => $value) {
						$style_attribute->nodeValue = str_replace($value, '', $style_attribute->nodeValue);
					}
				}
			}
			// link styling
			preg_match_all('/(color\s*:\s*blue)|(text-decoration\s*:\s*underline)\s*;/is', $style_attribute->nodeValue, $link_styling_matches);
			if(sizeof($link_styling_matches[0]) > 0) {
				$delete_styling = false;
				foreach($link_styling_matches[0] as $index => $value) {
					if($parent->nodeName === "a") {
						$delete_styling = true;
						break;
					} else {
						$ancestor_as = $this->xpath->query('ancestor::' . ReTidy::get_html_namespace() . 'a', $parent);
						foreach($ancestor_as as $ancestor_a) {
							if(ReTidy::areConflationaryIgnoringWhitespace($ancestor_a, $parent)) {
								$delete_styling = true;
								break 2;
							}
						}
						if(!$delete_styling) {
							$descendant_as = $this->xpath->query('.//' . ReTidy::get_html_namespace() . 'a', $parent);
							foreach($descendant_as as $descendant_a) {
								if(ReTidy::areConflationaryIgnoringWhitespace($descendant_a, $parent)) {
									$delete_styling = true;
									break 2;
								}
							}							
						}
					}
				}
				if($delete_styling) {
					foreach($link_styling_matches[0] as $index => $value) {
						$style_attribute->nodeValue = str_replace($value, '', $style_attribute->nodeValue);
					}
				}				
			}
		}
		
		// should this be here? does it do anything? (since we have done it before)
		//ReTidy::DOM_word_lists();
		
		// microsoft arbitrary section classes and footnotes
		$strip_footnotes_parent = true;
		$query = '//' . ReTidy::get_html_namespace() . 'div';
		$divs = $this->xpath->query($query);
		foreach($divs as $div) {
			// again, we would not want to do this generally
			if(ReTidy::isConflationaryWithChildIgnoringWhitespace($div) && ReTidy::firstElementChild($div)->nodeName === "table") {
				$div->setAttribute("stripme", "y");
				ReTidy::DOM_strip_node($div);
			}
			if($div->hasAttributes()) {
				foreach($div->attributes as $attribute) {
					if($attribute->nodeName === "id") {
						if(substr($attribute->nodeValue, 0, 3) === "ftn") {
							$query = ReTidy::get_html_namespace() . 'p';
							$ps = $this->xpath->query($query, $div);
							foreach($ps as $p) {
								if($p->hasAttributes()) {
									foreach($p->attributes as $style_attribute) {
										if($style_attribute->nodeName === "style") {
											$style_attribute->nodeValue = "stripme";
											break;
										}
									}
								}
							}
							$div->setAttribute("stripme", "y");
							ReTidy::DOM_strip_node($div);
							// this code works as long as the footnote parent exists; that is, as long as word's save as html always outputs it.
							if($strip_footnotes_parent) {
								$parent = $div->parentNode;
								while($parent->nodeType != 9) {
									if($parent->nodeName === "div") {
										$query7 = './/' . ReTidy::get_html_namespace() . 'hr';
										$hrs = $this->xpath->query($query7, $parent);
										foreach($hrs as $hr) {
											$style_attribute = ReTidy::getAttribute($hr, "style");
											$style_attribute->nodeValue = "stripme";
										}										
										$parent->setAttribute("stripme", "y");
										ReTidy::DOM_strip_node($parent);
										$strip_footnotes_parent = false;
										break;
									}
									$parent = $parent->parentNode;
								}
							}
						}
					}					
				}
			}
		}
		
		// used at least in table of contents page indicators
		$query = '//@style';
		$style_attributes = $this->xpath->query($query);
		foreach($style_attributes as $style_attribute) {
			$style_attribute->nodeValue = trim($style_attribute->nodeValue);
			preg_match('/display\s*:\s*none/is', $style_attribute->nodeValue, $matches46);
			if(sizeof($matches46[0]) > 0) {
				$parentNode = $style_attribute->parentNode;
				$parentNode->setAttribute("deleteme", "y");		
			}
		}
		
		// again, should this be here? does it do anything? (since we have done it before)
		ReTidy::DOM_word_table_clean();

		$query = '//' . ReTidy::get_html_namespace() . 'span';
		$spans = $this->xpath->query($query);
		foreach($spans as $span) {
			$found_an_attribute = false;
			foreach($span->attributes as $attribute) {
				if(strlen($attribute->nodeValue) === 0 || $attribute->nodeValue === "XXX9o9stripme9o9XXX") {
					// ignore as not a relevant attribute
				} else {
					$found_an_attribute = true;
					break;					
				}
			}
			if(!$found_an_attribute) {
				$span->setAttribute("stripme", "y");
				ReTidy::DOM_strip_node($span);
			}
		}
	}
	
	protected function getPreviousElements($node) {
		$arrayPreviousElements = array();
		$previousSibling = $node->previousSibling;
		while(ReTidy::isNode($previousSibling)) {
			if($previousSibling->nodeType === 1) {
				$arrayPreviousSiblings[] = $previousSibling;
			}
			$previousSibling = $previousSibling->previousSibling;
		}
		return $arrayPreviousElements;
	}
	
	protected function getNextElements($node) {
		$arrayNextElements = array();
		$nextSibling = $node->nextSibling;
		while(ReTidy::isNode($nextSibling)) {
			if($nextSibling->nodeType === 1) {
				$arrayNextSiblings[] = $nextSibling;
			}
			$nextSibling = $nextSibling->nextSibling;
		}
		return $arrayNextElements;
	}		
	
	protected function getPreviousSiblings($node) {
		$arrayPreviousSiblings = array();
		$previousSibling = $node->previousSibling;
		while(ReTidy::isNode($previousSibling)) {
			$arrayPreviousSiblings[] = $previousSibling;
			$previousSibling = $previousSibling->previousSibling;
		}
		return $arrayPreviousSiblings;
	}
	
	protected function getNextSiblings($node) {
		$arrayNextSiblings = array();
		$nextSibling = $node->nextSibling;
		while(ReTidy::isNode($nextSibling)) {
			$arrayNextSiblings[] = $nextSibling;
			$nextSibling = $nextSibling->nextSibling;
		}
		return $arrayNextSiblings;
	}

	protected function DOM_word_table_clean() {
		//$ps = $this->xpath->query('//p');
		//print('ps12: ');var_dump($ps, $ps->length, $this->dom);
		//print('$this->code: ' . $this->code);
		// "table-row-like" structures with lists that are done in word with paragraphs
		$trs = $this->xpath->query('//' . ReTidy::get_html_namespace() . 'tr');
		foreach($trs as $tr) {
			$saved_ul_count = false;
			$cells = $this->xpath->query(ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'td', $tr);
			foreach($cells as $cell) {
				$uls = $this->xpath->query(ReTidy::get_html_namespace() . 'ul', $cell);
				$ul_count = 0;
				foreach($uls as $ul) {
					$ul_count++;
				}
				if($ul_count < 2) {
					continue 2;
				}
				if($ul_count > 0) {
					if(!$saved_ul_count) {
						$saved_ul_count = $ul_count;
						continue;
					} elseif($saved_ul_count === $ul_count) {
						continue;
					} else {
						continue 2;
					}
				}
				continue 2;
			}
			// if we get to here, then do the row splitting
			while($ul_count > 0) {
				$new_node = $tr->cloneNode(true);
				$tr->parentNode->insertBefore($new_node, $tr->nextSibling);
				$new_node_cells = $this->xpath->query(ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'td', $new_node);
				foreach($new_node_cells as $new_node_cell) {
					$ul_to_keeps = $this->xpath->query(ReTidy::get_html_namespace() . 'ul[' . $ul_count . ']', $new_node_cell);
					foreach($ul_to_keeps as $ul_to_keep) {  }
					// delete everything before
					$previousSiblings = ReTidy::getPreviousSiblings($ul_to_keep);
					foreach($previousSiblings as $previousSibling) {
						if($previousSibling->nodeType === 3 || $previousSibling->nodeType === 5 || $previousSibling->nodeType === 6 || $previousSibling->nodeType === 8) {
							$previousSibling->nodeValue = "";
						}
						if($previousSibling->nodeType === 1) {
							$previousSibling->setAttribute('deleteme', 'y');
						}
					}
					// delete from the next <ul> on.
					$nextUl = ReTidy::nextElement($ul_to_keep, "ul");
					if($nextUl) {
						$nextSiblings = ReTidy::getNextSiblings($nextUl);
						$nextUl->setAttribute('deleteme', 'y');
						foreach($nextSiblings as $nextSibling) {
							if($nextSibling->nodeType === 3 || $nextSibling->nodeType === 5 || $nextSibling->nodeType === 6 || $nextSibling->nodeType === 8) {
								$nextSibling->nodeValue = "";
							}
							if($nextSibling->nodeType === 1) {
								$nextSibling->setAttribute('deleteme', 'y');
							}
						}						
					}
				}
				$ul_count--;
			}
			$make_new_row = false;
			foreach($cells as $cell) {
				$first_uls = $this->xpath->query(ReTidy::get_html_namespace() . 'ul[1]', $cell);
				foreach($first_uls as $first_ul) {
					$previousElement = ReTidy::previousElement($first_ul);
					if($previousElement) { // then we need to keep a row for the stuff before the lists.
						$keep_row = true;
						break;
					}
				}
			}
			if($keep_row) {
				// delete from the next <ul> on.
				$tr_cells = $this->xpath->query(ReTidy::get_html_namespace() . 'th | ' . ReTidy::get_html_namespace() . 'td', $tr);
				foreach($tr_cells as $tr_cell) {
					$first_uls = $this->xpath->query(ReTidy::get_html_namespace() . 'ul[1]', $tr_cell);
					foreach($first_uls as $nextUl) {  }
					$nextSiblings = ReTidy::getNextSiblings($nextUl);
					$nextUl->setAttribute('deleteme', 'y');
					foreach($nextSiblings as $nextSibling) {
						if($nextSibling->nodeType === 3 || $nextSibling->nodeType === 5 || $nextSibling->nodeType === 6 || $nextSibling->nodeType === 8) {
							$nextSibling->nodeValue = "";
						}
						if($nextSibling->nodeType === 1) {
							$nextSibling->setAttribute('deleteme', 'y');
						}
					}
				}
			} else {
				$tr->setAttribute('deleteme', 'y');
			}
		}
		
		// default attributes for tables
		$query = '//' . ReTidy::get_html_namespace() . 'table';
		$tables = $this->xpath->query($query);
		foreach($tables as $table) {
			$table->setAttribute('border', '1');
			$table->setAttribute('cellpadding', '4');
		}

		$arrayMicrosoftTableStylesToDelete = array(
		'width',
		'height',
		'border',
		'border-left',
		'border-right',
		'border-bottom',
		'border-top',
		'border-collapse',
		);
		$arrayMicrosoftTableAttributesToDelete = array(
		'width', 
		// unfortunately word's "save as filtered html" outputs widths on all tables cells so there is no way to distinguish 
		// user-applied widths. While we would probably like to apply percent widths (instead of static pixel widths), this will be left
		// to a human to apply widths if needed (based on the template and other factors).
		'height',
		'nowrap',
		);
		// in some cases, we could use height and width styles or attributes to determine what width classes (or styles, if not CLF2) to apply.
		$query = '//' . ReTidy::get_html_namespace() . 'td | //' . ReTidy::get_html_namespace() . 'td | //' . ReTidy::get_html_namespace() . 'table | //' . ReTidy::get_html_namespace() . 'tr';
		$cells = $this->xpath->query($query);
		foreach($cells as $cell) {
			if($cell->hasAttributes()) {
				foreach($cell->attributes as $attribute) {
					foreach($arrayMicrosoftTableAttributesToDelete as $microsoftAttributeName) {
						if($attribute->nodeName === $microsoftAttributeName) {
							$attribute->nodeValue = "stripme";
							break;
						}
					}
					if($attribute->nodeName === "style") {
						// add the style attribute to an array
						foreach($arrayMicrosoftTableStylesToDelete as $microsoftStyle) {
							$attribute->nodeValue = preg_replace('/' . ReTidy::preg_escape($microsoftStyle) . '\s*:\s*[^;]{0,}/is', '', $attribute->nodeValue);
						}
					}
				}
			}
		}
	}

	protected function areSimilarColors($color1, $color2) {
		$color1 = strtolower($color1);
		$color2 = strtolower($color2);
		if($color1 === $color2) {
			return true;
		}
		$red1 = hexdec($color1[0] . $color1[1]);
		$green1 = hexdec($color1[2] . $color1[3]);
		$blue1 = hexdec($color1[4] . $color1[5]);
		$red2 = hexdec($color2[0] . $color2[1]);
		$green2 = hexdec($color2[2] . $color2[3]);
		$blue2 = hexdec($color2[4] . $color2[5]);
		if(
		(abs($red1 - $red2) < 53) &&
		(abs($green1 - $green2) < 53) &&
		(abs($blue1 - $blue2) < 53)
		) {
			return true;
		}
		return false;
	}
	
	protected function set_clf2() {
		$this->clf2 = false;
		foreach($this->config['macro'] as $function) {
			//print('function: ');var_dump($function);
			if(strtolower($function) === "clf2") {
				$this->clf2 = true;
				break;
			}
		}
		if(stripos($this->config_profile, "clf2") !== false) {
			$this->clf2 = true;
		}
		//var_dump(substr_count($this->code, 'clf2'));exit(0);
		if(substr_count($this->code, 'clf2') > 9) {
			$this->clf2 = true;
		}
		if($this->clf2) {
			$this->logMsg('CLF2 has been set');
		}
		//print('$this->clf2: ');var_dump($this->clf2);exit(0);
	}
	
	protected function get_clf2() {
		if(!isset($this->clf2)) {
			ReTidy::set_clf2();
		}
		return $this->clf2;
	}
	
	protected function is_clf2() {
		return ReTidy::get_clf2();
	}
	
	protected function set_CLF($code = false) {
		if($code === false) {
			$code = $this->code;
		}
		//print('here37585696708708<br>');
		$this->CLF = false;
		if(substr_count($code, 'clf2') > 9) {
			//print('here37585696708709<br>');
			$this->CLF = true;
		}
		//var_dump($code);
		if(strpos($code, 'Web Experience Toolkit (WET)') !== false) {
			//print('here37585696708710<br>');
			$this->CLF = true;
		}
	}
	
	protected function get_CLF($code = false) {
		if($code === false) {
			$code = $this->code;
		}
		//print('here37585696708711<br>');
		if(!isset($this->CLF)) {
			//print('here37585696708712<br>');
			ReTidy::set_CLF($code);
		}
		return $this->CLF;
	}
	
	protected function is_CLF($code = false) {
		if($code === false) {
			$code = $this->code;
		}
		return ReTidy::get_CLF($code);
	}
	
	protected function line_wrapping() {
		if($this->config['non_breaking_type'] === 'nbsp' || !$this->config['non_breaking_type'] /* default */) {
			$arrayReplaces = array(
			'&laquo; ' => '&laquo;&nbsp;',
			' &raquo;' => '&nbsp;&raquo;',
			//'« ' => '«&nbsp;',
			//' »' => '&nbsp;»',
			html_entity_decode("&laquo;") . ' ' => html_entity_decode("&laquo;") . '&nbsp;',
			' ' . html_entity_decode("&raquo;") => '&nbsp;' . html_entity_decode("&raquo;"),			
			);
			foreach($arrayReplaces as $search => $replace) {
				$this->code = str_replace($search, $replace, $this->code, $c);
				$this->logMsgIf("[$search]", $c);
			}
		} elseif($this->config['non_breaking_type'] === 'noWrap') {
			//print('this->config[\'macro\']: ');var_dump($this->config['macro']);exit(0);
			// I do not think that we will need to worry about nesting for this
			//print('ReTidy::is_clf2(): ');var_dump(ReTidy::is_clf2());exit(0);
			if(ReTidy::is_clf2()) {
				$this->code = preg_replace('/((' . html_entity_decode("&laquo;") . '|&laquo;)\s+.)(.*?)(.\s+(' . html_entity_decode("&raquo;") . '|&raquo;))/is', '<span class="noWrap">$1</span>$3<span class="noWrap">$4</span>', $this->code, -1, $c);
			} else {
				$this->code = preg_replace('/((' . html_entity_decode("&laquo;") . '|&laquo;)\s+.)(.*?)(.\s+(' . html_entity_decode("&raquo;") . '|&raquo;))/is', '<span style="white-space: nowrap;">$1</span>$3<span style="white-space: nowrap;">$4</span>', $this->code, -1, $c);
			}
			$this->logMsgIf("&laquo; .*? &raquo;", $c);
		}
	}

	protected function DOM_delete_empty_attributes() {
		// tidy would not want to do this, for example, because elements could be styled by their (empty) attributes.
		$query = '//' . ReTidy::get_html_namespace() . '*[@*=""]';
		$tags_with_empty_attribute = $this->xpath->query($query);
		foreach($tags_with_empty_attribute as $tag) {
			$tagName = $tag->nodeName;
			$array_attributes = DTD::getAttributesForElementByType($tagName, "#IMPLIED");
			foreach($tag->attributes as $attribute) {
				if(strlen($attribute->nodeValue) === 0) {
					foreach($array_attributes as $attribute2){
						if($attribute->nodeName === $attribute2) {
							$attribute->nodeValue = "XXX9o9stripme9o9XXX";
							break;
						}
					}					
				}
			}
		}
	}

	protected function delete_empty_tags() {
		$arrayTagNames = array(
		'Heading-1',
		'li_label',
		);
		$entity = DTD::getInline();
		$arrayInlineTags = explode("|", $entity);
		$arrayTagNames = array_merge($arrayTagNames, $arrayInlineTags);
		$entity = DTD::getBlock();
		$entity = str_replace('div|', '', $entity); // exclude <div>s from being deleted
		//var_dump($entity);exit(0);
		$arrayBlockTags = explode("|", $entity);
		$arrayTagNames = array_merge($arrayTagNames, $arrayBlockTags);
		// apparently tidy removes empty block tags... although not empty tags with attributes.
		// there may be a reason for tidy's behaviour; in which case, this part of this function 
		// could be disabled in the configuration file.
		$arrayIgnoreTagNames = DTD::getElementsByContent("EMPTY");
		foreach($arrayTagNames as $tagName) {
			foreach($arrayIgnoreTagNames as $ignoreTagName) {
				if($tagName === $ignoreTagName) {
					continue 2;
				}
			}
			if($tagName === "a") {
				preg_match_all('/<a([^<>]*?)(\s*\/>|><\/a>)/is', $this->code, $a_matches);
				foreach($a_matches[1] as $index => $a_match) {
					if((strpos($a_match, "id=") !== false) || (strpos($a_match, "name=") !== false)) {
						// then leave it alone
					} else {
						$this->code = str_replace($a_matches[0][$index], '', $this->code, $e);
						$this->logMsgIf("[" . htmlentities($a_matches[0][$index]) . "]", $e);
					}
				}
			} else {
				$search = '<' . $tagName . '( [^<>]*){0,1}\s*\/>';
				$search2 = '<' . $tagName . '( [^<>]*){0,1}>\s*<\/' . $tagName . '>';
				$this->code = preg_replace('/' . $search . '/is', '', $this->code, -1, $c);
				$this->code = preg_replace('/' . $search2 . '/is', '', $this->code, -1, $d);
				$this->logMsgIf("[" . htmlentities($search) . "]", $c);
				$this->logMsgIf("[" . htmlentities($search2) . "]", $d);
			}
		}
	}

	protected function dom_parse_lists() {
		$this->logMsg("=== Parsing lists === ");
		$query = '//' . ReTidy::get_html_namespace() . implode(' | //' . ReTidy::get_html_namespace(), $this->config['parse_lists_container_tags']);
		$tags = $this->xpath->query($query);
		$this->logMsg("Containers: " . $tags->length);
		$allowed_chars = '((\-|\*|\.|\)|_|\x{2660}|\x{2663}|\x{2665}|\x{2666}|\x{25D0}|\x{25E6}|\x{F0AB}|\x{F076}){1,2})';
		$lists_array = array();
		foreach($tags as $tag) {
			$tmp2 = $fuzzy_list_type = $fuzzy_list_started = $list_type = false;
			$list_chars = '';
			$list_elems = array();
			foreach ($tag->childNodes as $child) {
				if($child->nodeType != XML_ELEMENT_NODE)
					continue;

				$item_found = $item_nr = $item_type = false;
				$item_chars = '';

				if(in_array($child->nodeName, $this->config['parse_lists_tags'])) {
					$content = $child->firstChild->nodeValue;
					$content2 = $child->textContent;
					$table_tabs = 0;
					if($this->config['parse_table_tabs'])
						$table_tabs = substr_count($content2, "\t");

					$matches = array();
					if(preg_match('/^\s*([\d\p{N}]{1,2})\s*' . $allowed_chars . '/iu', $content, $matches)) {
						$item_type = 'ol-1';
						$item_nr = $matches[1];
						$item_chars = $matches[2];
					} else if(preg_match('/^\s*([a-z\p{L}])\s*' . $allowed_chars . '\s+/iu', $content, $matches)) {
						$item_type = 'ol-a';
						$item_nr = $matches[1];
						$item_chars = $matches[2];
					} else if(preg_match('/^\s*' . $allowed_chars . '/iu', $content, $matches)) {
						$item_type = 'ul';
						$item_nr = false;
						$item_chars = $matches[1];
					} else if($table_tabs > 0) {
						$item_type = 'table-tabs';
						$item_nr = false;
						$item_chars = $table_tabs;
					} else if($this->config['parse_fuzzy_lists'] && preg_match('/:\s*$/', $content2)) {
						$fuzzy_list_started = true;
						$item_chars = ':';
					} else if($fuzzy_list_started && preg_match('/(;|\.)\s*$/iu', $content2, $matches)) {
						$tmp = preg_match('/^[\s\d\p{N}\p{P}]*[a-z\p{Ll}]/u', $content);
						if(!$fuzzy_list_type) {
							if($tmp)
								$fuzzy_list_type = 'a';
							else
								$fuzzy_list_type = 'A';
						}
						if($tmp2) {
							$tmp2 = false;
							if($matches[1] == '.')
								$fuzzy_list_type = $fuzzy_list_started = false;
						}
						if($fuzzy_list_started && $matches[1] == '.' && !$tmp) {
							if($fuzzy_list_type == 'a')
								$fuzzy_list_type = $fuzzy_list_started = false;
							else
								$tmp = 2;
						}
						if($fuzzy_list_started) {
							$item_type = 'fuzzy-ul';
							$item_nr = false;
							$item_chars = ';';
						}
						if($tmp == 2) {
							if(!isset($list_elems[1]))
								$tmp2 = true;
							else
								$fuzzy_list_type = $fuzzy_list_started = false;
						}
					}
				}
				if($item_nr && $list_type && isset($list_elems[$item_nr]))
					$item_found = true;

				if(!$list_type && $item_type) {
					$list_type = $item_type;
					$list_chars = $item_chars;
				}
				if($item_type && $list_type && $item_type == $list_type && $item_chars == $list_chars) {
					if($item_type == 'ul' || $item_type == 'fuzzy-ul' || $item_type == 'table-tabs')
						$list_elems[] = $child;
					else
						$list_elems[$item_nr] = $child;
				}
				if($list_type && $item_type && ($item_type != $list_type || $item_chars != $list_chars || $item_found)) {
					if(count($list_elems) > 1 || (count($list_elems) == 1 && $list_type == 'ul' && $this->config['parse_ulist_1li'])) {
						$lists_array[] = array('type' => $list_type, 'elems' => $list_elems, 'chars' => $list_chars);
					}
					$list_type = $item_type;
					$list_chars = $item_chars;
					$list_elems = array();
					$list_started = false;
					if($item_chars != ':')
						$fuzzy_list_started = $fuzzy_list_type = false;
					if($item_type == 'ul' || $item_type == 'fuzzy-ul' || $item_type == 'table-tabs')
						$list_elems[] = $child;
					else
						$list_elems[$item_nr] = $child;
				}
				if($list_type && !$item_type) {
					if(count($list_elems) > 1 || (count($list_elems) == 1 && $list_type == 'ul' && $this->config['parse_ulist_1li'] === true)) {
						$lists_array[] = array('type' => $list_type, 'elems' => $list_elems, 'chars' => $list_chars);
					}
					$list_started = $list_type = false;
					$list_chars = '';
					$list_elems = array();
					if($item_chars != ':')
						$fuzzy_list_started = $fuzzy_list_type = false;
				}
			}
		}
		$c_li = 0;
		foreach($lists_array as $i => $list) {
			// this is used for ltrimming any LI (to eliminate the LI char)
			$regex = false;
			if($list['type'] == 'ul' || $list['type'] == 'fuzzy-ul') {
				$container = $this->dom->createElementNS(self::$xhtmlns, 'ul');
				if($list['type'] == 'ul')
					$regex = '/^\s*'.$allowed_chars.'\s*/iu';
			} else if($list['type'] == 'ol-a' || $list['type'] == 'ol-1') {
				$container = $this->dom->createElementNS(self::$xhtmlns, 'ol');
				if($list['type'] == 'ol-a') {
					$container->setAttribute('type', 'a');
					$regex = '/^\s*([a-z\p{L}])\s*'.$allowed_chars.'\s+/iu';
				} else
					$regex = '/^\s*([\d\p{N}]{1,2})\s*'.$allowed_chars.'\s*/iu';
			} else if($list['type'] == 'table-tabs')
				$container = $this->dom->createElementNS(self::$xhtmlns, 'table');
			else
				continue;

			// $regex_prev is used for matching "inline list items" in paragraphs that are previousSiblings of ULs
			$regex_prev = '/(:)\s+'.preg_quote($list['chars']).'\s+/u';

			$regex_li = false;
			if($list['chars'] == '-' || $list['chars'] == '*')
				$regex_li = '/(;)\s+'.preg_quote($list['chars']).'\s+/u';
			else
				$regex_li = '/\s+'.preg_quote($list['chars']).'\s+/u';

			// we will only use the above regular expressions *if* $parse_ulist_inline is true, and current $list['type'] is 'ul', and the $list['chars'] is NOT '.'
			if($list['chars'] == '.' || $list['type'] != 'ul' || !$this->config['parse_ulist_inline'])
				$regex_prev = $regex_li = false;

			if($regex_li)
				$regex_li_str = "\\1\x01";

			if($list['type'] == 'table-tabs')
			{
				$regex_li = '/\t+/';
				$regex_li_str = "\x05";
				$li_elem_name = 'td';
			} else
				$li_elem_name = 'li';

			$pNode = false;

			foreach($list['elems'] as $elem) {
				$c_li++;
				$li = $this->dom->createElementNS(self::$xhtmlns, $li_elem_name);
				if($regex)
					$elem->firstChild->nodeValue = preg_replace($regex, '', $elem->firstChild->nodeValue);

				foreach($elem->childNodes as $child) {
					$clone = $child->cloneNode(true);
					if($regex_li) {
						if($clone->hasChildNodes())
							$tmp = $clone->firstChild;
						else
							$tmp = $clone;

						$tmp->nodeValue = preg_replace($regex_li, $regex_li_str, $tmp->nodeValue);
					}
					$li->appendChild($clone);
				}

				if(!$pNode) {
					$pNode = $elem->parentNode;
					$pNode->insertBefore($container, $elem);
				}

				$pNode->removeChild($elem);

				if($list['type'] == 'table-tabs') {
					$tmp_tr = $this->dom->createElementNS(self::$xhtmlns, 'tr');
					$tmp_tr->appendChild($li);
					$container->appendChild($tmp_tr);
				} else
					$container->appendChild($li);
			}

			$prev = $container->previousSibling;
			if($prev != null && $prev->nodeType != XML_ELEMENT_NODE)
				$prev = $prev->previousSibling;

			if($regex_prev && $prev != null && $prev->nodeName == 'p') {
				foreach($prev->childNodes as $child) {
					if($child->hasChildNodes())
						$tmp = $child->firstChild;
					else
						$tmp = $child;

					$tmp->nodeValue = preg_replace($regex_prev, "\\1\x03", $tmp->nodeValue, -1, $c);
					if($c > 0)
						break;
				}
			}
		}

		$this->logMsg("parse_lists DOM " . count($lists_array) .  " lists $c_li LIs ");

		if($this->config['parse_table_tabs']) {
			$this->code = str_replace("\x05", '</td><td>', $this->code, $c);
			$this->logMsg("parse_table_tabs $c TDs ");
		}

		if($this->config['parse_ulist_inline']) {
			$this->code = str_replace("\x01", '</li><li>', $this->code, $c);
			$this->code = preg_replace('/\x03(.+?)<\/p>\s*<ul>/is', '</p><ul><li>\1</li>', $this->code, -1, $ct);
			$this->logMsg("parse_ulist_inline $c LIs $ct ULs ");
		}

		if($this->config['parse_lists_combine_br_tags'])
			$this->combine_br_tags();

		if($this->config['tidy_after_parse_lists'])
			$this->tidy_code();

		$this->logMsg("=== Lists parsed === ");

		return true;
	}

	private $toc_ids = false;
	protected function dom_toc_add ()
	{
		if(!$this->config['add_toc'])
			return false;

		$this->logMsg("=== TOC generation === ");

		if(!$this->dom || !$this->xpath)
			$this->dom_init();

		if(!$this->dom || !$this->xpath)
			return false;

		$tags = $this->xpath->query('//' . ReTidy::get_html_namespace() . 'h1 | //' . ReTidy::get_html_namespace() . 'h2 | //' . ReTidy::get_html_namespace() . 'h3 | //' . ReTidy::get_html_namespace() . 'h3 | //' . ReTidy::get_html_namespace() . 'h4 | //' . ReTidy::get_html_namespace() . 'h5 | //' . ReTidy::get_html_namespace() . 'h6');

		$this->logMsg("Heading nodes: " . $tags->length);

		$plvl = false;

		$levels = array(
			0 => $this->dom->createElementNS(self::$xhtmlns, 'ul'),
		);

		$this->toc_ids = array();
		$c = 0;

		foreach($tags as $tag)
		{
			$nodeName = $tag->nodeName;
			$lvl = $nodeName{1};

			if($nodeName{0} != 'h' || !is_numeric($lvl))
				continue;

			$uplvl = $lvl-1;
			if($plvl && $lvl < $plvl)
			{
				for($y = $lvl; $y < $plvl; $y++)
					unset($levels[$y]);
			}

			if(!$plvl && $lvl > 1)
			{
				for($y = 1; $y < $lvl; $y++)
				{
					$levels[$y] = $this->dom->createElementNS(self::$xhtmlns, 'ul');
					$li2 = $this->dom->createElementNS(self::$xhtmlns, 'li');
					$li2->appendChild($this->dom->createTextNode('Heading '.$y));
					$li2->appendChild($levels[$y]);
					$levels[($y-1)]->appendChild($li2);
				}
			}

			$id = $tag->getAttribute('id');

			if($this->config['toc_autolink'] && (!$id || $id == null))
			{
				$id = $this->toc_genid($tag->textContent, $c);
				$tag->setAttribute('id', $id);
			}

			$li = $this->dom->createElementNS(self::$xhtmlns, 'li');
			$txt = $this->dom->createTextNode($tag->textContent);
			if(!$txt || $txt == null || $txt == '')
				$txt = 'item '.$i;

			if($this->config['toc_autolink'])
			{
				$a = $this->dom->createElementNS(self::$xhtmlns, 'a');
				$a->setAttribute('href', '#'.$id);
				$a->appendChild($txt);
				$li->appendChild($a);
			} else
				$li->appendChild($txt);

			if(!isset($levels[$uplvl]))
			{
				for($y = min($uplvl, count($levels)); $y < $lvl; $y++)
				{
					$levels[$y] = $this->dom->createElementNS(self::$xhtmlns, 'ul');
					if($levels[($y-1)]->lastChild == null)
					{
						$li2 = $this->dom->createElementNS(self::$xhtmlns, 'li');
						$li2->appendChild($this->dom->createTextNode('Heading '.$y));
						$li2->appendChild($levels[$y]);
						$levels[($y-1)]->appendChild($li2);
					} else
						$levels[($y-1)]->lastChild->appendChild($levels[$y]);
				}
			}
			$levels[$uplvl]->appendChild($li);

			$plvl = $lvl;
			$c++;
		}

		$body = $this->dom->getElementsByTagName('body');
		$body = $body->item(0);
		$body->insertBefore($levels[0], $body->firstChild);

		$this->logMsg("TOC ".count($this->toc_ids)." IDs $c LIs ");

		if($this->config['tidy_after_toc'])
			$this->tidy_code();

		$this->logMsg("=== TOC generated === ");

		return true;
	}

	private function toc_genid ($txt, $n)
	{
		if($this->config['toc_autolink'] != '#text')
			return $this->config['toc_autolink'] . $n;

		if(!isset($this->toc_ids) || !is_array($this->toc_ids))
			return 'toc_auto_' . $n;

		if(is_callable('mb_strtolower'))
			$id = mb_strtolower($txt);
		else
			$id = strtolower($txt);

		$id = preg_replace('/[\p{P}]/u', '-', $id);
		$id = str_replace(array(' ', '_'), '-', $id);
		if(is_callable('mb_convert_encoding'))
			$id = mb_convert_encoding($id, 'ascii');
		$id = preg_replace('/[^a-z0-9\-]/', '-', $id);
		$id = preg_replace('/\-+/', '-', $id);
		$id = trim($id, '-');
		$id = preg_replace('/^\d+/', '', $id);
		$id = trim($id, '-');

		if(!isset($id{1}))
			$id = 'hid-' . $n;

		if(in_array($id, $this->toc_ids))
			$id .= '-'.$n;

		$this->toc_ids[] = $id;

		return $id;
	}

	protected function style_cdata() {
		$this->code = preg_replace('/(<style[^<>]*>)(\s*)\/\*<!\[CDATA\[\*\/(.*?)\/\*\]\]>\*\/(\s*)(<\/style>)/is', '$1$3$5', $this->code);
		return true;
	}

	protected function final_regex() {
		if(!is_array($this->config['final_regex'])) return false;

		$c = $ct = 0;
		foreach($this->config['final_regex'] as $key => $val) {
			$this->code = preg_replace($val[0], $val[1], $this->code, -1, $c);
			$this->logMsg("final_regex[$key] $c ");
			$ct += $c;
		}
		$this->code = preg_replace('/(<style[^<>]*>)(\s*)\/\*<!\[CDATA\[\*\/(\s*)([^<>\r\n]*)(\s*)\/\*\]\]>\*\/(\s*)(<\/style>)/is', '$1$4$7', $this->code);
		$this->logMsgIf("final_regex", $ct);
		return true;
	}
	
	protected function dogrib() {
		foreach($this->config['dogrib'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $sum);
		}
		$this->logMsg("dogrib $sum ");
		return true;
	}
	
	protected function basicstripID ()
	{
		if(!is_array($this->config['basicstripID']))
			return false;

		$c = $ct = 0;
		foreach($this->config['basicstripID'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("basicstripID[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("basicstripID", $ct);
		return true;
	}

	protected function layout_tables () {
		if(!is_array($this->config['layout_tables'])) return false;

		$c = $ct = $cnt = 0;
		preg_match_all('/<table[^>]*>.*?<\/table>/is', $this->code, $tables);		
		foreach($tables[0] as $index => $table) {
			if(preg_match('/<table[^>]*>.+<table/is', $table)) {
				// Give up since we cannot guarantee working on the appropriate start and end tags
				// because we are not using the document object model:
				// see OM.php
				continue;
			}
			
			if (preg_match('/<table[^>]*summary="[^"]*"[^>]*>/is', $table) || 
			preg_match('/<p[^>]*>(<strong>|).*?Table(au|) [0-9]{1,3}( |):.+?(<\/strong>|)<\/p>\s*<table[^>]*>/is', $table) ||
			preg_match('/<p[^>]*>(<strong>|).*?<a name="tab.+?(<\/strong>|)<\/p>\s*<table[^>]*>/is', $table) ||
			preg_match('/<p[^>]*>(<strong>|).*?<a name="t.+?(<\/strong>|)<\/p>\s*<table[^>]*>/is', $table) ||
			preg_match('/<p[^>]*>(<strong>|).*?<a id="tab.+?(<\/strong>|)<\/p>\s*<table[^>]*>/is', $table) ||
			preg_match('/<p[^>]*>(<strong>|).*?<a id="t.+?(<\/strong>|)<\/p>\s*<table[^>]*>/is', $table)) {
				continue;
			}
			$initial_table = $table;
			/*
			$biggest_width_for_table = "0";
			$width_type1 = "";
			preg_match_all('/<tr[^>]>.*?<\/tr>/is', $table, $trs);
			foreach($trs[0] as $index => $tr) {
				preg_match_all('/<(td|th)[^>]*( width="([^"]*)")[^>]*>/is', $tr, $cell_widths1);
				preg_match_all('/<(td|th)[^>]*( style="width:([^;]*);")[^>]*>/is', $tr, $cell_widths2);
				$biggest_width1 = "0";
				$width_type1 = "";
				$biggest_width2 = "0";
				$width_type2 = "";				
				foreach($cell_widths1[3] as $index => $cell_width) {
					preg_match('/([0-9]*)([^0-9]*)/is', $cell_width, $width_match);
					$width_type1 = $width_match[2];
					if ($width_match[1] > $biggest_width1) {
						$biggest_width1 = $width_match[1];
					}
				}
				foreach($cell_widths2[3] as $index => $cell_width) {
					preg_match('/([0-9]*)([^0-9]*)/is', $cell_width, $width_match);
					$width_type2 = $width_match[2];
					if ($width_match[1] > $biggest_width2) {
						$biggest_width2 = $width_match[1];
					}
				}
				if ($biggest_width1 != 0) {
					if ($width_type1 == "") {
						$width_type1 = "px";
					}
					$biggest_width_for_tr = $biggest_width1;
				} else {
					if ($width_type2 == "") {
						$width_type2 = "px";
					}
					$biggest_width_for_tr = $biggest_width2;
				}
				
				$biggest_width_for_tr			
			}
			*/
			foreach($this->config['layout_tables'] as $search => $replace) {
				$table = preg_replace("/" . $search . "/is", $replace, $table, -1, $c);
				//$this->logMsgIf("layout_tables[" . htmlentities($search) . "]", $c);
				//$ct += $c;
			}
			
			preg_match('/<div style="width:100%;">\s*<div[^>]* style="clear:both;">\s*<div([^>]*) style="float:left;[^"]*">/is', $table, $first_cell_attributes);

			if (preg_match('/width:([^;]*);/is', $first_cell_attributes[1], $first_cell_width)){
				$table = preg_replace(
				'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)">/is', 
				'<div$1 style="clear:both;">$2<div$3 style="float:left;$4width:' . $first_cell_width[1] . ';">', 
				$table);
			}
			
			if(preg_match('/class="[^"]*(width[0-9]{1,3})[^"]*"/is', $first_cell_attributes[1], $first_cell_width)) {
				$table = preg_replace(
				'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)">/is', 
				'<div$1 style="clear:both;">$2<div$3 style="float:left;$4" class="' . $first_cell_width[1] . '">', 
				$table);
			}
			/*
			preg_match('/<div style="width:100%;">\s*<div[^>]* style="clear:both;">\s*<div[^>]* style="float:left;[^"]*"[^>]*>.*?<\/div>\s*<div([^>]*) style="float:left;[^"]*"([^>]*)>/is', $table, $second_cell_attributes);						
			
			if (preg_match('/width:([^;]*);/is', $second_cell_attributes[1], $second_cell_width)){
				$table = preg_replace(
				'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)">(.*?)<\/div>(\s*)<div([^>]*) style="float:left;([^"]*)">/is', 
				'<div$1 style="clear:both;">$2<div$3 style="float:left;$4">$5<\/div>$6<div$7 style="float:left;$8' . $second_cell_width[1] . ';">', 
				$table);
			}			
			
			if(preg_match('/class="[^"]*(width[0-9]{1,3})[^"]*"/is', $second_cell_attributes[1], $second_cell_width)) {
				$table = preg_replace(
				'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)"([^>]*)>(.*?)<\/div>(\s*)<div([^>]*) style="float:left;([^"]*)"([^>]*)>/is', 
				'<div$1 style="clear:both;">$2<div$3 style="float:left;$4"$5>$6<\/div>$7<div$8 style="float:left;$9"$10 class="' . $second_cell_width[1] . '">', 
				$table);
			}
			if(preg_match('/class="[^"]*(width[0-9]{1,3})[^"]*"/is', $second_cell_attributes[2], $second_cell_width)) {
				$table = preg_replace(
				'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)"([^>]*)>(.*?)<\/div>(\s*)<div([^>]*) style="float:left;([^"]*)"([^>]*)>/is', 
				'<div$1 style="clear:both;">$2<div$3 style="float:left;$4"$5>$6<\/div>$7<div$8 style="float:left;$9"$10 class="' . $second_cell_width[1] . '">', 
				$table);
			}						
			*/
			$this->code = str_replace($initial_table, $table, $this->code, $ct);
			$cnt += $ct;
		}
		$this->logMsgIf("layout_tables", $cnt);
		return true;
	}
	
	protected function DOM_CLF2 () {
		$query = '//' . ReTidy::get_html_namespace() . 'li';
		$lis = $this->xpath->query($query);
		foreach($lis as $li) {
			if($li->hasAttributes()) {
				foreach ($li->attributes as $attribute) {
					if ($attribute->nodeName === "type") {
						$list_style = "";
						if ($attribute->nodeValue === "disc") {
							$list_style = "disc";
						} elseif ($attribute->nodeValue === "square") {
							$list_style = "square";
						} elseif ($attribute->nodeValue === "circle") {
							$list_style = "circle";
						} elseif ($attribute->nodeValue === "none") {
							$list_style = "noBullet";
						}	
						if($list_style != "") {
							$ul = $li->parentNode;
							if ($ul->hasAttributes()) {
								foreach ($ul->attributes as $ul_attribute) {
									if ($ul_attribute->nodeName === "class") {
										if(strpos($ul_attribute->nodeValue, " $list_style ") != false) {
											// it is already there; do nothing.
										} else {
											$ul_attribute->nodeValue .= " $list_style";
										}
									}
								}
							} else {
								$ul->setAttribute('class', '$list_style');
							}
							// in the rare case where <li>s have different type attribute values
							// in the same list, then the last one shall obtain (bacause of the cascading nature
							// of the styles
						}
						$li->removeAttribute($attribute);
					}
				}
			}
		}
		
		$e = 0;
		$query = '//' . ReTidy::get_html_namespace() . 'span';
		$spans = $this->xpath->query($query);	
		foreach($spans as $span) {
			if($span->hasAttributes()) {
				foreach ($span->attributes as $attribute) {
					if ($attribute->nodeName === "class") {
						while (strpos($attribute->nodeValue, 'align') != false) {
							// strip aligns on spans 
							$attribute->nodeValue = preg_replace('/align(Top|Bottom|)(Left|Center|Right)/', '', $attribute->nodeValue, -1, $c);
							$attribute->nodeValue = preg_replace('/align(Top|Bottom)(Left|Center|Right|)/', '', $attribute->nodeValue, -1, $d);
							$e += $c;
							$e += $d;							
						}
					}
				}
			}
		}
		$this->logMsgIf("DOM_CLF2[alignment on spans]", $e);
		
		// change border attributes to styles on elements except tables
		$query = '//@border';
		$border_attributes = $this->xpath->query($query);
		foreach($border_attributes as $border_attribute) {
			$parentNode = $border_attribute->parentNode;
			if($parentNode->nodeName === "table") {
				continue;
			}
			ReTidy::addStyleWithoutOverwrite($parentNode, "border: " . $border_attribute->nodeValue . "px solid;");
			$border_attribute->nodeValue = "stripme";
		}
		// change height and width attributes to styles on elements except images
		$query = '//@height';
		$height_attributes = $this->xpath->query($query);
		foreach($height_attributes as $height_attribute) {
			$parentNode = $height_attribute->parentNode;
			if($parentNode->nodeName === "img") {
				continue;
			}
			preg_match('/[0-9%]*/', $height_attribute->nodeValue, $height_attribute_matches);
			if(strlen($height_attribute_matches[0]) === strlen($height_attribute->nodeValue)) {
				if($height_attribute->nodeValue[strlen($height_attribute->nodeValue)-1] === "%") {
					ReTidy::addStyleWithoutOverwrite($parentNode, "height: " . substr($height_attribute->nodeValue, 0, strlen($height_attribute->nodeValue)-1) . "%;");			
				} else {
					ReTidy::addStyleWithoutOverwrite($parentNode, "height: " . $height_attribute->nodeValue . "px;");
				}
				$height_attribute->nodeValue = "stripme";
			} else {
				// it is wierd
			}
		}
		$query = '//@width';
		$width_attributes = $this->xpath->query($query);
		foreach($width_attributes as $width_attribute) {
			$parentNode = $width_attribute->parentNode;
			if($parentNode->nodeName === "img") {
				continue;
			}
			preg_match('/[0-9%]*/', $width_attribute->nodeValue, $width_attribute_matches);
			if(strlen($width_attribute_matches[0]) === strlen($width_attribute->nodeValue)) {
				if($width_attribute->nodeValue[strlen($width_attribute->nodeValue)-1] === "%") {
					ReTidy::addStyleWithoutOverwrite($parentNode, "width: " . substr($width_attribute->nodeValue, 0, strlen($width_attribute->nodeValue)-1) . "%;");			
				} else {
					ReTidy::addStyleWithoutOverwrite($parentNode, "width: " . $width_attribute->nodeValue . "px;");
				}
				$width_attribute->nodeValue = "stripme";
			} else {
				// it is wierd
			}
		}
		// images must have an alt attribute
		$query = '//' . ReTidy::get_html_namespace() . 'img';
		$images = $this->xpath->query($query);
		foreach($images as $image) {
			if(ReTidy::getAttribute($image, "alt")) {
				// it already has one
			} else {
				$image->setAttribute("alt", "");
			}
		}
		
		// default attributes for tables
		$query = '//' . ReTidy::get_html_namespace() . 'table';
		$tables = $this->xpath->query($query);
		foreach($tables as $table) {
			ReTidy::addClassWithoutOverwrite($table, "widthFull");
		}		
		
		// since the default alignment for <th>s in different browsers differs, we force it.
		$query = '//' . ReTidy::get_html_namespace() . 'th';
		$ths = $this->xpath->query($query);
		foreach($ths as $th) {
			$class_attribute = ReTidy::getAttribute($th, 'class');
			if($class_attribute) {
				preg_match_all('/align\w*(Left|Center|Right)/', $class_attribute->nodeValue, $matches);
				preg_match_all('/normalize/', $class_attribute->nodeValue, $matches2);
				if(sizeof($matches[0]) > 0) {
					// do nothing since it already has alignment
				} else {
					ReTidy::addClassWithoutOverwrite($th, 'alignLeft');
				}
				if(sizeof($matches2[0]) > 0) {
					// do nothing since it already is normalized
				} else {
					//ReTidy::addClassWithoutOverwrite($th, 'normalize');
					// we cannot assume that this class exists
					if($this->config['normalize_th'] !== false && $this->config['strict_accessibility_level'] < 2) {
						ReTidy::addStyleWithoutOverwrite($th, 'font-weight: normal;');
					}
				}				
			} else {
				ReTidy::addClassWithoutOverwrite($th, 'alignLeft');
				//ReTidy::addClassWithoutOverwrite($th, 'normalize');
				// we cannot assume that this class exists
				if($this->config['normalize_th'] !== false && $this->config['strict_accessibility_level'] < 2) {
					ReTidy::addStyleWithoutOverwrite($th, 'font-weight: normal;');
				}
			}
		}
		
		// background-color
		$arrayCLF2BaseColors = array(
		// order matters; black is after grey
		'redBG' => 'FF0000',
		'blueBG' => '0000FF',
		'greenBG' => '009933',
		'lightgreyBG' => 'CCCCCC',
		//'deepyellowBG' => 'FFCC33',
		'blackBG white' => '000000',
		'whiteBG' => 'FFFFFF',
		);
		$array_color_names = array();
		$array_colorname_tab_color = explode("\r\n", file_get_contents('css' . DS . 'color_names.txt'));
		foreach($array_colorname_tab_color as $colorname_tab_color) {
			$colorname = substr($colorname_tab_color, 0, strpos($colorname_tab_color, "	"));
			$color2 = substr($colorname_tab_color, strpos($colorname_tab_color, "	") + 1);			
			$array_color_names[] = array($colorname, $color2);
		}
		$query = '//@style';
		$style_attributes = $this->xpath->query($query);
		foreach($style_attributes as $style_attribute) {
			if($attribute->nodeValue === "XXX9o9stripme9o9XXX") {
				continue;
			}
			preg_match('/background(\-color){0,1}\s*:\s*([^;]*);/s', $style_attribute->nodeValue, $matches1);
			if(sizeof($matches1) > 0) {
				$color = trim($matches1[2]);
				if(strpos($color, "#") === 0) {
					$color = substr($color, 1);
				}
				if(strlen($color) === 3) {
					preg_match('/[0-9a-f]{3}/i', $color, $matches3);
					if(sizeof($matches3) > 0) { // then it is a three-character RGB value
						$color = $color[1] . $color[1] . $color[2] . $color[2] . $color[3] . $color[3];
					}
				}
				preg_match('/[0-9a-f]{6}/i', $color, $matches4);
				if(sizeof($matches4) > 0) { // then it is a six-character RGB value
					foreach($arrayCLF2BaseColors as $class_name => $color3) {
						if(ReTidy::areSimilarColors($color, $color3)) {
							ReTidy::addClassWithoutOverwrite($style_attribute->parentNode, $class_name);
							$style_attribute->nodeValue = ReTidy::str_replace_first($matches1[0], '', $style_attribute->nodeValue);
							break;
						}
					}
					if($this->config['strict_accessibility_level'] > 0) { // then just make it grey
						ReTidy::addClassWithoutOverwrite($style_attribute->parentNode, 'lightgreyBG');
						$style_attribute->nodeValue = ReTidy::str_replace_first($matches1[0], '', $style_attribute->nodeValue);
					}
				} else { // then it is a color name
					foreach($array_color_names as $index => $value) {
						$colorname = $value[0];
						$color2 = $value[1];
						if($colorname === $color) {
							$color = $color2;
							break;
						}
					}
					foreach($arrayCLF2BaseColors as $class_name => $color3) {
						if(ReTidy::areSimilarColors($color, $color3)) {
							ReTidy::addClassWithoutOverwrite($style_attribute->parentNode, $class_name);
							$style_attribute->nodeValue = ReTidy::str_replace_first($matches1[0], '', $style_attribute->nodeValue);							
							break;
						}
					}
					if($this->config['strict_accessibility_level'] > 0) { // then just make it grey
						ReTidy::addClassWithoutOverwrite($style_attribute->parentNode, 'lightgreyBG');
						$style_attribute->nodeValue = ReTidy::str_replace_first($matches1[0], '', $style_attribute->nodeValue);
					}
				}
			}
			// seems like unnecessary repetition
			/*preg_match('/background\s*:\s*([^;]*);/s', $style_attribute->nodeValue, $matches1);
			if(sizeof($matches1) > 0) {
				$color = trim($matches1[1]);
				if(strpos($color, "#") === 0) {
					$color = substr($color, 1);
				}
				if(strlen($color) === 3) {
					preg_match('/[0-9a-f]{3}/i', $color, $matches3);
					if(sizeof($matches3) > 0) { // then it is a three-character RGB value
						$color = $color[1] . $color[1] . $color[2] . $color[2] . $color[3] . $color[3];
					}
				}
				preg_match('/[0-9a-f]{6}/i', $color, $matches4);
				if(sizeof($matches4) > 0) { // then it is a six-character RGB value
					foreach($arrayCLF2BaseColors as $class_name => $color3) {
						if(ReTidy::areSimilarColors($color, $color3)) {
							ReTidy::addClassWithoutOverwrite($style_attribute->parentNode, $class_name);
							$style_attribute->nodeValue = ReTidy::str_replace_first($matches1[0], '', $style_attribute->nodeValue);							
							break;
						}
					}
				} else { // then it is a color name
					foreach($array_color_names as $index => $value) {
						$colorname = $value[0];
						$color2 = $value[1];
						if($colorname === $color) {
							$color = $color2;
							break;
						}
					}
					foreach($arrayCLF2BaseColors as $class_name => $color3) {
						if(ReTidy::areSimilarColors($color, $color3)) {
							ReTidy::addClassWithoutOverwrite($style_attribute->parentNode, $class_name);
							$style_attribute->nodeValue = ReTidy::str_replace_first($matches1[0], '', $style_attribute->nodeValue);							
							break;
						}
					}					
				}
			}*/
		}		
		return true;
	}
	
	protected function getClassAttribute($node) {
		return ReTidy::getAttribute($node, "class");
	}
	
	protected function getStyleAttribute($node) {
		return ReTidy::getAttribute($node, "style");
	}	
	
	protected function getAttribute($node, $attribute_name) {
		if(ReTidy::isNode($node) && $node->hasAttributes()) {
			foreach($node->attributes as $attribute) {
				if($attribute->nodeName === $attribute_name) {
					return $attribute;
				}
			}
		}
		return false;
	}

	protected function WET() {
		ReTidy::tidy_code();
		
		ReTidy::dom_init();
		ReTidy::DOM_clean_redundant_tags(); // necessitates the addition of post_DOM (compared to CLF2)
		ReTidy::dom_save();
		
		ReTidy::post_DOM();
		
		ReTidy::tidy_code();
	}
	
	protected function quotation_macro() {
		ReTidy::tidy_code();
		
		ReTidy::decode_for_DOM_all_inline();
		
		ReTidy::pre_DOM_quotation();
		
		ReTidy::dom_init();
		ReTidy::DOM_quotation();
		ReTidy::dom_save();

		ReTidy::encode_for_DOM_all();
		
		ReTidy::post_DOM_quotation();
		
		ReTidy::post_DOM();
		
		ReTidy::tidy_code();
		
		ReTidy::combine_inline();
		
		ReTidy::remove_tags_intra_tags(); // for the rare quotations in <title>s
		
	}
	
	protected function pre_DOM_quotation() {
		
		// " ' « » ‘ ’ ‚ “ ” „ ‹ ›
		
		/*
		" 	" 	&#34; 	&#x22; 	&quot;
		' 	' 	&#39; 	&#x27; 	&apos;		
		« 	« 	&#171; 	&#xab; 	&laquo;
		» 	» 	&#187; 	&#xbb; 	&raquo;
		‘ 	‘ 	&#8216; 	&#x2018; 	&lsquo;
		’ 	’ 	&#8217; 	&#x2019; 	&rsquo;
		‚ 	‚ 	&#8218; 	&#x201a; 	&sbquo;
		“ 	“ 	&#8220; 	&#x201c; 	&ldquo;
		” 	” 	&#8221; 	&#x201d; 	&rdquo;
		„ 	„ 	&#8222; 	&#x201e; 	&bdquo;
		‹ 	‹ 	&#8249; 	&#x2039; 	&lsaquo;
		› 	› 	&#8250; 	&#x203a; 	&rsaquo;
		*/
		
		$this->code = preg_replace('/&([^;&\s]+);/is', 'XXX9o9NewQuotesEntityXXX${1}9o9XXX', $this->code);
		
		
		
		// the quotation code was written expecting <q> tags on the outside of characters so force all preexistent ones in the document to be that way.
		$this->code = preg_replace('/(' . $this->leftQuotes . ')(' . $this->nonBreakingSpaceRegex . '){0,}\s*<q>(' . $this->leftQuotes . ')(' . $this->nonBreakingSpaceRegex . '){0,}<q>/is', 'XXX9o9NewTagBeginXXXq9o9XXX$1$2XXX9o9NewTagBeginXXXq9o9XXX$3$4', $this->code);
		$this->code = preg_replace('/(' . $this->leftQuotes . ')(' . $this->nonBreakingSpaceRegex . '){0,}<q>/is', '<q>$1$2', $this->code);
		$this->code = preg_replace('/<\/q>(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightQuotes . ')<\/q>(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightQuotes . ')/is', '$1$2XXX9o9NewTagEndXXXq9o9XXX$3$4XXX9o9NewTagEndXXXq9o9XXX', $this->code);
		$this->code = preg_replace('/<\/q>(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightQuotes . ')/is', '$1$2</q>', $this->code);
		$this->code = str_replace('XXX9o9NewTagBeginXXXq9o9XXX', '<q>', $this->code);
		$this->code = str_replace('XXX9o9NewTagEndXXXq9o9XXX', '</q>', $this->code);
		if($this->config['quotes_style'] === 'omit_characters') {
			$this->code = preg_replace('/<q>(\s*<[^<>]+?>){0,1}\s*(' . $this->leftDoubleQuotes . ')(\s*<[^<>]+?>){0,1}\s*(' . $this->nonBreakingSpaceRegex . '){0,}\s*/is', '<q>$1$3', $this->code);
			$this->code = preg_replace('/\s*(' . $this->nonBreakingSpaceRegex . '){0,}\s*(<[^<>]+?>\s*){0,1}(' . $this->rightDoubleQuotes . ')\s*(<[^<>]+?>\s*){0,1}<\/q>/is', '$2$4</q>', $this->code);
			$this->code = preg_replace('/<q>(\s*<[^<>]+?>){0,1}\s*(' . $this->leftSingleQuotes . ')(\s*<[^<>]+?>){0,1}\s*(' . $this->nonBreakingSpaceRegex . '){0,}\s*/is', '<q>$1$3', $this->code);
			$this->code = preg_replace('/\s*(' . $this->nonBreakingSpaceRegex . '){0,}\s*(<[^<>]+?>\s*){0,1}(' . $this->rightSingleQuotes . ')\s*(<[^<>]+?>\s*){0,1}<\/q>/is', '$2$4</q>', $this->code);
		} else {
			// unfortunately people seem to use french quotes on english pages...
			// so that we are forcing quotes to correspond to the language of the page (which could potentially mess it up if something 
			// like quoting french text in an english page occurs)
			$q_strings = OM::getAllOStrings($this->code, "<q", "</q>");
			if($this->language === "french") {
				// for single quotes
				foreach($q_strings as $index => $value) {
					$q_string = $value[0];
					$substr = substr($q_string, 2, strlen($q_string) - 6);
					if(strpos($substr, "<q") !== false) { // then there is a nested <q>
						// notice that this assumes that there are no other tag names that begin with q which is currently (2011-07-11) true for
						// HTML5 and XHTML 1.0 Strict
						$substr = preg_replace('/<q>(\s*<[^<>]+?>\s*){0,1}(' . $this->leftSingleQuotes . '){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}/is', 'XXX9o9NewTagBeginXXXq9o9XXX$1XXX9o9NewEntityXXXlsaquo9o9XXXXXX9o9NewEntityXXXnbsp9o9XXX$4', $substr);
						$substr = preg_replace('/(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightSingleQuotes . '){0,1}(\s*<[^<>]+?>\s*){0,1}<\/q>/is', '$2XXX9o9NewEntityXXXnbsp9o9XXXXXX9o9NewEntityXXXrsaquo9o9XXX$5XXX9o9NewTagEndXXXq9o9XXX', $substr);
						$this->code = str_replace($q_string, "<q" . $substr . "</q>", $this->code);
					}
				}
				// for double quotes
				$this->code = preg_replace('/<q>(\s*<[^<>]+?>\s*){0,1}(' . $this->leftDoubleQuotes . '){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}/is', '<q>$1XXX9o9NewEntityXXXlaquo9o9XXXXXX9o9NewEntityXXXnbsp9o9XXX$4', $this->code);
				$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightDoubleQuotes . '){0,1}(\s*<[^<>]+?>\s*){0,1}<\/q>/is', '$2XXX9o9NewEntityXXXnbsp9o9XXXXXX9o9NewEntityXXXraquo9o9XXX$5</q>', $this->code);
			} else {
				// for single quotes
				foreach($q_strings as $index => $value) {
					$q_string = $value[0];
					$substr = substr($q_string, 2, strlen($q_string) - 6);
					if(strpos($substr, "<q") !== false) { // then there is a nested <q>
						// notice that this assumes that there are no other tag names that begin with q which is currently (2011-07-11) true for
						// HTML5 and XHTML 1.0 Strict
						$substr = preg_replace('/<q>(\s*<[^<>]+?>\s*){0,1}(' . $this->leftSingleQuotes . '){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}/is', 'XXX9o9NewTagBeginXXXq9o9XXX$1XXX9o9NewEntityXXXlsquo9o9XXX$4', $substr);
						$substr = preg_replace('/(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightSingleQuotes . '){0,1}(\s*<[^<>]+?>\s*){0,1}<\/q>/is', '$2XXX9o9NewEntityXXXrsquo9o9XXX$5XXX9o9NewTagEndXXXq9o9XXX', $substr);
						$this->code = str_replace($q_string, "<q" . $substr . "</q>", $this->code);
					}
				}
				// for double quotes
				$this->code = preg_replace('/<q>(\s*<[^<>]+?>\s*){0,1}(' . $this->leftDoubleQuotes . '){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}/is', '<q>$1XXX9o9NewEntityXXXldquo9o9XXX$4', $this->code);
				$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightDoubleQuotes . '){0,1}(\s*<[^<>]+?>\s*){0,1}<\/q>/is', '$2XXX9o9NewEntityXXXrdquo9o9XXX$5</q>', $this->code);
			}
		}
	}
	
	protected function DOM_quotation() {
		
		// we do not want to apply <q> tags while inside these tags.
		$array_exclusions = array(
		'head',
		'script',
		'style',
		);
		
		$grand_changes_count = 0;
		
		// this does not deal with &quot; entities..........
		$query = '//text()';
		$text_nodes = $this->xpath->query($query);
		foreach($text_nodes as $text_node) {
			$changes_count = 0;
			if(strlen(trim($text_node->nodeValue)) > 0) {
				$node_value = $text_node->nodeValue;
				// come to think of it, the right double quotes lines just take any double quotes remaining and makes them closing quote tags... oh well.
				if($this->config['quotes_style'] === 'omit_characters') {
					$node_value = preg_replace('/(' . $this->leftDoubleQuotes . ')(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}((\.\.\.){0,}\w{1,})/is', 'XXX9o9NewTagBeginXXXq9o9XXX$2$4$5', $node_value, -1, $ct1);
					$node_value = preg_replace('/(\w{0,}[\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/\']{0,})(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->rightDoubleQuotes . ')/is', '$1$2$4XXX9o9NewTagEndXXXq9o9XXX', $node_value, -1, $ct2);
					$changes_count += $ct1;
				} else {
					// unfortunately people seem to use french quotes on english pages...
					if($this->language === "french") {
						$node_value = preg_replace('/(' . $this->leftDoubleQuotes . ')(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}((\.\.\.){0,}\w{1,})/is', 'XXX9o9NewTagBeginXXXq9o9XXXXXX9o9NewEntityXXXlaquo9o9XXXXXX9o9NewEntityXXXnbsp9o9XXX$2$4$5', $node_value, -1, $ct4);
						$node_value = preg_replace('/(\w{0,}[\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/\']{0,})(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->rightDoubleQuotes . ')/is', '$1$2$4XXX9o9NewEntityXXXnbsp9o9XXXXXX9o9NewEntityXXXraquo9o9XXXXXX9o9NewTagEndXXXq9o9XXX', $node_value, -1, $ct5);
						$changes_count += $ct4;
					} else {
						$node_value = preg_replace('/(' . $this->leftDoubleQuotes . ')(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}((\.\.\.){0,}\w{1,})/is', 'XXX9o9NewTagBeginXXXq9o9XXXXXX9o9NewEntityXXXldquo9o9XXX$2$4$5', $node_value, -1, $ct7);
						$node_value = preg_replace('/(\w{0,}[\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/\']{0,})(\s*<[^<>]+?>\s*){0,1}(' . $this->nonBreakingSpaceRegex . '){0,}(\s*<[^<>]+?>\s*){0,1}(' . $this->rightDoubleQuotes . ')/is', '$1$2$4XXX9o9NewEntityXXXrdquo9o9XXXXXX9o9NewTagEndXXXq9o9XXX', $node_value, -1, $ct8);
						$changes_count += $ct7;
					}
				}
				if($ct1 > 0 || $ct2 > 0 || $ct4 > 0 || $ct5 > 0 || $ct7 > 0 || $ct8 > 0) {
					$nodeAncestorsArray = ReTidy::DOM_getNodeAncestry($text_node);
					$apply_q = true;
					foreach($nodeAncestorsArray as $ancestor) {
						foreach($array_exclusions as $exclusion) {
							if($exclusion === $ancestor) {
								$apply_q = false;
								continue 3;
							}
						}
					}
					if($apply_q) {
						$text_node->nodeValue = $node_value;
						$grand_changes_count += $changes_count;
					}
				}
			}
		}
		$this->logMsgIf("double quotes to &lt;q&gt;", $grand_changes_count);
	}
	
	protected function post_DOM_quotation() {
		
		// we won't deal with nestings beyond third level; like:
		// Consider this example from that story (page 29): [Marlow said,] "...The fat man sighed. 'Very sad.' 'And the pestiferous 
		// absurdity of his talk,' continued the other; 'he bothered me enough when he was here. "Each station should be like a beacon 
		// on the road towards better things, a center for trade of course, but also for humanizing, improving, instructing." Conceive 
		// you—that ass! And he wants to be manager! No, it's—' Here he got choked by excessive indignation, and I lifted my head the least bit. ..."
		
		//$this->code = iconv($this->config['encoding'], 'utf-8' . "//TRANSLIT", $this->code);
		$changes_count = 0;
		$singleQuotesArray = explode("|", $this->singleQuotes);
		
		// here is where we bravely try to to semantically discern single quotes from apostrophes
		// first; only search for nested quotations in already identified (double quotes) quotations
		$q_strings = OM::getAllOStrings($this->code, "<q", "</q>");
		foreach($q_strings as $index => $value) {
			$q_string = $value[0];
			$substr = substr($q_string, 2, strlen($q_string) - 6);
			$do_the_replaces = false;
			foreach($singleQuotesArray as $singleQuote) {
				if(strpos($substr, $singleQuote) !== false) { // then there is potentially a nested quotation
					$do_the_replaces = true;
					break;
				}
			}
			if($do_the_replaces) {
				// notice that this assumes that there are no other tag names that begin with q which is currently (2011-07-11) true for
				// HTML5 and XHTML 1.0 Strict
				// whether there is an even number of single quotes is not a good indicator since there could be a nested quote 
				// as well as an apostraphe although good authors would resist this situation
				// we make the word length at least 2 to avoid french things like: l'écouteur, d'écouter, c'est-à-dire
				// and english apostraphe words: Mark's, Tom's
				if($this->config['quotes_style'] === 'omit_characters') {
					$substr = preg_replace("/([\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/])(\s*<[^q][^<>]*?>\s*){0,1}(\s*<q[^<>]*?>\s*){0,1}(\s*<[^<>]+?>\s*){0,1}(" . $this->leftSingleQuotes . ")(\s*<[^<>]+?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^<>]+?>\s*){0,1}((\.\.\.){0,}([iIaA0-9]\s|\w{2,}))/is", '$1$2<q>$4$6$8$9', $substr, -1, $ct1);
					if($ct1 > 0) {
						$substr = preg_replace("/(\w{2,}[\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/]{0,})(\s*<[^<>]+?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^<>]+?>\s*){0,1}(" . $this->rightSingleQuotes . ")(\s*<[^\/]|\/[^q][^<>]*?>\s*){0,1}(\s*<\/q>\s*){0,1}(\s*<[^<>]+?>\s*){0,1}([\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/])/is", '$1$2$4$6</q>$8$9', $substr, -1, $ct2);
					}
				} else {
					if($this->language === "french") {
						$substr = preg_replace("/([\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/]|" . $this->leftDoubleQuotes . ")(\s*<[^q][^<>]*?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^q][^<>]*?>\s*){0,1}(\s*<q[^<>]*?>\s*){0,1}(\s*<[^<>]+?>\s*){0,1}(" . $this->leftSingleQuotes . ")(\s*<[^<>]+?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^<>]+?>\s*){0,1}((\.\.\.){0,}([iIaA0-9]\s|\w{2,}))/is", '$1$2$3$4<q>$6&lsaquo;$8&nbsp;$10$11', $substr, -1, $ct1);
						if($ct1 > 0) {
							$substr = preg_replace("/(\w{2,}[\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/]{0,})(\s*<[^<>]+?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^<>]+?>\s*){0,1}(" . $this->rightSingleQuotes . ")(\s*<[^\/]|\/[^q][^<>]*?>\s*){0,1}(\s*<\/q>\s*){0,1}(\s*<[^<>]+?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^<>]+?>\s*){0,1}([\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/]|" . $this->rightDoubleQuotes . ")/is", '$1$2&nbsp;$4&rsaquo;$6</q>$8$9$10$11', $substr, -1, $ct2);
						}
					} else {
						$substr = preg_replace("/([\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/]|" . $this->leftDoubleQuotes . ")(\s*<[^q][^<>]*?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^q][^<>]*?>\s*){0,1}(\s*<q[^<>]*?>\s*){0,1}(\s*<[^<>]+?>\s*){0,1}(" . $this->leftSingleQuotes . ")(\s*<[^<>]+?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^<>]+?>\s*){0,1}((\.\.\.){0,}([iIaA0-9]\s|\w{2,}))/is", '$1$2$3$4<q>$6&lsquo;$8$10$11', $substr, -1, $ct1);
						if($ct1 > 0) {
							$substr = preg_replace("/(\w{2,}[\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/]{0,})(\s*<[^<>]+?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^<>]+?>\s*){0,1}(" . $this->rightSingleQuotes . ")(\s*<[^\/]|\/[^q][^<>]*?>\s*){0,1}(\s*<\/q>\s*){0,1}(\s*<[^<>]+?>\s*){0,1}(" . $this->nonBreakingSpaceRegex . "){0,}(\s*<[^<>]+?>\s*){0,1}([\s,~!\(\)\-=\+\{\}\[\]\\\|:;\<>,\.\?\/]|" . $this->rightDoubleQuotes . ")/is", '$1$2$4&rsquo;$6</q>$8$9$10$11', $substr, -1, $ct2);
						}
					}
				}
				if($ct1 > 0) {
					if($ct1 !== $ct2) {

					} else {
						$this->code = str_replace($q_string, "<q" . $substr . "</q>", $this->code, $ct3);
						$changes_count += $ct3;
					}
				}
			}
		}
		
		//<q>&laquo;&nbsp;XXX9o9NewQuotesEntityXXX#1609o9XXXRevenusXXX9o9NewQuotesEntityXXX#1609o9XXX&nbsp;&raquo;</q>
		$this->code = preg_replace('/XXX9o9NewQuotesEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXXXXX9o9NewQuotesEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXX/is', 'XXX9o9NewQuotesEntityXXX${1}9o9XXX', $this->code);
		$this->code = preg_replace('/XXX9o9NewQuotesEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXXXXX9o9NewQuotesEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXX/is', 'XXX9o9NewQuotesEntityXXX${2}9o9XXX', $this->code);
		$this->code = preg_replace('/XXX9o9NewQuotesEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXXXXX9o9NewEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXX/is', 'XXX9o9NewEntityXXX${2}9o9XXX', $this->code);
		$this->code = preg_replace('/XXX9o9NewEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXXXXX9o9NewQuotesEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXX/is', 'XXX9o9NewEntityXXX${1}9o9XXX', $this->code);
		$this->code = preg_replace('/XXX9o9NewQuotesEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXX(' . $this->nonBreakingSpaceRegex . ')/is', 'XXX9o9NewQuotesEntityXXX${1}9o9XXX', $this->code);
		$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . ')XXX9o9NewQuotesEntityXXX(#32|#160|#xa0|#xA0|nbsp)9o9XXX/is', 'XXX9o9NewQuotesEntityXXX${2}9o9XXX', $this->code);
		//$this->code = preg_replace('/XXX9o9NewQuotesEntityXXX#1609o9XXX(' . $this->nonBreakingSpaceRegex . ')/is', 'XXX9o9NewQuotesEntityXXX#1609o9XXX', $this->code);
		//$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . ')XXX9o9NewQuotesEntityXXX#1609o9XXX/is', 'XXX9o9NewQuotesEntityXXX#1609o9XXX', $this->code);
		//$this->code = preg_replace('/XXX9o9NewQuotesEntityXXX#1609o9XXX(&nbsp;)/is', 'XXX9o9NewQuotesEntityXXX#1609o9XXX', $this->code);
		//$this->code = preg_replace('/(&nbsp;)XXX9o9NewQuotesEntityXXX#1609o9XXX/is', 'XXX9o9NewQuotesEntityXXX#1609o9XXX', $this->code);
		//$this->code = str_replace('XXX9o9NewQuotesEntityXXX#1609o9XXX&nbsp;', 'XXX9o9NewQuotesEntityXXX#1609o9XXX', $this->code);
		//$this->code = str_replace('&nbsp;XXX9o9NewQuotesEntityXXX#1609o9XXX', 'XXX9o9NewQuotesEntityXXX#1609o9XXX', $this->code);
		
		// the quotation code was written expecting <q> tags on the outside of characters so if the configuration in the profile demands it, put them on the inside
		if($this->config['quotes_style'] === 'use_quote_chars_outside_quote_tags') {
			$this->code = preg_replace('/<q>(' . $this->leftQuotes . ')(' . $this->nonBreakingSpaceRegex . '){0,}\s*<q>(' . $this->leftQuotes . ')(' . $this->nonBreakingSpaceRegex . '){0,}/is', '$1$2XXX9o9NewTagBeginXXXq9o9XXX$3$4XXX9o9NewTagBeginXXXq9o9XXX', $this->code);
			$this->code = preg_replace('/<q>(' . $this->leftQuotes . ')(' . $this->nonBreakingSpaceRegex . '){0,}/is', '$1$2<q>', $this->code);
			$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightQuotes . ')<\/q>(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightQuotes . ')<\/q>/is', 'XXX9o9NewTagEndXXXq9o9XXX$1$2XXX9o9NewTagEndXXXq9o9XXX$3$4', $this->code);
			$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . '){0,}(' . $this->rightQuotes . ')<\/q>/is', '</q>$1$2', $this->code);
			$this->code = str_replace('XXX9o9NewTagBeginXXXq9o9XXX', '<q>', $this->code);
			$this->code = str_replace('XXX9o9NewTagEndXXXq9o9XXX', '</q>', $this->code);
			// some replaces for clean-up
			$this->code = preg_replace('/(' . $this->leftQuotes . ')(' . $this->nonBreakingSpaceRegex . ')<q>((<[^<>]+?>)*)(' . $this->nonBreakingSpaceRegex . ')/is', '$1&nbsp;<q>$3', $this->code);
			$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . ')<\/q>(' . $this->nonBreakingSpaceRegex . ')/is', '$1</q>', $this->code);
			$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . ')<q>(' . $this->nonBreakingSpaceRegex . ')/is', '<q>$2', $this->code);
			$this->code = preg_replace('/XXX9o9NewQuotesEntityXXXnbsp9o9XXX<\/q>(' . $this->nonBreakingSpaceRegex . ')/is', '</q>$1', $this->code);
			$this->code = preg_replace('/(' . $this->nonBreakingSpaceRegex . ')<q>XXX9o9NewQuotesEntityXXXnbsp9o9XXX/is', '$1<q>', $this->code);
		}
		
		// also quotes decode the entities
		$this->code = preg_replace('/XXX9o9NewQuotesEntityXXX([^;&\s]+?)9o9XXX/is', '&$1;', $this->code);
		$this->logMsgIf("single quotes to &lt;q&gt;", $changes_count);
	}
	
	protected function CLF2() {
		ReTidy::CLF2_replace();
		ReTidy::exhaustive_CLF2_regex();
		
		// disabled since people will definately not expect this and if content is transfered without retaining the <head> code then this fix fails.
		//ReTidy::ol_start_to_javascript();

		ReTidy::tidy_code();
		
		ReTidy::dom_init();
		ReTidy::DOM_CLF2();
		ReTidy::DOM_redundant_classes();
		ReTidy::dom_save();
		
		ReTidy::post_dom();
		
		ReTidy::CLF2_regex();
		
		ReTidy::tidy_code();
	}

	protected function exhaustive_CLF2_regex() {
		$initial_code = true;
		$code = false;		
		while($initial_code != $code) {
			$initial_code = $this->code;
			ReTidy::CLF2_regex();
			$code = $this->code;
		}		
	}
	
	protected function CLF2_regex() {
		if(!is_array($this->config['CLF2_regex'])) {
			ReTidy::warning('Attempting to do CLF2_regex but its array was not properly set.');
			return false;
		}
		$c = $ct = 0;
		foreach($this->config['CLF2_regex'] as $search => $replace) {
			if(strpos($search, "section") !== false || strpos($replace, "section") !== false) {
				$counter = 0;
				while($counter < sizeof($this->anchor_text_array) + 1) {
					$this->code = preg_replace("/" . str_replace('section', $this->anchor_text_array[$counter], $search) . "/is", str_replace('section', $this->anchor_text_array[$counter], $replace), $this->code, -1, $c);
					$this->logMsgIf("CLF2_regex[" . htmlentities($search) . "]", $c);
					$ct += $c;
					$counter++;
				}
			}
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("CLF2_regex[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		return true;
	}
	
	protected function CLF2_replace() {
		if(!is_array($this->config['CLF2_replace'])) {
			ReTidy::warning('Attempting to do CLF2_replace but its array was not properly set.');
			return false;
		}
		$c = $ct = 0;
		foreach($this->config['CLF2_replace'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("CLF2_replace[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		return true;
	}
	
	protected function basicnetscape4_7 ()
	{
		if(!is_array($this->config['basicnetscape4_7']))
			return false;

		$c = $ct = 0;
		foreach($this->config['basicnetscape4_7'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("basicnetscape4_7[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("basicnetscape4_7", $ct);
		return true;
	}

	protected function fix_empty_anchors () {
		$ct = 0;
		//$this->code = preg_replace('/<a name="(note[0-9]*)"( id="\1"){0,1}><\/a><sup><a href="#foot\1"([^<>]*)>/is', '<sup><a href="#foot$1" name="$1" id="$1"$3>', $this->code, -1, $c);
		//$this->code = preg_replace('/<a name="foot(note[0-9]*)"( id="foot\1"){0,1}([^<>]*)><\/a><a href="#\1"([^<>]*)>/is', '<a href="#\1" name="foot$1" id="foot$1"$3$4>', $this->code, -1, $d);		
		//$this->code = preg_replace('/(<a name="section([0-9]*)"( id="section\1"){0,1}([^<>]*)>)(<\/a>)\2/is', '$1$2$5', $this->code, -1, $e);
		//$this->code = preg_replace('/(<a name="section([0-9]*)_([0-9]*)"( id="section\2_\3"){0,1}([^<>]*)>)(<\/a>)\2\.\3/is', '$1$2.$3$6', $this->code, -1, $f);
		//$this->code = preg_replace('/(<a name="section([0-9]*)_([0-9]*)_([0-9]*)"( id="section\2_\3_\4"){0,1}([^<>]*)>)(<\/a>)\2\.\3\.\4/is', '$1$2.$3.$4$7', $this->code, -1, $g);
		//$this->code = preg_replace('/(<a name="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"( id="section\2_\3_\4_\5"){0,1}([^<>]*)>)(<\/a>)\2\.\3\.\4\.\5/is', '$1$2.$3.$4.$5$8', $this->code, -1, $g);		
		//$this->code = preg_replace('/(<a name="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"( id="section\2_\3_\4_\5_\6"){0,1}([^<>]*)>)(<\/a>)\2\.\3\.\4\.\5\.\6/is', '$1$2.$3.$4.$5.$6$9', $this->code, -1, $g);
		//$this->code = preg_replace('/(<a name="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"( id="section\2_\3_\4_\5_\6_\7"){0,1}([^<>]*)>)(<\/a>)\2\.\3\.\4\.\5\.\6\.\7/is', '$1$2.$3.$4.$5.$6.$7$10', $this->code, -1, $g);
		// (2011-06-27) the name attribute is deprecated
		//$this->code = preg_replace('/<a id="(note[0-9]*)"><\/a><sup><a href="#foot\1"([^<>]*)>/is', '<sup><a href="#foot$1" id="$1"$2>', $this->code, -1, $c);
		//$this->code = preg_replace('/<a id="foot(note[0-9]*)"([^<>]*)><\/a><a href="#\1"([^<>]*)>/is', '<a href="#$1" id="foot$1"$2$3>', $this->code, -1, $d);		
		//$this->code = preg_replace('/( id="section([0-9]*)"([^<>]*)>)\2/is', '$1$2', $this->code, -1, $e);
		//$this->code = preg_replace('/( id="section([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3/is', '$1$2.$3', $this->code, -1, $f);
		//$this->code = preg_replace('/( id="section([0-9]*)_([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3\.\4/is', '$1$2.$3.$4', $this->code, -1, $g);
		//$this->code = preg_replace('/( id="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3\.\4\.\5/is', '$1$2.$3.$4.$5', $this->code, -1, $g);		
		//$this->code = preg_replace('/( id="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3\.\4\.\5\.\6/is', '$1$2.$3.$4.$5.$6', $this->code, -1, $g);
		//$this->code = preg_replace('/( id="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3\.\4\.\5\.\6\.\7/is', '$1$2.$3.$4.$5.$6.$7', $this->code, -1, $g);
		
		$empty_anchors_rxp_array = array(
			'<a id="(note[0-9]*)"><\/a><sup><a href="#foot\1"([^<>]*)>' => '<sup><a href="#foot$1" id="$1"$2>',
			'<a id="foot(note[0-9]*)"([^<>]*)><\/a><a href="#\1"([^<>]*)>' => '<a href="#$1" id="foot$1"$2$3>',
			'( id="section([0-9]*)"([^<>]*)>)\2' => '$1$2',
			'( id="section([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3' => '$1$2.$3',
			'( id="section([0-9]*)_([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3\.\4' => '$1$2.$3.$4',
			'( id="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3\.\4\.\5' => '$1$2.$3.$4.$5',
			'( id="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3\.\4\.\5\.\6' => '$1$2.$3.$4.$5.$6',
			'( id="section([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)_([0-9]*)"([^<>]*)>)\2\.\3\.\4\.\5\.\6\.\7' => '$1$2.$3.$4.$5.$6.$7',
		);
		
		foreach($this->anchor_text_array as $index => $anchor_text) {
			foreach($empty_anchors_rxp_array as $search => $replace) {
				$this->code = preg_replace('/' . str_replace('section', $anchor_text, $search) . '/is', $replace, $this->code, -1, $count);
				$ct += $count;
			}
		}
		$this->logMsgIf("fix_empty_anchors", $ct);
		return true;
	}
	
	protected function basictypical() {
		if(!is_array($this->config['basictypical'])) return false;
		$c = $ct = 0;
		foreach($this->config['basictypical'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("basictypical[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		return true;
	}	
	
	protected function oe() {
		if(!is_array($this->config['oeArray'])) {
			print('<h1 style="color:red;">No OE array!</h1>');exit(0);
			return false;
		}
		$c = $ct = 0;
		foreach($this->config['oeArray'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("oe[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		return true;
	}

	protected function basiclanguage () {
		$c = $d = $ct = $dt = $cnt = 0;
		if ($this->language === "english") {
			$LanguageArray = $this->config['basicEnglishArray'];
		}
		if ($this->language === "french" || $this->language === "english_and_french") {
			$LanguageArray = $this->config['basicFrenchArray'];
			$LanguageRxpArray = $this->config['basicFrenchRxpArray'];
		}
		if($LanguageArray) {
			foreach($LanguageArray as $search => $replace) {
				$this->code = str_replace($search, $replace, $this->code, $c);
				$this->logMsgIf("basiclanguage[" . htmlentities($search) . "]", $c);
				$ct += $c;
			}
		}
		if($LanguageRxpArray) {
			foreach($LanguageRxpArray as $search => $replace) {
				$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, $d);
				$this->logMsgIf("basiclanguage[" . htmlentities($search) . "]", $d);
				$dt += $c;
			}
		}
		return true;
	}
	
	protected function basicwingding () {
		if(!is_array($this->config['basicwingding'])) return false;

		$c = $ct = 0;
		foreach($this->config['basicwingding'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("basicwingding[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("basicwingding", $ct);
		return true;
	}	
	
	protected function basicphysunits () {
		print("<h1>BOOM4894!!!</h1>");exit(0);
		if(!is_array($this->config['basicphysunits'])) return false;
		$c = $c2 = $ct = 0;
		foreach($this->config['basicphysunits'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("basicphysunits[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		foreach($this->config['basicphysunitsRxp'] as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $c2);
			$this->logMsgIf("basicphysunitsRxp[" . htmlentities($search) . "]", $c2);
			$ct += $c2;
		}	
		$this->logMsgIf("basicphysunits", $ct);
		return true;
	}

	protected function array_mix() {
		$array = array();
		$arrays = func_get_args();
		foreach($arrays as $array_i) if(is_array($array_i))
			$array = ReTidy::array_mixer($array, $array_i);
		return $array;
	}
	
	protected function array_mix_recursive() {
		$array = array();
		$arrays = func_get_args();
		foreach($arrays as $array_i) if(is_array($array_i))
			$array = ReTidy::array_mixer($array, $array_i);
		return $array;
	}
	
	protected function array_mixer($array_o, $array_i) {
		foreach($array_i as $k => $v) {
			if(!isset($array_o[$k])) {
				$array_o[$k] = $v;
			} else {
				if(is_array($array_o[$k])) {
					$array_o[$k][] = $v;
				} else {
					$array_o[$k] = array($array_o[$k], $v);
					$new_array[strtolower($index)] = array($new_array[strtolower($index)], strtolower($value));
				}			
			}
		}
		return $array_o;
	}

	protected function phys_units_init() {
		if($this->language === "english" || $this->language === "unknown" || !$this->language) {
			$SI_base_units = array(
			//'symbol' => 'name',
			'm' => 'metre',
			'g' /* kg... */ => 'gram' /* kilogram... */,
			's' => 'second',
			'A' => 'ampere',
			'K' => 'kelvin',
			'cd' => 'candela',
			'mol' => 'mole',
			);	
			
			$SI_derived_units = array(
			//'symbol' => 'name',
			'Hz' => 'hertz',
			'rad' => 'radian',
			'sr' => 'steradian',
			'N' => 'newton',
			'Pa' => 'pascal',
			'J' => 'joule',
			'W' => 'watt',
			'C' => 'coulomb',
			'V' => 'volt',
			'F' => 'farad',
			html_entity_decode('&Omega;') => 'ohm', '&Omega;' => 'ohm', //'Ω' => 'ohm', 
			'S' => 'siemens',
			'Wb' => 'weber',
			'T' => 'tesla',
			'H' => 'henry',
			/*'°C' => 'degree Celsius',*/ html_entity_decode("&deg;") . 'C' => 'degree Celsius', '&deg;C' => 'degree Celsius', /*'°C' => 'degrees Celsius',*/ html_entity_decode("&deg;") . 'C' => 'degrees Celsius', '&deg;C' => 'degrees Celsius',
			'lm' => 'lumen',
			'lx' => 'lux',
			'Bq' => 'becquerel',
			'Gy' => 'gray',
			'Sv' => 'sievert',
			'kat' => 'katal',
			);
			
			$other_units = array(
			//'symbol' => 'name',		
			'min' => 'minute',
			'h' => 'hour',
			'd' => 'day',
			html_entity_decode("&deg;") => 'degree', //'°' => 'degree', //'°' => 'degree of arc',
			html_entity_decode("&prime;") => 'minute', //'′' => 'minute', //'′' => 'minute of arc', 
			html_entity_decode("&Prime;") => 'second', //'″' => 'second', //'″' => 'second of arc', 
			//'deg<sup>2</sup>' => 'square degree',
			//'sq.deg.' => 'square degree',
			'ha' => 'hectare',
			'l' => 'litre',
			'L' => 'litre',		
			't' => 'tonne',
			);
			
			$american_units = array(
			//'symbol' => 'name',		
			'lb' => 'pound',
			'L' => 'liter',
			'm' => 'meter',
			'in' => 'inch',
			'ft' => 'foot',
			'yd' => 'yard',
			'mi' => 'mile',
			'gal' => 'gallon',		
			);
			
			$cooking_units = array(
			//'symbol' => 'name',		
			'tsp' => 'teaspoon',
			'tbsp' => 'tablespoon',
			'C' => 'cup',
			'oz' => 'ounce',
			'pt' => 'pint',
			'qt' => 'quart',
			);		

			$SI_standard_prefixes = array(
			//'symbol' => 'name',
			'' => '', // for a unit without a prefix
			'da' => 'deca',
			'h' => 'hecto',
			'k' => 'kilo',
			'M' => 'mega',
			'G' => 'giga',
			'T' => 'tera',
			'P' => 'peta',
			'E' => 'exa',
			'Z' => 'zetta',
			'Y' => 'yotta',
			
			'd' => 'deci',
			'c' => 'centi',
			'm' => 'milli',
			'µ' => 'micro',
			'n' => 'nano',
			'p' => 'pico',
			'f' => 'femto',
			'a' => 'atto',
			'z' => 'zepto',
			'y' => 'yocto',
			);
			
			$american_prefixes = array(
			//'symbol' => 'name',
			'da' => 'deka',
			);
		}

		// french is not yet tested (2009-06-15)
		if($this->language === "french") {
			$SI_base_units = array(
			//'symbol' => 'name',
			'm' => 'mètre',
			'g' /* kg... */ => 'gramme' /* kilogram... */,
			's' => 'seconde',
			'A' => 'ampère',
			'K' => 'kelvin',
			'cd' => 'candela',
			'mol' => 'mole',
			);	
			
			$SI_derived_units = array(
			//'symbol' => 'name',
			'Hz' => 'hertz',
			'rad' => 'radian',
			'sr' => 'steradian',
			'N' => 'newton',
			'Pa' => 'pascal',
			'J' => 'joule',
			'W' => 'watt',
			'C' => 'coulomb',
			'V' => 'volt',
			'F' => 'farad',
			html_entity_decode('&Omega;') => 'ohm', '&Omega;' => 'ohm', //'Ω' => 'ohm', 
			'S' => 'siemens',
			'Wb' => 'weber',
			'T' => 'tesla',
			'H' => 'henry',
			/*'°C' => 'degré Celsius',*/ html_entity_decode("&deg;") . 'C' => 'degré Celsius', '&deg;C' => 'degré Celsius', /*'°C' => 'degrés Celsius',*/ html_entity_decode("&deg;") . 'C' => 'degrés Celsius', '&deg;C' => 'degrés Celsius',
			'lm' => 'lumen',
			'lx' => 'lux',
			'Bq' => 'becquerel',
			'Gy' => 'gray',
			'Sv' => 'sievert',
			'kat' => 'katal',
			);
			
			$other_units = array(
			//'symbol' => 'name',		
			'min' => 'minute',
			'h' => 'heure',
			'd' => 'jour',
			html_entity_decode("&deg;") => 'degré', //'°' => 'degree', //'°' => 'degree of arc',
			html_entity_decode("&prime;") => 'minute', //'′' => 'minute', //'′' => 'minute of arc', 
			html_entity_decode("&Prime;") => 'seconde', //'″' => 'second', //'″' => 'second of arc', 
			//'deg<sup>2</sup>' => 'square degree',
			//'sq.deg.' => 'square degree',
			'ha' => 'hectare',
			'l' => 'litre',
			'L' => 'litre',		
			't' => 'tonne',
			);
			
			$american_units = array(
			//'symbol' => 'name',		
			'lb' => 'livre',
			'L' => 'liter',
			'm' => 'meter',
			'in' => 'pousse',
			'ft' => 'pied',
			'yd' => 'yard',
			'mi' => 'mile',
			'gal' => 'gallon',		
			);
			
			$cooking_units = array(
			//'symbol' => 'name',		
			'tsp' => 'cuillerée à café',
			'tbsp' => 'cuillerée à soupe',
			'C' => 'tasse',
			'oz' => 'once',
			'pt' => 'pinte',
			'qt' => 'quart',
			);		

			$SI_standard_prefixes = array(
			//'symbol' => 'name',
			'' => '', // for a unit without a prefix
			'da' => 'deca',
			'h' => 'hecto',
			'k' => 'kilo',
			'M' => 'mega',
			'G' => 'giga',
			'T' => 'tera',
			'P' => 'peta',
			'E' => 'exa',
			'Z' => 'zetta',
			'Y' => 'yotta',
			
			'd' => 'deci',
			'c' => 'centi',
			'm' => 'milli',
			'μ' => 'micro',
			'n' => 'nano',
			'p' => 'pico',
			'f' => 'femto',
			'a' => 'atto',
			'z' => 'zepto',
			'y' => 'yocto',
			);
			
			$american_prefixes = array(
			//'symbol' => 'name',
			'da' => 'deka',
			);
		}
		
		$this->units = ReTidy::array_mix($SI_base_units, $SI_derived_units, $american_units, $cooking_units, $other_units);
		uksort($this->units, 'sortAlphabetically');
		$this->units = array_reverse($this->units);
		// this is done so that "lb" (pound) appears before "l" (liter). We sort this array in reverse alphabetical order by the index.
		$this->prefixes = ReTidy::array_mix($SI_standard_prefixes, $american_prefixes);
		uksort($this->prefixes, 'sortAlphabetically');
		$this->prefixes = array_reverse($this->prefixes);
		// this is done so that "lb" (pound) appears before "l" (liter). We sort this array in reverse alphabetical order by the index.
		ReTidy::words_init();
	}

	protected function strtolower_recursive($array, $new_array) {
		foreach($array as $index => $value) {
			if(is_array($value)) {
				$new_array[strtolower($index)] = ReTidy::strtolower_recursive($value, array());
			} else {
				if(isset($new_array[strtolower($index)])) {
					if(is_array($new_array[strtolower($index)])) {
						$new_array[strtolower($index)][] = strtolower($value);
					} else {
						$new_array[strtolower($index)] = array($new_array[strtolower($index)], strtolower($value));
					}
				} else {
					$new_array[strtolower($index)] = strtolower($value);
				}
			}
		}
		return $new_array;
	}	
	
	protected function words_init() {
		// while utf8_encoding the files is not general, it does not become a problem as long as these are only used in headings normalization
		if(!isset($this->words_array)) {
			if($this->language === "french") {
				//$this->words_array = explode("\n", utf8_encode(file_get_contents("acronyms/fra/mots.txt")));
				//$this->entitied_words_array = explode("\n", utf8_encode(htmlentities(file_get_contents("acronyms/fra/mots.txt"))));
				//$this->words_array = explode("\n", iconv("iso-8859-1", $this->config['encoding'] . "//TRANSLIT", file_get_contents("acronyms/fra/mots.txt")));
				$this->words_array = explode("\n", file_get_contents('abbr' . DS . 'fra' . DS . 'mots.txt'));
				$this->entitied_words_array = explode("\n", htmlentities(file_get_contents('abbr' . DS . 'fra' . DS . 'mots.txt')));
			} else { // default is english
				//$this->words_array = explode("\r\n", utf8_encode(file_get_contents("acronyms/eng/words.txt")));
				//$this->entitied_words_array = explode("\r\n", utf8_encode(htmlentities(file_get_contents("acronyms/eng/words.txt"))));
				//$this->words_array = explode("\r\n", iconv("iso-8859-1", $this->config['encoding'] . "//TRANSLIT", file_get_contents("acronyms/eng/words.txt")));
				$this->words_array = explode("\r\n", file_get_contents('abbr' . DS . 'eng' . DS . 'words.txt'));
				$this->entitied_words_array = explode("\r\n", htmlentities(file_get_contents('abbr' . DS . 'eng' . DS . 'words.txt')));
			}
		}
		if(!isset($this->stop_words_array)) {
			if($this->language === "french") {
				$this->stopWordsFile = 'abbr' . DS . 'fra' . DS . 'stop_words.txt';
			} else { // default to english
				$this->stopWordsFile = 'abbr' . DS . 'eng' . DS . 'stop_words_small.txt';
			}
			//$this->stop_words_array = explode("\r\n", utf8_encode(file_get_contents($this->stopWordsFile)));
			//$this->entitied_stop_words_array = explode("\r\n", utf8_encode(htmlentities(file_get_contents($this->stopWordsFile))));
			//$this->stop_words_array = explode("\r\n", iconv("iso-8859-1", $this->config['encoding'] . "//TRANSLIT", file_get_contents($this->stopWordsFile)));
			$this->stop_words_array = explode("\r\n", file_get_contents($this->stopWordsFile));
			$this->entitied_stop_words_array = explode("\r\n", htmlentities(file_get_contents($this->stopWordsFile)));
		}
		if(!isset($this->french_headings_normalization_exceptions)) {
			$this->french_headings_normalization_exceptions = array(
			// search => replace
			'comité de surveillance des activités de renseignement de sécurité' => 'Comité de surveillance des activités de renseignement de sécurité',
			'comit&eacute; de surveillance des activit&eacute;s de renseignement de s&eacute;curit&eacute;' => 'Comit&eacute; de surveillance des activit&eacute;s de renseignement de s&eacute;curit&eacute;',
			'commission d\'examen des plaintes concernant la police militaire' => 'Commission d\'examen des plaintes concernant la police militaire',
			'service des poursuites pénales du Canada' => 'Service des poursuites pénales du Canada',
			'service des poursuites p&eacute;nales du Canada' => 'Service des poursuites p&eacute;nales du Canada',
			'agence parcs canada' => 'Agence Parcs Canada',
			'parcs canada' => 'Parcs Canada',
			
			'canada' => 'Canada',
			'parlement' => 'Parlement',
			
			'québec' => 'Québec',
			'qu&eacute;bec' => 'Qu&eacutebec',
			'ontario' => 'Ontario',
			'colombie-britannique' => 'Colombie-Britannique',
			'alberta' => 'Alberta',
			'saskatchewan' => 'Saskatchewan',
			'manitoba' => 'Manitoba',
			'nouveau-brunswick' => 'Nouveau-brunswick',
			'île-du-prince-édouard' => 'Île-du-Prince-Édouard',
			'&icirc;le-du-prince-&eacute;douard' => '&Icirc;le-du-Prince-&Eacute;douard',
			'nouvelle-écosse' => 'Nouvelle-Écosse',
			'nouvelle-&eacute;cosse' => 'Nouvelle-&Eacute;cosse',
			'terre-neuve' => 'Terre-Neuve',
			'yukon' => 'Yukon',
			'territoires du nord-ouest' => 'Territoires du Nord-Ouest',
			'nunavut' => 'Nunavut',
			
			'ottawa' => 'Ottawa',
			'toronto' => 'Toronto',
			'montréal' => 'Montréal',
			'montr&eacute;al' => 'Montr&eacute;al',
			'vancouver' => 'Vancouver',
			
			'majesté' => 'Majesté',
			'majest&eacute;' => 'Majest&eacute;',
			'directeur général' => 'Directeur général',
			'directeur g&eacute;n&eacute;ral' => 'Directeur g&eacute;n&eacute;ral',
			
			);
		}
	}
	
	protected function DOM_non_breaking() {
		// the 'noWrap' ['non_breaking_type'] is generally undesireable because it creates intrawordal <span>s
		//' ### numbers over 10 000
		$array_other_numbers = array(
		'¼', html_entity_decode('&frac14;'), '&#188;', '&#xbc;', '&frac14;',
		'½', html_entity_decode('&frac12;'), '&#189;', '&#xbd;', '&frac12;',
		'¾', html_entity_decode('&frac34;'), '&#190;', '&#xbe;', '&frac34;',
		);
		$other_number_string = implode("|", $array_other_numbers);
		$body_text_nodes = $this->xpath->query(ReTidy::get_html_namespace() . 'body//' . ReTidy::get_html_namespace() . '*/child::text()');
		foreach($body_text_nodes as $node) {
			if($this->config['non_breaking_type'] === 'noWrap') {
				$node->nodeValue = preg_replace('/([0-9]+)(\s([0-9]|(' . $other_number_string . '))+)+/s', 'XXX9o9NewTagBeginXXXspan style="white-space: nowrap;"9o9XXX$0XXX9o9NewTagEndXXXspan9o9XXX', $node->nodeValue, -1, $count1);
			} else { // default
				$node->nodeValue = preg_replace('/([0-9])\s([0-9]|(' . $other_number_string . '))/s', '$1XXX9o9NewEntityXXXnbsp9o9XXX$2', $node->nodeValue, -1, $count1);
				//$node->nodeValue = preg_replace('/([0-9])\s([0-9]|(' . $other_number_string . '))/s', '$1&nbsp;$2', $node->nodeValue, -1, $count1);
			}
			$count += $count1;
		}
		$this->logMsgIf('([0-9])\s([0-9])', $count);	
		ReTidy::DOM_phys_units();
	}
	
	protected function DOM_phys_units() {
		if(!$this->units || !$this->prefixes) {
			ReTidy::phys_units_init();
		}
		$length_of_longest_unit_symbol = 0;
		$length_of_longest_unit_name = 0;
		$length_of_longest_prefix_symbol = 0;
		$length_of_longest_prefix_name = 0;		
		foreach($this->units as $unit_symbol => $unit_name) {
			if(strlen($unit_symbol) > $length_of_longest_unit_symbol) {
				$length_of_longest_unit_symbol = strlen($unit_symbol);
			}
			if(is_array($unit_name)) {
				foreach($unit_name as $index3 => $unit_name3) {
					if(strlen($unit_name3) > $length_of_longest_unit_name) {
						$length_of_longest_unit_name = strlen($unit_name3);
					}					
				}
				continue;
			}
			if(strlen($unit_name) > $length_of_longest_unit_name) {
				$length_of_longest_unit_name = strlen($unit_name);
			}			
		}
		foreach($this->prefixes as $prefix_symbol => $prefix_name) {
			if(strlen($prefix_symbol) > $length_of_longest_prefix_symbol) {
				$length_of_longest_prefix_symbol = strlen($prefix_symbol);
			}
			if(is_array($prefix_name)) {
				foreach($prefix_name as $index3 => $prefix_name3) {
					if(strlen($prefix_name3) > $length_of_longest_prefix_name) {
						$length_of_longest_prefix_name = strlen($prefix_name3);
					}					
				}
				continue;
			}
			if(strlen($prefix_name) > $length_of_longest_prefix_name) {
				$length_of_longest_prefix_name = strlen($prefix_name);
			}			
		}
		$length_longest_symbol = $length_of_longest_unit_symbol + $length_of_longest_prefix_symbol;
		$length_longest_name = $length_of_longest_unit_name + $length_of_longest_prefix_name;			
		//$query = '//' . ReTidy::get_html_namespace() . 'a[@href="#footnote"][@name="note"][@title="Link to footnote "][@id="note"]';
		// (2011-06-27) the name attribute is deprecated
		$query = '//' . ReTidy::get_html_namespace() . 'a[@href="#footnote"][@title="Link to footnote "][@id="note"]';
		$blank_footnotes = $this->xpath->query($query);
		foreach($blank_footnotes as $blank_footnote){
			$previousText = ReTidy::getPreviousText($blank_footnote);
			$working_symbol_string = substr(strrev($previousText), 0, $length_longest_symbol+1);
			$working_name_string = substr(strrev($previousText), 0, $length_longest_name+1);
			foreach($this->units as $unit_symbol => $unit_name) {
				foreach($this->prefixes as $prefix_symbol => $prefix_name) {
					if(ReTidy::checkWithSymbol($working_symbol_string, $prefix_symbol, $unit_symbol, $blank_footnote) ||
					ReTidy::checkWithName($working_name_string, $prefix_name, $unit_name, $blank_footnote)) {
						break 2;
					}
				}
			}
		}
	}
	
	protected function allPhysUnits($string){
		if(strlen($string) === 0) {
			return false;
		}
		if(!$this->units || !$this->prefixes) {
			ReTidy::phys_units_init();
		}
		if(!$this->words_array) {
			ReTidy::words_init();
		}
		$unit_symbols_string = "";
		$unit_names_string = "";
		$prefix_symbols_string = "";
		$prefix_names_string = "";				
		foreach($this->units as $unit_symbol => $unit_name) {
			$unit_symbols_string .= "|" . $unit_symbol;
			if(is_array($unit_name)) {
				foreach($unit_name as $index4 => $unit_name4) {
					$unit_names_string  .= "|" . $unit_name4;
				}
			} else {
				$unit_names_string  .= "|" . $unit_name;
			}
		}
		foreach($this->prefixes as $prefix_symbol => $prefix_name) {
			$prefix_symbols_string .= "|" . $prefix_symbol;
			if(is_array($prefix_name)) {
				foreach($prefix_name as $index4 => $prefix_name4) {
					$prefix_names_string  .= "|" . $prefix_name4;
				}
			} else {
				$prefix_names_string  .= "|" . $prefix_name;
			}
		}	
		//var_dump($unit_symbols_string);print("<br />\r\n");
		//var_dump($unit_names_string);print("<br />\r\n");
		//var_dump($prefix_symbols_string);print("<br />\r\n");
		//var_dump($prefix_names_string);print("<br />\r\n");		
		$unit_symbols_string = substr($unit_symbols_string, 1);
		$unit_names_string = substr($unit_names_string, 1);
		$prefix_symbols_string = substr($prefix_symbols_string, 1);
		$prefix_names_string = substr($prefix_names_string, 1);	
		
		// first look to see if it begins with a physical unit
		// prefix and unit names can have "s" at the end and are case-insensitive.
		preg_match_all('/((' . $prefix_names_string . ')(' . $unit_names_string . ')s{0,1})/is', $string, $name_matches);
		$sum_name_strings = 0;
		foreach($name_matches[0] as $name_string) {
			$sum_name_strings += strlen($name_string);
		}
		if($sum_name_strings === strlen($string)) {
			return true;
		}
		preg_match_all('/((' . $prefix_symbols_string . ')(' . $unit_symbols_string . '))/s', $string, $symbol_matches);
		$sum_symbol_strings = 0;
		foreach($symbol_matches[0] as $symbol_string) {
			$sum_symbol_strings += strlen($symbol_string);
		}
		if($sum_symbol_strings === strlen($string)) {
			// here we could also have an exceptions list... had, etc...
			// although adding an extra &nbsp; is often not very terrible.
			// compare to a file with words that are assumed not to be physical units
			// note that with an exceptions file with 1/3 x 10^6 entries this may take a very long time.
			$do_it = true;
			foreach($this->words_array as $word) {
				if(strtolower($word) === strtolower($string)) {
					$do_it = false;
				}
			}
			if($do_it) {
				return true;
			}
		}
		return false;
	}
	
	protected function basic() {
		$temp_config = $this->config;
		$this->config = include('profiles' . DS . 'basic.php');
		$array_functions = $this->config["macro"];
		// this is a simplified version of cleanCode's macro processing loop.
		foreach($array_functions as $method) {
			call_user_func(array($this, $method));
		}
		// we would want to use the tidy config from basic then switch back after this function... I guess the whole profile
		// this is only important if the profile being used differs from the basic profile.
		$this->config = $temp_config;
	}
	
	protected function clean_word_macro() {
		$temp_config = $this->config;
		$this->config = include('profiles' . DS . 'clean_word.php');
		$array_functions = $this->config["macro"];
		// this is a simplified version of cleanCode's macro processing loop.
		foreach($array_functions as $method) {
			call_user_func(array($this, $method));
		}
		$this->config = $temp_config;
	}
	
	protected function clean_word_clf2_macro() {
		$temp_config = $this->config;
		$this->config = include('profiles' . DS . 'clean_word_clf2.php');
		$array_functions = $this->config["macro"];
		// this is a simplified version of cleanCode's macro processing loop.
		foreach($array_functions as $method) {
			call_user_func(array($this, $method));
		}
		$this->config = $temp_config;
	}
	
	protected function abbr_macro() {
		$temp_config = $this->config;
		$this->config = include('profiles' . DS . 'abbr.php');
		$array_functions = $this->config["pre_internal_templating_macro"];
		// this is a simplified version of cleanCode's macro processing loop.
		foreach($array_functions as $method) {
			call_user_func(array($this, $method));
		}
		$this->config = $temp_config;
	}

	protected function phys_units() {
		$count = 0;	
		$array_other_numbers = array(
		'¼', html_entity_decode('&frac14;'), '&#188;', '&#xbc;', '&frac14;',
		'½', html_entity_decode('&frac12;'), '&#189;', '&#xbd;', '&frac12;',
		'¾', html_entity_decode('&frac34;'), '&#190;', '&#xbe;', '&frac34;',
		);
		$other_number_string = implode("|", $array_other_numbers);
		preg_match_all('/([^a-z]([0-9]|(' . $other_number_string . ')))\s+/is', $this->code, $matches, PREG_OFFSET_CAPTURE);
		$array_replaces = array();
		foreach($matches[1] as $index => $value) {
			$match = $value[0];
			$offset = $value[1];
			preg_match('/[\s<\)\/,:;\?!\.]/is', $this->code, $after_matches, PREG_OFFSET_CAPTURE, $offset+strlen($match)+1);			
			$position_potential_end_phys_unit = $after_matches[0][1];
			$string_after_number = substr($this->code, $offset+strlen($match)+1, $position_potential_end_phys_unit-$offset-strlen($match)-1);
			$unit_type = ReTidy::allPhysUnits($string_after_number);
			if($unit_type){
				if($this->config['non_breaking_type'] === 'nbsp' || !$this->config['non_breaking_type']) {
					$array_replaces["/" . ReTidy::preg_escape($match) . "\s+" . ReTidy::preg_escape($string_after_number) . "([^a-z])/is"] = ReTidy::preg_escape_replacement($match) . "&nbsp;" . $string_after_number . '$1';
				} elseif($this->config['non_breaking_type'] === 'noWrap') {
					if(ReTidy::is_clf2()) {
						$array_replaces["/" . ReTidy::preg_escape($match) . "\s+" . ReTidy::preg_escape($string_after_number) . "([^a-z])/is"] = '<span class="noWrap">' . ReTidy::preg_escape_replacement($match) . " " . $string_after_number . "</span>$1";
					} else {
						$array_replaces["/" . ReTidy::preg_escape($match) . "\s+" . ReTidy::preg_escape($string_after_number) . "([^a-z])/is"] = '<span style="white-space: nowrap;">' . ReTidy::preg_escape_replacement($match) . " " . $string_after_number . "</span>$1";
					}
				}
			}
		}
		//print('$array_replaces: ');var_dump($array_replaces);
		foreach($array_replaces as $search => $replace) {
			$this->code = preg_replace($search, $replace, $this->code, -1, $ct1);
			$count += $ct1;
		}
		$this->logMsgIf("phys_units", $count);
	}
	
	protected function non_breaking() {
	    // in expressions in which figures and abbreviations (or symbols) are separated by a space (e.g. 17 kg, AD 565, 2:50 pm);
		// between the date number and month name (e.g. 3 June or June 3); and
		// in other places where breaking across lines might be disruptive to the reader, especially in infoboxes, such as £11 billion, June 2011, 5° 24′ 21.12″ N, Boeing 747, after the number in a numbered address (e.g. 123 Fake Street) and before roman numerals at the end of phrases (e.g. World War II and Pope Benedict XVI).

		// browsers treat dashes to be same as hyphens (even though they shouldn't)
		// consider http://www.punctuationmatters.com/the-hyphen-dash-n-dash-and-m-dash/
		ReTidy::line_wrapping();
		ReTidy::phys_units();
		ReTidy::non_breaking_phone_number();
		ReTidy::non_breaking_date();
		ReTidy::non_breaking_dollar_amounts();
		ReTidy::non_breaking_postal_code();
		ReTidy::non_breaking_year_range();
		// some others we may want to do are names, honorifics, places...
		ReTidy::clean_nowrap();
		ReTidy::remove_tags_intra_tags(); // for dates in the <title> that earned <span style="white-space: nowrap;">, for example
		
	}	
	
	protected function non_breaking_postal_code() {
		if($this->config['non_breaking_type'] === 'noWrap') {
			if(ReTidy::is_clf2()) {
				$this->code = preg_replace('/([^A-Z0-9])([A-Z][0-9][A-Z])(' . $this->spaceRegex . ')+([0-9][A-Z][0-9])([^A-Z0-9])/is', '$1<span class="noWrap">$2 $4</span>$5', $this->code, -1, $a);
			} else {
				$this->code = preg_replace('/([^A-Z0-9])([A-Z][0-9][A-Z])(' . $this->spaceRegex . ')+([0-9][A-Z][0-9])([^A-Z0-9])/is', '$1<span style="white-space: nowrap;">$2 $4</span>$5', $this->code, -1, $a);
			}
		} else { // default to nbsp
			$this->code = preg_replace('/([^A-Z0-9])([A-Z][0-9][A-Z])(' . $this->spaceRegex . ')+([0-9][A-Z][0-9])([^A-Z0-9])/is', '$1$2&nbsp;$4$5', $this->code, -1, $b);
		}
		$count = $a + $b;
		$this->logMsgIf("non_breaking_postal_codes", $count);
	}
	
	protected function non_breaking_dollar_amounts() {
		// does this catch all the dollar amounts we are interested in? (2012-09-20)
		if($this->config['non_breaking_type'] === 'noWrap') {
			if(ReTidy::is_clf2()) {
				$this->code = preg_replace('/(\${0,1})([0-9\.,]+)(' . $this->spaceRegex . ')+(M|million|millions|B|billion|billions)([^a-z])/is', '<span class="noWrap">$1$2 $4</span>$5', $this->code, -1, $a);
			} else {
				$this->code = preg_replace('/(\${0,1})([0-9\.,]+)(' . $this->spaceRegex . ')+(M|million|millions|B|billion|billions)([^a-z])/is', '<span style="white-space: nowrap;">$1$2 $4</span>$5', $this->code, -1, $a);
			}
		} else { // default to nbsp
			$this->code = preg_replace('/(\${0,1})([0-9\.,]+)(' . $this->spaceRegex . ')+(M|million|millions|B|billion|billions)([^a-z])/is', '$1$2&nbsp;$4$5', $this->code, -1, $b);
		}
		$count = $a + $b;
		$this->logMsgIf("non_breaking_dollar_amounts", $count);
	}
	
	protected function non_breaking_year_range() {
		if(ReTidy::is_clf2()) {
			//$this->code = preg_replace('/([^;])([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})/is', '$1<span class="noWrap">$2$3$4</span>', $this->code, -1, $a);
			//$this->code = preg_replace('/([^;0-9])([0-9]{2})(' . implode("|", $this->dashes_array) . ')([0-9]{2})([^;0-9])/is', '$1<span class="noWrap">$2&ndash;$4</span>$5', $this->code, -1, $a);
			//$this->code = preg_replace('/([^;0-9])([0-9]{4})(' . implode("|", $this->dashes_array) . ')([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2&ndash;$4</span>$5', $this->code, -1, $b);
			$this->code = preg_replace('/([^;0-9])([0-9]{2})(' . implode("|", $this->dashes_array) . ')([0-9]{2})([^;0-9])/is', '$1<span class="noWrap">$2$3$4</span>$5', $this->code, -1, $a);
			$this->code = preg_replace('/([^;0-9])([0-9]{4})(' . implode("|", $this->dashes_array) . ')([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2$3$4</span>$5', $this->code, -1, $b);
		} else {
			//$this->code = preg_replace('/([^;])([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})/is', '$1<span style="white-space: nowrap;">$2$3$4</span>', $this->code, -1, $a);
			//$this->code = preg_replace('/([^;0-9])([0-9]{2})(' . implode("|", $this->dashes_array) . ')([0-9]{2})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2&ndash;$4</span>$5', $this->code, -1, $a);
			//$this->code = preg_replace('/([^;0-9])([0-9]{4})(' . implode("|", $this->dashes_array) . ')([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2&ndash;$4</span>$5', $this->code, -1, $b);
			$this->code = preg_replace('/([^;0-9])([0-9]{2})(' . implode("|", $this->dashes_array) . ')([0-9]{2})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2$3$4</span>$5', $this->code, -1, $a);
			$this->code = preg_replace('/([^;0-9])([0-9]{4})(' . implode("|", $this->dashes_array) . ')([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2$3$4</span>$5', $this->code, -1, $b);
		}
		$count = $a + $b;
		$this->logMsgIf("non_breaking_year_range", $count);
	}
	
	protected function non_breaking_phone_number() {
		// really we could get a proper regular expression for this instead of assuming north american standard format telephone numbers but... (2012-09-20)
		if($this->config['non_breaking_type'] === 'noWrap') {
			if(ReTidy::is_clf2()) {
				//print('here33495905060<br>');
				//$this->code = preg_replace('/(\([0-9]{3}\))(' . $this->spaceRegex . ')+([0-9]{3}\-[0-9]{4})/is', '<span class="noWrap">$1 $3</span>', $this->code, -1, $a);
				$this->code = preg_replace('/([^;0-9])(1)((' . $this->spaceRegex . ')+)(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+)([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2 $5 $8 $11</span>$12', $this->code, -1, $a);
				$this->code = preg_replace('/([^;0-9])(1)((' . implode("|", $this->dashes_array) . ')+)(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')+)([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2-$5-$8-$11</span>$12', $this->code, -1, $b);
				$this->code = preg_replace('/([^;0-9])(1)((\.)+))(\(?[0-9]{3}\)?)((\.)+)([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2.$5.$8.$11</span>$12', $this->code, -1, $c);
				
				$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+)([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2 $5 $8</span>$9', $this->code, -1, $d);
				$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')+)([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2-$5-$8</span>$9', $this->code, -1, $e);
				$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((\.)+)([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2.$5.$8</span>$9', $this->code, -1, $f);
				
				$this->code = preg_replace('/([^;0-9])([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2 $5</span>$6', $this->code, -1, $g);
				$this->code = preg_replace('/([^;0-9])([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2-$5</span>$6', $this->code, -1, $h);
				$this->code = preg_replace('/([^;0-9])([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2.$5</span>$6', $this->code, -1, $i);
				
			//  I am guessing; not necessary
			//	$this->code = preg_replace('/(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+){0,1}([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '<span class="noWrap">$1 $4 $7</span>', $this->code, -1, $d);
			//	$this->code = preg_replace('/(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')){0,1}([0-9]{3})((' . implode("|", $this->dashes_array) . '))([0-9]{4})/is', '<span class="noWrap">$1-$4-$7</span>', $this->code, -1, $e);
			//	$this->code = preg_replace('/(\(?[0-9]{3}\)?)((\.)+){0,1}([0-9]{3})((\.)+)([0-9]{4})/is', '<span class="noWrap">$1.$4.$7</span>', $this->code, -1, $f);
				
			//	$this->code = preg_replace('/([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '<span class="noWrap">$1 $4</span>', $this->code, -1, $g);
			//	$this->code = preg_replace('/([0-9]{3})((' . implode("|", $this->dashes_array) . '))([0-9]{4})/is', '<span class="noWrap">$1-$4</span>', $this->code, -1, $h);
			//	$this->code = preg_replace('/([0-9]{3})((\.)+)([0-9]{4})/is', '<span class="noWrap">$1.$4</span>', $this->code, -1, $i);
			} else {
				//print('here33495905061<br>');
				//$this->code = preg_replace('/(1((\.|\-|' . $this->spaceRegex . ')+)){0,1}(\(?[0-9]{3}\)?((\.|\-|' . $this->spaceRegex . ')+)){0,1}([0-9]{3}((\.|\-|' . $this->spaceRegex . ')+)[0-9]{4})/is', '<span style="white-space: nowrap;">$0</span>', $this->code, -1, $a);
			//	$this->code = preg_replace('/(1((' . $this->spaceRegex . ')+)){0,1}(\(?[0-9]{3}\)?((' . $this->spaceRegex . ')+)){0,1}([0-9]{3}((' . $this->spaceRegex . ')+)[0-9]{4})/is', '<span style="white-space: nowrap;">$1 $4 $7 $10</span>', $this->code, -1, $a);
			//	$this->code = preg_replace('/(1)((' . implode("|", $this->dashes_array) . '))(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . '))([0-9]{3})((' . implode("|", $this->dashes_array) . '))([0-9]{4})/is', '<span style="white-space: nowrap;">$1-$4-$7-$10</span>', $this->code, -1, $b);
			//	$this->code = preg_replace('/(1)((\.)+){0,1}(\(?[0-9]{3}\)?)((\.)+){0,1}([0-9]{3})((\.)+)([0-9]{4})/is', '<span style="white-space: nowrap;">$1.$4.$7.$10</span>', $this->code, -1, $c);
				
			//	$this->code = preg_replace('/(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+){0,1}([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '<span style="white-space: nowrap;">$1 $4 $7</span>', $this->code, -1, $d);
			//	$this->code = preg_replace('/(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')){0,1}([0-9]{3})((' . implode("|", $this->dashes_array) . '))([0-9]{4})/is', '<span style="white-space: nowrap;">$1-$4-$7</span>', $this->code, -1, $e);
			//	$this->code = preg_replace('/(\(?[0-9]{3}\)?)((\.)+){0,1}([0-9]{3})((\.)+)([0-9]{4})/is', '<span style="white-space: nowrap;">$1.$4.$7</span>', $this->code, -1, $f);
				
			//	$this->code = preg_replace('/([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '<span style="white-space: nowrap;">$1 $4</span>', $this->code, -1, $g);
			//	$this->code = preg_replace('/([0-9]{3})((' . implode("|", $this->dashes_array) . '))([0-9]{4})/is', '<span style="white-space: nowrap;">$1-$4</span>', $this->code, -1, $h);
			//	$this->code = preg_replace('/([0-9]{3})((\.)+)([0-9]{4})/is', '<span style="white-space: nowrap;">$1.$4</span>', $this->code, -1, $i);
				
				$this->code = preg_replace('/([^;0-9])(1)((' . $this->spaceRegex . ')+)((\(?[0-9]{3}\)?)(' . $this->spaceRegex . ')+)([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2 $5 $8 $11</span>$12', $this->code, -1, $a);
				$this->code = preg_replace('/([^;0-9])(1)((' . implode("|", $this->dashes_array) . ')+)(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')+)([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2-$5-$8-$11</span>$12', $this->code, -1, $b);
				$this->code = preg_replace('/([^;0-9])(1)((\.)+)(\(?[0-9]{3}\)?)((\.)+)([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2.$5.$8.$11</span>$12', $this->code, -1, $c);
				
				$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+)([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2 $5 $8</span>$9', $this->code, -1, $d);
				$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')+)([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2-$5-$8</span>$9', $this->code, -1, $e);
				$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((\.)+)([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2.$5.$8</span>$9', $this->code, -1, $f);
				
				$this->code = preg_replace('/([^;0-9])([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2 $5</span>$6', $this->code, -1, $g);
				$this->code = preg_replace('/([^;0-9])([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2-$5</span>$6', $this->code, -1, $h);
				$this->code = preg_replace('/([^;0-9])([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2.$5</span>$6', $this->code, -1, $i);
			}
		} else {
			//print('here33495905062<br>');
			//$this->code = preg_replace('/(\([0-9]{3}\))(' . $this->spaceRegex . ')+([0-9]{3}\-[0-9]{4})/is', '$1&nbsp;$3', $this->code, -1, $b);
		//	$this->code = preg_replace('/(1)((' . $this->spaceRegex . ')+){0,1}(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+){0,1}([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '$1&nbsp;$4&nbsp;$7&nbsp;$10', $this->code, -1, $b);
		//	$this->code = preg_replace('/(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+){0,1}([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '$1&nbsp;$4&nbsp;$7', $this->code, -1, $c);
		//	$this->code = preg_replace('/([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '$1&nbsp;$4', $this->code, -1, $d);
	//		$this->code = preg_replace('/(1((' . $this->spaceRegex . ')+)){0,1}(\(?[0-9]{3}\)?((' . $this->spaceRegex . ')+)){0,1}([0-9]{3}((' . $this->spaceRegex . ')+)[0-9]{4})/is', '$1&nbsp;$4&nbsp;$7&nbsp;$10', $this->code, -1, $a);
	//		$this->code = preg_replace('/(1)((' . implode("|", $this->dashes_array) . '))(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . '))([0-9]{3})((' . implode("|", $this->dashes_array) . '))([0-9]{4})/is', '$1-$4-$7-$10', $this->code, -1, $b);
	//		$this->code = preg_replace('/(1)((\.)+){0,1}(\(?[0-9]{3}\)?)((\.)+){0,1}([0-9]{3})((\.)+)([0-9]{4})/is', '$1.$4.$7.$10', $this->code, -1, $c);
			
	//		$this->code = preg_replace('/(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+){0,1}([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '$1&nbsp;$4&nbsp;$7', $this->code, -1, $d);
	//		$this->code = preg_replace('/(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')){0,1}([0-9]{3})((' . implode("|", $this->dashes_array) . '))([0-9]{4})/is', '$1-$4-$7', $this->code, -1, $e);
	//		$this->code = preg_replace('/(\(?[0-9]{3}\)?)((\.)+){0,1}([0-9]{3})((\.)+)([0-9]{4})/is', '$1.$4.$7', $this->code, -1, $f);
			
	//		$this->code = preg_replace('/([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})/is', '$1&nbsp;$4', $this->code, -1, $g);
	//		$this->code = preg_replace('/([0-9]{3})((' . implode("|", $this->dashes_array) . '))([0-9]{4})/is', '$1-$4', $this->code, -1, $h);
	//		$this->code = preg_replace('/([0-9]{3})((\.)+)([0-9]{4})/is', '$1.$4', $this->code, -1, $i);
			
			$this->code = preg_replace('/([^;0-9])(1)((' . $this->spaceRegex . ')+)(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+)([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1$2&nbsp;$5&nbsp;$8&nbsp;$11$12', $this->code, -1, $a);
			$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((' . $this->spaceRegex . ')+)([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1$2&nbsp;$5&nbsp;$8$9', $this->code, -1, $d);
			$this->code = preg_replace('/([^;0-9])([0-9]{3})((' . $this->spaceRegex . ')+)([0-9]{4})([^;0-9])/is', '$1$2&nbsp;$5$6', $this->code, -1, $g);
			
			$this->code = preg_replace('/([^;0-9])(1)((\.)+)(\(?[0-9]{3}\)?)((\.)+)([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1$2.$5.$8.$11$12', $this->code, -1, $c);
			$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((\.)+)([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1$2.$5.$8$9', $this->code, -1, $f);
			$this->code = preg_replace('/([^;0-9])([0-9]{3})((\.)+)([0-9]{4})([^;0-9])/is', '$1$2.$5$6', $this->code, -1, $i);
			if(ReTidy::is_clf2()) {
				$this->code = preg_replace('/([^;0-9])(1)((' . implode("|", $this->dashes_array) . ')+)(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')+)([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2-$5-$8-$11</span>$12', $this->code, -1, $b);
				$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')+)([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2-$5-$8</span>$9', $this->code, -1, $e);
				$this->code = preg_replace('/([^;0-9])([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span class="noWrap">$2-$5</span>$6', $this->code, -1, $h);
			} else {
				$this->code = preg_replace('/([^;0-9])(1)((' . implode("|", $this->dashes_array) . ')+)(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')+)([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2-$5-$8-$11</span>$12', $this->code, -1, $b);
				$this->code = preg_replace('/([^;0-9])(\(?[0-9]{3}\)?)((' . implode("|", $this->dashes_array) . ')+)([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2-$5-$8</span>$9', $this->code, -1, $e);
				$this->code = preg_replace('/([^;0-9])([0-9]{3})((' . implode("|", $this->dashes_array) . ')+)([0-9]{4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2-$5</span>$6', $this->code, -1, $h);
			}
		}
		$count = $a + $b + $c + $d + $e + $f + $g + $h + $i;
		//$count = $a + $b + $c;
		//var_dump($a, $b, $c, $d, $e);
		$this->logMsgIf("non_breaking_phone_number", $count);
	}
	
	protected function non_breaking_date() {
		// will using unmarked abbreviations (ex. Sept) cause problems? should be minor
		$english_months_array = array(
		// month => variations
		'January' => array('Jan.', 'Jan'),
		'February' => array('Feb.', 'Feb'),
		'March' => array('Mar.', 'Mar'),
		'April' => array('Apr.', 'Apr'),
		'May' => array(),
		'June' => array('Jun.', 'Jun'),
		'July' => array('Jul.', 'Jul'),
		'August' => array('Aug.', 'Aug'),
		'September' => array('Sept.', 'Sept'),
		'October' => array('Oct.', 'Oct'),
		'November' => array('Nov.', 'Nov'),
		'December' => array('Dec.', 'Dec'),
		);
		$french_months_array = array(
		// month => variations
		'janvier' => array('jan.', 'jan'),
		'février' => array('fév.', 'fév', 'f&#233;vrier', 'f&#233;v.', 'f&#233;v', 'f&#xe9;vrier', 'f&#xe9;v.', 'f&#xe9;v', 'f&eacute;vrier', 'f&eacute;v.', 'f&eacute;v'),
		'mars' => array('mar.', 'mar'),
		'avril' => array('avr.', 'avr'),
		'mai' => array(),
		'juin' => array(),
		'juillet' => array('juil.', 'juil'),
		'août' => array('ao&#251;t', 'ao&#xfb;t', 'ao&ucirc;t'),
		'septembre' => array('sept.', 'sept'),
		'octobre' => array('oct.', 'oct'),
		'novembre' => array('nov.', 'nov'),
		'décembre' => array('déc.', 'déc', 'd&#233;cembre', 'd&#233;c.', 'd&#233;c', 'd&#xe9;cembre', 'd&#xe9;c.', 'd&#xe9;c', 'd&eacute;cembre', 'd&eacute;c.', 'd&eacute;c'),
		);
		$english_seasons_array = array(
		'Spring',
		'Summer',
		'Fall',
		'Winter',
		);
		$french_seasons_array = array(
		'printemps',
		'été', '&#233;t&#233;', '&#xe9;t&#xe9;', '&eacute;t&eacute;',
		'automne',
		'hiver',
		);
		$time_periods_array = array();
		foreach($english_months_array as $month => $variations_array) {
			$time_periods_array[] = $month;
			foreach($variations_array as $variation) {
				$time_periods_array[] = $variation;
			}
		}
		foreach($french_months_array as $month => $variations_array) {
			$time_periods_array[] = $month;
			foreach($variations_array as $variation) {
				$time_periods_array[] = $variation;
			}
		}
		foreach($english_seasons_array as $season) {
			$time_periods_array[] = $season;
		}
		foreach($french_seasons_array as $season) {
			$time_periods_array[] = $season;
		}
		if($this->config['non_breaking_type'] === 'noWrap') {
			if(ReTidy::is_clf2()) {
				$this->code = preg_replace('/(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{1,2},*)(' . $this->spaceRegex . ')+([0-9]{4})/is', '<span class="noWrap">$1 $3 $5</span>', $this->code, -1, $a);
				$this->code = preg_replace('/([0-9]{1,2})(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ',*)(' . $this->spaceRegex . ')+([0-9]{4})/is', '<span class="noWrap">$1 $3 $5</span>', $this->code, -1, $b);
				$this->code = preg_replace('/(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{1,4},*)/is', '<span class="noWrap">$1 $3</span>', $this->code, -1, $c);
				$this->code = preg_replace('/([0-9]{1,2})(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ',*)/is', '<span class="noWrap">$1 $3</span>', $this->code, -1, $d);
			} else {
				$this->code = preg_replace('/(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{1,2},*)(' . $this->spaceRegex . ')+([0-9]{4})/is', '<span style="white-space: nowrap;">$1 $3 $5</span>', $this->code, -1, $a);
				$this->code = preg_replace('/([0-9]{1,2})(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ',*)(' . $this->spaceRegex . ')+([0-9]{4})/is', '<span style="white-space: nowrap;">$1 $3 $5</span>', $this->code, -1, $b);
				$this->code = preg_replace('/(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{1,4},*)/is', '<span style="white-space: nowrap;">$1 $3</span>', $this->code, -1, $c);
				$this->code = preg_replace('/([0-9]{1,2})(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ',*)/is', '<span style="white-space: nowrap;">$1 $3</span>', $this->code, -1, $d);
			}
		} else { // default to nbsp
			$this->code = preg_replace('/(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{1,2},*)(' . $this->spaceRegex . ')+([0-9]{4})/is', '$1&nbsp;$3&nbsp;$5', $this->code, -1, $a);
			$this->code = preg_replace('/([0-9]{1,2})(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ',*)(' . $this->spaceRegex . ')+([0-9]{4})/is', '$1&nbsp;$3&nbsp;$5', $this->code, -1, $b);
			$this->code = preg_replace('/(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{1,4},*)/is', '$1&nbsp;$3', $this->code, -1, $c);
			$this->code = preg_replace('/([0-9]{1,2})(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ',*)/is', '$1&nbsp;$3', $this->code, -1, $d);
			
		}
		if(ReTidy::is_clf2()) {
			//$this->code = preg_replace('/([^;0-9])([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})([^;0-9])/is', '$1<span class="noWrap">$2&ndash;$4&ndash;$6</span>$7', $this->code, -1, $e);
			//$this->code = preg_replace('/([^;0-9])(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{2,4})(' . $this->spaceRegex . ')+(' . implode("|", $this->dashes_array) . ')(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{2,4})([^;0-9])/is', '$1<span class="noWrap">$2&nbsp;$4&nbsp;&ndash;&nbsp;$8&nbsp;$10</span>$11', $this->code, -1, $f);
			$this->code = preg_replace('/([^;0-9])([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})([^;0-9])/is', '$1<span class="noWrap">$2$3$4$5$6</span>$7', $this->code, -1, $e);
			$this->code = preg_replace('/([^;0-9])(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{2,4})(' . $this->spaceRegex . ')+(' . implode("|", $this->dashes_array) . ')(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{2,4})([^;0-9])/is', '$1<span class="noWrap">$2&nbsp;$4&nbsp;$6&nbsp;$8&nbsp;$10</span>$11', $this->code, -1, $f);
		} else {
			//$this->code = preg_replace('/([^;0-9])([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2&ndash;$4&ndash;$6</span>$7', $this->code, -1, $e);
			//$this->code = preg_replace('/([^;0-9])(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{2,4})(' . $this->spaceRegex . ')+(' . implode("|", $this->dashes_array) . ')(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{2,4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2&nbsp;$4&nbsp;&ndash;&nbsp;$8&nbsp;$10</span>$11', $this->code, -1, $f);
			$this->code = preg_replace('/([^;0-9])([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})(' . implode("|", $this->dashes_array) . ')([0-9]{2,4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2$3$4$5$6</span>$7', $this->code, -1, $e);
			$this->code = preg_replace('/([^;0-9])(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{2,4})(' . $this->spaceRegex . ')+(' . implode("|", $this->dashes_array) . ')(' . $this->spaceRegex . ')+(' . implode("|", $time_periods_array) . ')(' . $this->spaceRegex . ')+([0-9]{2,4})([^;0-9])/is', '$1<span style="white-space: nowrap;">$2&nbsp;$4&nbsp;$6&nbsp;$8&nbsp;$10</span>$11', $this->code, -1, $f);
		}
		//$this->logMsgIf("non_breaking_year_range", $count);
		$count = $a + $b + $c + $d + $e + $f;
		//var_dump($a, $b, $c, $d, $e, $f);
		$this->logMsgIf("non_breaking_date", $count);
	}
	
	protected function clean_nowrap() {
		// ideally we would like to search the CSS to find which class is used to prevent wrapping but even then, if the stylesheets are not properly attached we will not have success
		$array_common_nowrap_classes = array('noWrap', 'wrap-none');
		$nowrap_string = '(' . implode('|', $array_common_nowrap_classes) . ')';
		preg_match_all('/<(\w+)[^<>]*? class="[^"]*?' . $nowrap_string . '[^"]*?"[^<>]*?>/is', $this->code, $no_wrap_matches, PREG_OFFSET_CAPTURE);
		$counter = sizeof($no_wrap_matches[0]) - 1;
		while($counter >= 0) {
			$offset = $no_wrap_matches[0][$counter][1];
			$tagname = $no_wrap_matches[1][$counter][0];
			$no_wrap_tag = OM::getOString($this->code, '<' . $tagname, '</' . $tagname . '>', $offset);
			$strlen = strlen($no_wrap_tag);
			$substr = substr($no_wrap_tag, strlen($tagname) + 1, $strlen - strlen($tagname) - strlen($tagname) - 4);
			$substr = str_replace('<span style="white-space: nowrap;">', '<span stripme="y">', $substr);
			//$substr = str_replace('<span class="noWrap">', '<span stripme="y">', $substr);
			foreach($array_common_nowrap_classes as $index => $class) {
				$substr = str_replace('<span class="' . $class . '">', '<span stripme="y">', $substr);
			}
			$this->code = substr($this->code, 0, $offset) . '<' . $tagname . $substr . '</' . $tagname . '>' . substr($this->code, $strlen + $offset);
			$counter--;
		}
		preg_match_all('/<(\w+)[^<>]*? style="[^"]*?white\-space\s*:\s*nowrap\s*;*[^"]*?"[^<>]*?>/is', $this->code, $white_space_no_wrap_matches, PREG_OFFSET_CAPTURE);
		$counter = sizeof($white_space_no_wrap_matches[0]) - 1;
		while($counter >= 0) {
			$offset = $white_space_no_wrap_matches[0][$counter][1];
			$tagname = $white_space_no_wrap_matches[1][$counter][0];
			$white_space_no_wrap_tag = OM::getOString($this->code, '<' . $tagname, '</' . $tagname . '>', $offset);
			$strlen = strlen($white_space_no_wrap_tag);
			$substr = substr($white_space_no_wrap_tag, strlen($tagname) + 1, $strlen - strlen($tagname) - strlen($tagname) - 4);
			$substr = str_replace('<span style="white-space: nowrap;">', '<span stripme="y">', $substr);
			//$substr = str_replace('<span class="noWrap">', '<span stripme="y">', $substr);
			foreach($array_common_nowrap_classes as $index => $class) {
				$substr = str_replace('<span class="' . $class . '">', '<span stripme="y">', $substr);
			}
			$this->code = substr($this->code, 0, $offset) . '<' . $tagname . $substr . '</' . $tagname . '>' . substr($this->code, $strlen + $offset);
			$counter--;
		}
		ReTidy::post_dom();
	}
	
	protected function checkWithSymbol($working_symbol_string, $prefix_symbol, $unit_symbol, $blank_footnote) {
		if(strpos($working_symbol_string, strrev($prefix_symbol . $unit_symbol)) === 0) {
			if($working_symbol_string[strlen($prefix_symbol . $unit_symbol)] === " " ||
			$working_symbol_string[strlen($prefix_symbol . $unit_symbol)] === "/" ||
			$working_symbol_string[strlen($prefix_symbol . $unit_symbol)] === "·") {
				$blank_footnote->setAttribute("stripme", "y");
				ReTidy::DOM_strip_node($blank_footnote);
				return true;
			}
			foreach($this->units as $unit_symbol2 => $unit_name2) {
				$string330 = substr($working_symbol_string, strlen($prefix_symbol . $unit_symbol), strlen($unit_symbol2));
				if(strrev($unit_symbol2) === $string330) {
					$blank_footnote->setAttribute("stripme", "y");
					ReTidy::DOM_strip_node($blank_footnote);
					return true;
				}							
			}
		}
	}
	protected function checkWithName($working_name_string, $prefix_name, $unit_name, $blank_footnote) {
		if(is_array($unit_name)) {
			foreach($unit_name as $index4 => $unit_name4) {
				if(ReTidy::checkWithName($working_name_string, $prefix_name, $unit_name4, $blank_footnote, $units)){
					return true;
				}
			}
			return false;
		}
		if(is_array($prefix_name)) {
			foreach($prefix_name as $index4 => $prefix_name4) {
				if(ReTidy::checkWithName($working_name_string, $prefix_name4, $unit_name, $blank_footnote, $units)){
					return true;
				}
			}
			return false;
		}		
		if(strpos($working_name_string, strrev($prefix_name . $unit_name)) === 0) {
			if($working_name_string[strlen($prefix_name . $unit_name)] === " " ||
			$working_name_string[strlen($prefix_name . $unit_name)] === "/" ||
			$working_name_string[strlen($prefix_name . $unit_name)] === "·") {
				$blank_footnote->setAttribute("stripme", "y");
				ReTidy::DOM_strip_node($blank_footnote);
				return true;						
			}
			foreach($this->units as $unit_symbol2 => $unit_name2) {
				if(is_array($unit_name2)) {
					foreach($unit_name2 as $index6 => $unit_name6) {
						$string333 = substr($working_name_string, strlen($prefix_name . $unit_name), strlen($unit_name6));
						if(strrev($unit_name6) === $string333) {
							$blank_footnote->setAttribute("stripme", "y");
							ReTidy::DOM_strip_node($blank_footnote);
							return true;						
						}
					}
				}
				$string331 = substr($working_name_string, strlen($prefix_name . $unit_name), strlen($unit_name2));
				if(strrev($unit_name2) === $string331) {
					$blank_footnote->setAttribute("stripme", "y");
					ReTidy::DOM_strip_node($blank_footnote);
					return true;						
				}							
			}
		}
	}	
		
	protected function getPreviousText($node) {
		$containingBlockNode = ReTidy::DOM_getContainingBlock($node);
		$tagless = ReTidy::tagless($containingBlockNode);
		// check if there is already a marker in the containing block node
		preg_match_all('/XXX9o9TextMarker9o9XXX([0-9]*)XXX/is', $tagless, $text_marker_matches);
		$size = sizeof($text_marker_matches[0]);
		if($size > 0) {
			$text_marker_count = $text_marker_matches[1][$size-1] + 1;
		} else {
			$text_marker_count = 1;
		}
		// mark the text in node
		$node->parentNode->insertBefore($new_node = new DOMText("XXX9o9TextMarker9o9XXX" . $text_marker_count . "XXX"), $node);
		$tagless2 = ReTidy::tagless($containingBlockNode);
		$position = strpos($tagless2, "XXX9o9TextMarker9o9XXX" . $text_marker_count . "XXX");
		$new_node->nodeValue = "";
		return substr($tagless2, 0, $position);
	}
	
	protected function DOM_getContainingBlock($node) {
		$blockTagNames = DTD::getBlock();
		return ReTidy::getAncestorOfNodeNamed($node, $blockTagNames);
	}
	
	protected function getAncestorOfNodeNamed($node, $string) {
		if($parentNode = $node->parentNode) {
			
		} else {
			return false;
		}
		if(strpos($string, "|") !== false) {
			$arrayTagNames = explode("|", $string);
			foreach($arrayTagNames as $TagName) {
				if($parentNode->nodeName === $TagName) {
					return $parentNode;
				}
			}
			return ReTidy::getAncestorOfNodeNamed($parentNode, $string);
		} else {
			if($parentNode->nodeName === $string) {
				return $parentNode;
			} else {
				return ReTidy::getAncestorOfNodeNamed($parentNode, $string);
			}
		}
	}
	
	protected function getNodeAncestry($node) {
		return DOM_getNodeAncestry($node);
	}
	
	protected function DOM_getNodeAncestry($node) {
		if($parentNode = $node->parentNode) {
			
		} else {
			return false;
		}
		$array_ancestors = array($parentNode->nodeName);
		while($parentNode = $parentNode->parentNode) {
			$array_ancestors[] = $parentNode->nodeName;
		}
		return $array_ancestors;
	}
	
	protected function SIRCRxp () {
		$c = $ct = 0;
		foreach($this->config['SIRCRxp'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("SIRCRxp[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("SIRCRxp", $ct);
		return true;
	}

	protected function encode_ampersands_in_links () {
		// although tidy may do this.
		preg_match_all('/(href="([^"]*)")/', $this->code, $matches);
		$c = $ct = 0;
		foreach($matches[0] as $index => $match) {
			$initial_match = $match;
			$match = str_replace('&', '&amp;', $match);
			$match = str_replace('&amp;amp;', '&amp;', $match);			
			if($initial_match !== $match) {
				var_dump($initial_match);print("<br>\r\n");
				var_dump($match);print("<br>\r\n");
				$this->code = str_replace($initial_match, $match, $this->code, $c);			
				$ct += $c;
			}
		}
		$this->logMsgIf("encode_ampersands_in_links", $ct);
		return true;
	}

	protected function unencode_entities_in_attributes() {
		preg_match_all('/((\w*)="([^"]*)")/', $this->code, $matches);
		$c = $ct = 0;
		foreach($matches[0] as $index => $match) {
			if($matches[2][$index] === "href") {
				// we want to leave entities encoded in href attributes
				continue;
			}
			$initial_match = $match;
			$match = html_entity_decode($match);
			if($initial_match !== $match) {
				$this->code = str_replace($initial_match, $match, $this->code, $c);			
				$ct += $c;
			}
		}
		$this->logMsgIf("unencode_entities_in_attributes", $ct);
		return true;
	}

	protected function basictypicalrxp () {
		if(!is_array($this->config['basictypicalrxp'])) return false;
		$c = $ct = 0;
		foreach($this->config['basictypicalrxp'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("basictypicalrxp[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		return true;
	}
	
	protected function basictypicalrxp2 () {
		if(!is_array($this->config['basictypicalrxp2'])) return false;
		$c = $ct = 0;
		foreach($this->config['basictypicalrxp2'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("basictypicalrxp2[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("basictypicalrxp2", $ct);
		return true;
	}
	
	protected function SIRCPre () {
		foreach($this->config['SIRCPre'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("SIRCPre[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("SIRCPre", $ct);
		return true;
	}

	protected function INACRep() {
		if(!is_array($this->config['INACRep'])) return false;
		foreach($this->config['INACRep'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("INACRep[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INACRep", $ct);
		return true;
	}
	
	protected function remove_default_attributes() {
		$arrayDefaultAttributes = array(
		' shape="rect"',
		' rowspan="1"',
		' colspan="1"',
		' type="1"',
		' start="1"',
		//' xml:space="preserve"',
		);
		foreach($arrayDefaultAttributes as $defaultAttribute) {
			$this->code = str_replace($defaultAttribute, '', $this->code, $c);
			$ct += $c;
		}
		$arrayDefaultAttributesOnTags = array(
		' align="left"' => array('p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr'),
		);
		foreach($arrayDefaultAttributesOnTags as $defaultAttribute => $tagsArray) {
			$tagsString = implode('|', $tagsArray);
			$this->code = preg_replace('/<(' . $tagsString . ')([^<>]*)' . $defaultAttribute . '([^<>]*)>/is', '<$1$2$3>', $this->code, -1, $d);
			$ct += $d;
		}		
		$this->logMsgIf("remove_default_attributes", $ct);
	}
	
	protected function socioeconomic() {
		$this->code = preg_replace('/<p[^<>]*>(Source.*?)<\/p>/is', '<div class="source">$1</div>', $this->code);
		$this->logMsgIf("socioeconomic", $ct);
		return true;
	}
	
	protected function lang() {
		// we should use DOM for this...
		if($this->language === "french") {
			foreach($this->config['lang_fr'] as $tag_name) {
				$this->code = preg_replace('/<' . $tag_name . '([^<>]*)>/', '<' . $tag_name . ' lang="fr" xml:lang="fr"$1>', $this->code);
				$this->code = preg_replace('/<' . $tag_name . ' lang="fr" xml:lang="fr"([^<>]*) lang="fr" xml:lang="fr"([^<>]*)>/', '<' . $tag_name . ' lang="fr" xml:lang="fr"$1$2>', $this->code);				
			}
		}
		if($this->language === "english_and_french") {
			preg_match_all('/<body[^<>]*>(.*?)<\/body>/is', $this->code, $matches);
			$initial_body_code = $body_code = $matches[1][0];
			$replace_count = -1;
			while($replace_count != 0) {
				$body_code = preg_replace('/<(\w*)([^<>]*)>\s*([^<>\/]*[^\s])\s*\/\s*([^<>\/]{1,})\s*</is', '<$1$2><span lang="en" xml:lang="en">$3</span> / <span lang="fr" xml:lang="fr">$4</span><', $body_code, -1, $replace_count);
			}
			$this->code = str_replace($initial_body_code, $body_code, $this->code);
		}
		$this->logMsgIf("lang", $ct);
		return true;
	}	
	
	function isPunctuation($string) {
		//preg_match('/[,~`!\-=\+\\\|:;"\'<>,\.\?\/]*/is', $string, $matches);
		preg_match('/[,~`!\-=\+\\\|:;"\'<>,\.\/]*/is', $string, $matches);
		if(strlen($string) === strlen($matches[0])) {
			return true;
		} else {
			return false;
		}
	}
	
	function hasPunctuationAtTheEnd($string) {
		var_dump($string);
		$rev_string = strrev($string);
		preg_match('/dna ;|[,~`!\-=\+\\\|:;"\'<>,\.\?\/]*/is', $rev_string, $matches, PREG_OFFSET_CAPTURE);
		if($matches[0][1] === 0) {
			return true;
		} else {
			return false;
		}
	}
	
	function isIndexical($string) {
		//print("here2900-4-219<br>\r\n");
		if(stripos($string, ' class="sweeper-not-indexical"') !== false) {
			return false;
		}
		if($this->config['trust_headings'] === true && !$this->finding_TOC) {
			//print("here2900-4-220<br>\r\n");
			preg_match('/<h([1-6])/is', $string, $heading_matches, PREG_OFFSET_CAPTURE);
			if($heading_matches[0][1] === 0) {
				return true;
			}
			//return false;
		}// else {
			//print("here2900-4-221<br>\r\n");
			//print("string: ");var_dump($string);
			// first allow the case of <caption>s
			if(strpos($string, "<caption>") !== false) {
				return true;
			}
			// second; call images non-indexical
			if(strpos($string, "<img") !== false) {
				return false;
			}
			if(stripos($string, "canada") !== false && stripos($string, "ottawa") !== false) { // very specific case...; we call this an address section
				return false;
			}
			// fourth check if it is not indexical by virtue of being a naturally structuring tag (that has a normal amount of content pieces)
			if(!$this->links_indexical) { // in other words, not obviously, if we are normalizing indexical content
				$array_content_pieces = array(
					'<li',
					'<td',
					'<th',
				);
				foreach($array_content_pieces as $content_piece) {
					if(substr_count($string, $content_piece) > 1) {
						//print("here2900-4-222<br>\r\n");
						return false;
					}
				}
			}
			$array_non_heading_tags = array(
			'blockquote',
			);
			//print("here2900-4-222.5<br>\r\n");
			foreach($array_non_heading_tags as $non_heading_tag_name) { // if the text is in one of these tags, we call it non-indexical
				//$ancestryArray = OM::getAncestryArray($string);
				//var_dump($ancestryArray);
				if(strpos($string, '<' . $non_heading_tag_name) !== false) {
					//print("here2900-4-223<br>\r\n");
					return false;
				}
			}
			// ignore contact sections... this simplistic search may do something.
			if((stripos($string, "telephone:") !== false && stripos($string, "fax:") !== false) ||
			(stripos($string, "téléphone :") !== false && stripos($string, "télécopieur :") !== false) || 
			preg_match('/[^0-9][0-9]{3}-[0-9]{4}/', $string) /* or it matches a telephone number (but not a year range) */ ) {
				//print("here2900-4-223.5<br>\r\n");
				return false;
			}
			//print('$this->findingTOC: ');var_dump($this->findingTOC);
			//print('$this->foundTOC: ');var_dump($this->foundTOC);
			//print('found a href: ');var_dump(strpos($string, '<a href=') !== false);
			if(stripos($string, '<a href=') !== false) {
				if(stripos($string, '.pdf') !== false && (stripos($string, 'Download') !== false || stripos($string, 'T&eacute;l&eacute;charger') !== false || stripos($string, 'Télécharger') !== false)) { // we call this a download PDF link and not indexical over web pages
					return false;
				}
				if(!$this->findingTOC) {
					// only allow links to be indexical in the table of contents (this is currently only an approximation; TOC non-existent rather than
					// not being in TOC)
					//print("here2900-4-224<br>\r\n");
					return false;
				}
			}
			//print('$string: ');var_dump($string);
			//$string = htmlentities($string); // convert raw non-breaking spaces into character entities?
			$normalizedString = preg_replace('/&[^&;\s]+;/is', '*', $string);
			$trimmed_tagless_string = ReTidy::trim_nbsp(ReTidy::taglessBracketless($normalizedString));
			//print('$trimmed_tagless_string: ');var_dump($trimmed_tagless_string);
			//print('strlen($trimmed_tagless_string): ');var_dump(strlen($trimmed_tagless_string));
			/*$counter77 = 0;
			while($counter77 < strlen($trimmed_tagless_string)) {
				print('ord($trimmed_tagless_string[$counter77]): ' . ord($trimmed_tagless_string[$counter77]) . '<br>');
				$counter77++;
			}*/
			if(strlen($trimmed_tagless_string) === 0) {
				//print("here2900-4-225<br>\r\n");
				return false;
			}
			// for CED (and maybe other) top of page links
			if($trimmed_tagless_string === "Top of Page" || $trimmed_tagless_string === "Haut de la page") {
				//print("here2900-4-226<br>\r\n");
				return false;
			}
			$rev_string = strrev($trimmed_tagless_string);
			if(strpos($rev_string, 'dna ;') === 0 || strpos($rev_string, 'dna;') === 0) {
				return false;
			}
			$last_character = $rev_string[0];
			$counter = 0;
			// trim characters before the last character we are interested in
			while(preg_match('/["\'«»‘’“”„‹›]/is', $last_character)) {
				$counter++;
				$last_character = $rev_string[$counter];
			}
			if(ReTidy::isPunctuation($last_character)) { // it ends with punctuation, then call it non-indexical
				//print("here2900-4-227<br>\r\n");
				return false;
			}
			$length_trimmed_tagless_string = strlen($trimmed_tagless_string);
			$isIndexical = ($length_trimmed_tagless_string < 300 && $length_trimmed_tagless_string > 1);
			//print("isIndexical: ");var_dump($isIndexical);
			return $isIndexical;
		//}
	}
	
	protected function taglessSingleCharactersify($string) {
		// we could theoretically (and probably easily) convert character entities to their single character equivalents
		// but this function is only currently being used for headings determination (in table of contents and content)
		$string = ReTidy::tagless($string);
		//print('tagless: ');var_dump($string);
		$string = ReTidy::trim_nbsp($string);
		//print('trim_nbsp: ');var_dump($string);
		$string = preg_replace('/&[^&;\s]+;/is', '*', $string);
		//print('single chars: ');var_dump($string);
		$string = preg_replace('/\s{1,}/is', ' ', $string);
		//print('single spaces: ');var_dump($string);
		return $string;
	}
	
	protected function singleCharactersify($string) {
		// we could theoretically (and probably easily) convert character entities to their single character equivalents
		// but this function is only currently being used for headings determination (in table of contents and content)
		$trimmed_tagless_string = $string;
		print('maybe this function (singleCharactersify) should not be used');exit(0);
		$trimmed_tagless_string = ReTidy::trim_nbsp(ReTidy::tagless($trimmed_tagless_string));
		$trimmed_tagless_string = preg_replace('/&[^&;\s]+;/is', '*', $trimmed_tagless_string);
		$trimmed_tagless_string = preg_replace('/\s{1,}/is', ' ', $trimmed_tagless_string);
		return $trimmed_tagless_string;
	}
	
	protected function getTOCArray() {
		// obsolete (2011-09-12)
		$blockString = DTD::getBlock() . '|li|td|th|caption';
		$blockString = str_replace('|ul', '', $blockString);
		$blockString = str_replace('|ol', '', $blockString);
		$blockString = str_replace('|dl', '', $blockString);
		
		preg_match_all('/<(' . $blockString . ')([^<>]*)>(\s*<[^<>]*>){0,}\s*((TABLE OF CONTENTS)|(Table des mati)|(TABLE DES MATI)|(INDEX))/is', $this->code, $matches, PREG_OFFSET_CAPTURE);
		if(sizeof($matches[0]) === 0) {
			// did not find a table of contents
			$this->foundTOC = false;
			return false;
		}
		$returnArray = array();
		foreach($matches[0] as $index => $value) {
			$position_of_table = $matches[4][$index][1];
			$blockArray = OM::getContainingBlock($this->code, $position_of_table, $blockString);
			$begin_position = $position_of_table - $blockArray[1];
			$heading_string = $blockArray[0];
			$TOCString = OM::getTOCString2($this->code, $begin_position);
			// we are adding rather than identifying the array on the next line because of the possibility of having multiple tables of contents
			// (which will have repercussions for the structure functions that will need to be considered).
			$returnArray[] = array($TOCString, $heading_string);
		}
		$this->foundTOC = true;
		$this->TOCArray = $returnArray;
		return $returnArray;
	}

	protected function TOC() {
		$blockString2 = DTD::getBlock() . '|li|td|th|caption';
		$TOCArray = ReTidy::getTOCArray();
		if(sizeof($TOCArray) > 0) {
			foreach($TOCArray as $index => $value) {
				$TOC = $value[0];
				$heading_string = $value[1];
				$initial_toc_string = $toc_string = substr($TOC, strlen($heading_string));

				// first apply anchors to headings and links in the table of contents (this is already done by the word save as filtered html).
		
				// remove any anchors in the table of contents.		
				//$toc_string = preg_replace('/<a [^<>]*><\/a>/is', '', $toc_string);
		
				// remove headings in the table of contents. 
				// this should be done while cleaning word
				$toc_string = preg_replace('/<h[1-6]/is', '<p', $toc_string);
				$toc_string = preg_replace('/<\/h[1-6]>/is', '</p>', $toc_string);
		
				// try to get rid of page references: (if necessary)
				//$toc_string = preg_replace('/\s*<strong>[0-9]*<\/strong><\/p>/is', '</p>', $toc_string);
				//$toc_string = preg_replace('/\s*[0-9]*<\/p>/is', '</p>', $toc_string);
				//$toc_string = preg_replace('/<p[^<>]*>\s*Page\s*<\/p>/is', '', $toc_string);
				
				//$toc_string = preg_replace('/<p[^<>]*>/is', '<p>', $toc_string);
				
				// get rid of classes
				$toc_string = preg_replace('/ class="[^"]*"/is', '', $toc_string);
				
				$last_grand_section = "";
				$array_anchor_replaces = array();

				preg_match_all('/<a href="#(_Toc[0-9]*)">((Table(au){0,1} [0-9]*(\.|:|&#160;:|&nbsp;:| :| :))|[^\s]*)\s{0,}/is', $toc_string, $matches7);
				foreach($matches7[0] as $index => $value) {
					$level = 2; // default (<h2>)
					$anchor = $matches7[1][$index];
					$section = $matches7[2][$index];
					$section = ReTidy::tagless($section);
					preg_match('/[a-z]*([\.\)])/is', $section, $matches8);
					preg_match('/[0-9]*([\.\)])/is', $section, $matches9);				
					if($section === $matches8[0]) { // is a letter
						$section = $last_number . "_" . substr($section, 0, strpos($section, $matches8[1]));
						$level = 3;
					}
					if($section === $matches9[0]) { // is a number
						$last_number = substr($section, 0, strpos($section, $matches9[1]));
						if (strlen($last_grand_section) === 0) {
							$level = 2;
						} else {
							$level = 3;
						}
						$section = $last_grand_section . substr($section, 0, strpos($section, $matches9[1]));
					}
					if(strpos(strtolower($section), "table") === 0) { // is a table
						$section = substr($section, 0, strpos($section, $matches7[5][$index]));
						$level = 0;						
					}
					if(strpos(strtolower($section), "appendi") === 0) { // is an appendix
						$last_grand_section = "app";
						$level = 2;						
					}
					if(strpos(strtolower($section), "annex") === 0) { // is an annex
						$last_grand_section = "ann";
						$level = 2;						
					}								
					$section = preg_replace('/[\s\.]/is', '_', $section);
					$array_anchor_replaces[] = array($anchor, $section, $level);
				}

				foreach($array_anchor_replaces as $index => $value) {
					$search = $value[0];
					$replace = $value[1];
					if(strlen($replace) > 0) {
						$toc_string = str_replace($search, $replace, $toc_string);
					}
				}
				foreach($array_anchor_replaces as $index => $value) {
					$search = $value[0];
					$replace = $value[1];
					$level = $value[2];
					preg_match('/<(p|li)>(<a href="#' . ReTidy::preg_escape($replace) . '".*?)<\/\1>/is', $toc_string, $matches003);
					$new_item = $item = $matches003[0];
					$item_inner = $matches003[1];
					if($this->config["TOC_sub"] === "indent") {
						if($level === 0 || $level === 3) {
							$new_item = '<p class="indent1">' . $item_inner . '</p>';
						}
						if($level === 4) {
							$new_item = '<p class="indent2">' . $item_inner . '</p>';
						}
						if($level === 5) {
							$new_item = '<p class="indent3">' . $item_inner . '</p>';
						}
						if($level === 6) {
							$new_item = '<p class="indent4">' . $item_inner . '</p>';
						}															
					} else {
						if($level === 0 || $level === 3) {
							$new_item = '<ul><li>' . $item_inner . '</li></ul>';
						}
						if($level === 4) {
							$new_item = '<ul><li><ul><li>' . $item_inner . '</li></ul></li></ul>';
						}
						if($level === 5) {
							$new_item = '<ul><li><ul><li><ul><li>' . $item_inner . '</li></ul></li></ul></li></ul>';
						}
						if($level === 6) {
							$new_item = '<ul><li><ul><li><ul><li><ul><li>' . $item_inner . '</li></ul></li></ul></li></ul></li></ul>';
						}
					}
					$toc_string = str_replace($item, $new_item, $toc_string);
				}
				$toc_string = preg_replace('/<ul>\s*<ul>/is', '<ul>', $toc_string);
				$toc_string = preg_replace('/<\/ul>\s*<\/ul>/is', '</ul>', $toc_string);
				$this->code = str_replace($initial_toc_string, $toc_string, $this->code);

				// having finished with the table of contents, I think we here deal with the anchors.
				foreach($array_anchor_replaces as $index => $value) {
					$search = $value[0];
					$replace = $value[1];
					$level = $value[2];
					if(strlen($replace) === 0) {
						continue;
					}
					$this->code = str_replace($search, $replace, $this->code);
					$position_of_anchor = strpos($this->code, 'name="' . $replace . '"');
					$string4320 = substr($this->code, 0, $position_of_anchor);
					preg_match('/>(p|[1-6]h)</is', strrev($string4320), $matches004, PREG_OFFSET_CAPTURE);
					$offset3943 = $position_of_anchor-$matches004[0][1]-10;
					preg_match('/<(p|h[1-6])>(.*?name="' . ReTidy::preg_escape($replace) . '".*?)<\/\1>/is', $this->code, $matches008, PREG_OFFSET_CAPTURE, $offset3943);
					$item = $matches008[0][0];
					$item_inner = $matches008[2][0];
					$blockString = "|" . DTD::getBlock() . "|table|tr|td|th|li";
					$blockString = str_replace('|', '|<', $blockString);
					$blockString = substr($blockString, 1);
					preg_match('/' . $blockString . '/is', $item_inner, $matches393);
					if(sizeof($matches393) === 0) {
						if($level === 0) {
							$new_item = '<p>' . $item_inner . '</p>';
						}
						if($level === 2) {
							$new_item = '<h2>' . $item_inner . '</h2>';
						}
						if($level === 3) {
							$new_item = '<h3>' . $item_inner . '</h3>';
						}
						if($level === 4) {
							$new_item = '<h4>' . $item_inner . '</h4>';
						}
						if($level === 5) {
							$new_item = '<h5>' . $item_inner . '</h5>';
						}
						if($level === 6) {
							$new_item = '<h6>' . $item_inner . '</h6>';
						}
						$this->code = str_replace($item, $new_item, $this->code);
					}
					$containingBlockArray = OM::getContainingBlockString($this->code, strpos($this->code, ' name="' . $replace . '"'), $blockString2);
					if($containingBlockArray !== false) {
						$stringOfBlockWithAnchor = $containingBlockArray[0];
						$pos_closing_bracket = strpos($stringOfBlockWithAnchor, '>');
						$pos_space = strpos($stringOfBlockWithAnchor, ' ');
						if($pos_closing_bracket < $pos_space) {
							$pos = $pos_closing_bracket;
						} else {
							$pos = $pos_space;
						}
						$new = substr($stringOfBlockWithAnchor, 0 , $pos) . ' id="' . $replace . '"' . substr($stringOfBlockWithAnchor, $pos);
						$new = str_replace('<a name="' . $replace . '" id="' . $replace . '"></a>', '', $new);
						$this->code = str_replace($stringOfBlockWithAnchor, $new, $this->code);
					}
				}
				// notice that if the above fails in creating new anchor names, we delete the original anchors anyway...
				$arrayAnchorNamePatterns = array(
				'_Toc',
				'OLE_LINK',
				's[0-9]*_',
				);
				foreach($arrayAnchorNamePatterns as $AnchorNamePattern) {
					$this->code = preg_replace('/<a [^<>]*name="[^"]*' . $AnchorNamePattern . '[^"]*"[^<>]*(\/>|><\/a>)/is', '', $this->code);
				}
			}
		}
		return true;
	}
	
	protected function only_content_open() {
		//print('trust headings: ');var_dump($this->config['trust_headings']);
		$contentArray = ReTidy::getContentArray($this->code);
		$content = $contentArray[0];
		$strpos_content = strpos($this->code, $content);
		$this->pre_content = substr($this->code, 0, $strpos_content);
		$this->post_content = substr($this->code, $strpos_content + strlen($content));
		$this->code = $content;
	}
	
	protected function only_content_close() {
		//print('trust headings: ');var_dump($this->config['trust_headings']);
		//var_dump($this->config['macro']);exit(0);
		// since tidy adds <doctype><html><body> type stuff
		foreach($this->config['macro'] as $function) {
			if($function === "tidy_code") {
				$contentArray = ReTidy::getContentArray($this->code);
				$this->code = $contentArray[0];
				break;
			}
		}
		$this->code = $this->pre_content . $this->code . $this->post_content;
	}
	
	function remove_ids($string) {
		$array_rxp = array(
			' id="[^"]*?"' => '',
		);
		// do we always want to remove ids?
		foreach($array_rxp as $search => $replace) {
			$string = preg_replace('/' . $search . '/is', $replace, $string);
		}
		return $string;
	}
	
	protected function remove_page_structure($content_only = false) {
		/*$array_rxp_removes = array(
			'<header[^<>]*?>',
			'<footer[^<>]*?>',
			'<section[^<>]*?>',
		);
		$array_removes = array(
			'</header>',
			'</footer>',
			'</section>',
		);
		if($content_only) {
			$contentArray = ReTidy::getContentArray($this->code);
			$content = $contentArray[0];
			//print('$content: ' . $content);
			$content_offset = strpos($this->code, $content);
			$strlen_content = strlen($content);
			foreach($array_rxp_removes as $rxp_remove) {
				$content = preg_replace('/' . $rxp_remove . '/is', '', $content, -1, $count1);
			}
			foreach($array_removes as $remove) {
				$content = str_replace($remove, '', $content, $count2);
			}
			//print('$content 2: ' . $content);
			$this->code = substr($this->code, 0, $content_offset) . $content . substr($this->code, $content_offset + $strlen_content);
		} else {
			foreach($array_rxp_removes as $rxp_remove) {
				$this->code = preg_replace('/' . $rxp_remove . '/is', '', $this->code, $count1);
			}
			foreach($array_removes as $remove) {
				$this->code = str_replace($remove, '', $this->code, $count2);
			}
		}
		$this->logMsgIf("page structure pieces removed", $count1 + $count2);*/
	}
	
	function get_level_based_on_array_order_indicators_not_in_TOC($code, $previous_TOC_level, $previous_level) {
		//print('code: ');var_dump($code);
		//print('previous_TOC_level: ');var_dump($previous_TOC_level);
		//print('previous_level: ');var_dump($previous_level);
		// if it's a <caption> just get it out of the way
		if(strpos($code, "<caption") !== false) {
			//print('here30405066<br>');
			return "?";
		}
		// first try to find the level directly from the order indicator, keeping in mind we should skip heading levels
		$determined_heading_level = ReTidy::determine_heading_level($code);
		//if($determined_heading_level !== false && ($determined_heading_level === $previous_level || $determined_heading_level - 1 === $previous_level)) {
		//print('determined_heading_level: ');var_dump($determined_heading_level);
		if($determined_heading_level !== false) { // this version says we trust the determined heading level
			//print('here30405067<br>');
			return $determined_heading_level;
		}
		// if the order indicator is not informative enough, try combining its information with that of previous TOC levels and their order indicator types
		$order_indicator_type_array = ReTidy::get_order_indicator_type($code);
		$order_indicator_type = $order_indicator_type_array[0];
		$order_indicator = $order_indicator_type_array[1];
		$level = false;
		if(sizeof($this->array_order_indicators_not_in_TOC) === 0) {
			// for the first heading there is the possibility that it is a genuine h1 (coming from a document with some semblance of structure)
			// so check for this possibility
			if(strpos($code, ' id="cont"') !== false) {
				//print('here30405068<br>');
				return 1;
			}
			if(strpos($code, 'CONTENT TITLE BEGINS') !== false) {
				//print('here30405069<br>');
				return 1;
			}
			$this->array_order_indicators_not_in_TOC[] = array($order_indicator_type, 1);
			$level = $previous_level + 1;
			//print('here30405070<br>');
			if(is_numeric($level) && ($level < 1 || $level > 6)) {
				$level = "?";
			}
			return $level;
		}
		//print('this->array_order_indicators_not_in_TOC: ');var_dump($this->array_order_indicators_not_in_TOC);
		//print('level 1: ');var_dump($level);
		foreach($this->array_order_indicators_not_in_TOC as $index => $value) {
			$type = $value[0];
			$count = $value[1];
			if($type == $order_indicator_type) {
				// reset everything after the matched one
				$new_array = array();
				$counter7 = 0;
				while($counter7 < $index + 1) {
					$new_array[] = $this->array_order_indicators_not_in_TOC[$counter7];
					$counter7++;
				}
				$this->array_order_indicators_not_in_TOC = $new_array;
				if($order_indicator_type === "lower letter" && preg_match('/[i]+/s', $order_indicator, $lower_roman_order_indicator_matches) === 1 && $lower_roman_order_indicator_matches[0] === "i") {
					// then this is ambiguous between lower roman and lower letter
					if($count === 8) {
						$this->array_order_indicators_not_in_TOC[$index] = array($this->array_order_indicators_not_in_TOC[$index][0], $this->array_order_indicators_not_in_TOC[$index][1] + 1);
						$level = $previous_level + $index;
					} else { // we call this a false lower letter
						// and add a new array entry
						$this->array_order_indicators_not_in_TOC[] = array("lower roman", 1);
						$level = $previous_level + $index + 1;
						break;
					}
				} elseif($order_indicator_type === "upper letter" && preg_match('/[I]+/s', $order_indicator, $upper_roman_order_indicator_matches) === 1 && $upper_roman_order_indicator_matches[0] === "I") {
					// then this is ambiguous between upper roman and upper letter
					if($count === 8) {
						$this->array_order_indicators_not_in_TOC[$index] = array($this->array_order_indicators_not_in_TOC[$index][0], $this->array_order_indicators_not_in_TOC[$index][1] + 1);
						$level = $previous_level + $index;
					} else { // we call this a false lower letter
						// and add a new array entry
						$this->array_order_indicators_not_in_TOC[] = array("upper roman", 1);
						$level = $previous_level + $index + 1;
					}
				} else {
					// increment the counter
					$this->array_order_indicators_not_in_TOC[$index] = array($this->array_order_indicators_not_in_TOC[$index][0], $this->array_order_indicators_not_in_TOC[$index][1] + 1);
					$level = $previous_level + $index;
				}
				break;
			}
		}
		//print('level 2: ');var_dump($level);
		if($level === false) {
			// if we get to to here it is assumed that the order indicator type did not match any in the array; and add a new array entry
			$this->array_order_indicators_not_in_TOC[] = array($order_indicator_type, 1);
			$level = $previous_TOC_level + $index + 2;
		}
		// it's unfortunate but if the heading level is found to be above 7 there is really not much we can do with it so just nullify it
		//print('level 3: ');var_dump($level);
		if($level > 6) {
			$level = "?";
		}
		//print('level 4: ');var_dump($level);
		//print('here30405071<br>');
		if($level === 1 && $this->did_an_h1) { // only allow one <h1>
			//print('here30405072<br>');
			$level = 2;
		}
		//print('level 5: ');var_dump($level);
		if(is_numeric($level) && ($level < 1 || $level > 6)) {
			$level = "?";
		}
		//print('level 6: ');var_dump($level);
		return $level;
	}
	
	function remove_order_indicator($code) {
		//print("code: ");var_dump($code);
		$order_indicator_type_array = ReTidy::get_order_indicator_type($code);
		$order_indicator = $order_indicator_type_array[1];
		//print("order_indicator: ");var_dump($order_indicator);
		//var_dump($order_indicator);
		//var_dump(OM::getAllTagParts($code));exit(0);
		if($order_indicator === false || strlen($order_indicator) === 0) {
			return $code;
		}
		$split_order_indicator = str_split($order_indicator);
		$tagParts = OM::getAllTagParts($code);
		//var_dump(OM::getStringFromPartsArray($tagParts));exit(0);
		//$test_string = "some string";
		//$test_substr = substr($test_string, 50);
		//var_dump("stringy string" . $test_substr);exit(0);
		$started_matching = false;
		$order_indicator_index = 0;
		foreach($tagParts as $index => $value) {
			if($value[2] === 0) { // it is text content
				$split_part = str_split($value[0]);
				if($started_matching) {
					$starting_index2 = $index2 = 0;
				} else {
					foreach($split_part as $index2 => $value2) {
						if($split_part[$index2] === $split_order_indicator[$order_indicator_index]) {
							$started_matching = true;
							$starting_index2 = $index2;
							break;
						}
					}
					if(!$started_matching) {
						continue;
					}
				}
				while($order_indicator_index !== strlen($order_indicator) && 
				$index2 !== strlen($value[0]) && 
				$split_part[$index2] === $split_order_indicator[$order_indicator_index]) {
					$order_indicator_index++;
					$index2++;
				}
				// need to do some replaces here
				$tagParts[$index] = array(substr($value[0], 0, $starting_index2) . substr($value[0], $index2), $value[1], $value[2]); // the offset we are putting here may be wrong but it shouldn't matter
				if($order_indicator_index === strlen($order_indicator) || $index2 !== strlen($value[0])) {
					break;
				}
			}
		}
		if($order_indicator_index !== strlen($order_indicator)) {
			print("Could not remove order indicator; this function needs to be smarter 49734987345");exit(0);
		}
		//print("string from tag parts: ");var_dump(OM::getStringFromPartsArray($tagParts));
		return OM::getStringFromPartsArray($tagParts);
	}
	
	function get_order_indicator_type($code) {
		//print("code: ");var_dump($code);
		if(!isset($this->array_order_indicators_not_in_TOC)) {
			$this->array_order_indicators_not_in_TOC = array();
		}
		/*preg_match('/<(\w{1,})[^<>]*?>(.*?)<\/\1>/is', $code, $section_heading_matches);*/
		//var_dump($section_heading_matches);
		//$section_heading_code = $section_heading_matches[0];
		//print("section_heading_code: ");var_dump($section_heading_code);
		$trimmed_tagless_code = ReTidy::trim_nbsp(ReTidy::tagless($code));
		//print('$trimmed_tagless_code :');var_dump($trimmed_tagless_code);
		preg_match('/' . $this->order_indicator_regex_with_complex_number_case_sensitive . '/s', $trimmed_tagless_code, $order_indicator_matches, PREG_OFFSET_CAPTURE);
		$order_indicator = $order_indicator_matches[1][0];
		//print('$order_indicator :');var_dump($order_indicator);
		if($order_indicator === false || $order_indicator === NULL) {
			//return false;
		} else {
			$order_indicator_offset = $order_indicator_matches[1][1];
			$space = $order_indicator_matches[sizeof($this->array_order_indicator_types_with_complex_number_case_sensitive) + 1][0];
			$found_an_order_indicator_to_work_with = true;
			if($order_indicator_offset === 0) {
				
			} else {
				$found_an_order_indicator_to_work_with = false;
				//return false;
			}
			if(strlen($order_indicator) === 0) {
				$found_an_order_indicator_to_work_with = false;
				//return false;
			}
		}
		//if(strpos($order_indicator, "&") === false && strlen($order_indicator) > 6) {
		//	$found_an_order_indicator_to_work_with = false;
		//}
		$order_indicator_type = '';
		// this is needed for text type order indicator. eventually it would probably be nice to include it from this function for the other types as well
		$order = 0;
		if($found_an_order_indicator_to_work_with) {
			//print('here0003-5----!<br>');
			// check for ambiguity between letters and roman numerals
			preg_match('/[a-z]+/is', $order_indicator, $letter_matches);
			$case = ReTidy::getLetterCase($letter_matches[0]);
			if(ReTidy::isAmbiguousBetweenRomanNumeralsAndLetters($order_indicator) && $case === "upper") {
				$order_indicator_type = "upper letter";
			} elseif(ReTidy::isAmbiguousBetweenRomanNumeralsAndLetters($order_indicator) && $case === "lower") {
				$order_indicator_type = "lower letter";
			} else {
				//print('here0556-<br>');
				foreach($this->array_order_indicator_types_with_complex_number_case_sensitive as $order_indicator_type_index => $order_indicator_type_value) {
					if($order_indicator === $order_indicator_matches[$order_indicator_type_index][0]) {
						$order_indicator_type = $order_indicator_type_value;
						break;
					}
				}
			}
		} else { // try to match it as a text order indicator
			//print('working on text type order indicator<br>');
			// participer...
			if(preg_match('/part(ie)?\s+([ivxlc]{1,8})/is', $trimmed_tagless_code, $part_matches, PREG_OFFSET_CAPTURE) && $part_matches[0][1] === 0) {
				//print('$part_matches: ');var_dump($part_matches);
				//print('here0003-5----<br>');
				//$part_matches[1][1] === 0) { // found part-type text order indicator
				$order_indicator = $part_matches[2][0];
				$order = ReTidy::roman_numeral_to_decimal($part_matches[2][0]);
				//print('$order_indicator: ');var_dump($order_indicator);
				//print('$order: ');var_dump($order);
				return array("text", $order_indicator, $order);
			}
			if(stripos($trimmed_tagless_code, "premi") === 0) {
				return array("text", $order_indicator, 1);
			} elseif(stripos($trimmed_tagless_code, "deux") === 0) {
				return array("text", $order_indicator, 2);
			} elseif(stripos($trimmed_tagless_code, "troi") === 0) {
				return array("text", $order_indicator, 3);
			} elseif(stripos($trimmed_tagless_code, "quatr") === 0) {
				return array("text", $order_indicator, 4);
			} elseif(stripos($trimmed_tagless_code, "cinq") === 0) {
				return array("text", $order_indicator, 5);
			} elseif(stripos($trimmed_tagless_code, "six") === 0) {
				return array("text", $order_indicator, 6);
			} elseif(preg_match('/sept(i|\s|^\w)/is', $trimmed_tagless_code, $sept_matches, PREG_OFFSET_CAPTURE) && $sept_matches[0][1] === 0) { // to avoid conflict with the month name september
				return array("text", $order_indicator, 7);
			} elseif(stripos($trimmed_tagless_code, "huit") === 0) {
				return array("text", $order_indicator, 8);
			} elseif(stripos($trimmed_tagless_code, "neu") === 0) {
				return array("text", $order_indicator, 9);
			} elseif(stripos($trimmed_tagless_code, "diz") === 0) {
				return array("text", $order_indicator, 10);
			} elseif(stripos($trimmed_tagless_code, "onz") === 0) {
				return array("text", $order_indicator, 11);
			} elseif(stripos($trimmed_tagless_code, "douz") === 0) {
				return array("text", $order_indicator, 12);
			} elseif(stripos($trimmed_tagless_code, "treiz") === 0) {
				return array("text", $order_indicator, 13);
			} elseif(stripos($trimmed_tagless_code, "quator") === 0) {
				return array("text", $order_indicator, 14);
			} elseif(stripos($trimmed_tagless_code, "quin") === 0) {
				return array("text", $order_indicator, 15);
			} elseif(stripos($trimmed_tagless_code, "seiz") === 0) {
				return array("text", $order_indicator, 16);
			} elseif(stripos($trimmed_tagless_code, "dix-sept") === 0) {
				return array("text", $order_indicator, 17);
			} elseif(stripos($trimmed_tagless_code, "dix-huit") === 0) {
				return array("text", $order_indicator, 18);
			} elseif(stripos($trimmed_tagless_code, "dix-neu") === 0) {
				return array("text", $order_indicator, 19);
			} elseif(stripos($trimmed_tagless_code, "vingt") === 0) {
				return array("text", $order_indicator, 20);
			} elseif(stripos($trimmed_tagless_code, "first") === 0) {
				return array("text", $order_indicator, 1);
			} elseif(stripos($trimmed_tagless_code, "second") === 0) {
				return array("text", $order_indicator, 2);
			} elseif(stripos($trimmed_tagless_code, "third") === 0) {
				return array("text", $order_indicator, 3);
			} elseif(stripos($trimmed_tagless_code, "fourth") === 0) {
				return array("text", $order_indicator, 4);
			} elseif(stripos($trimmed_tagless_code, "fifth") === 0) {
				return array("text", $order_indicator, 5);
			} elseif(stripos($trimmed_tagless_code, "sixth") === 0) {
				return array("text", $order_indicator, 6);
			} elseif(stripos($trimmed_tagless_code, "seventh") === 0) {
				return array("text", $order_indicator, 7);
			} elseif(stripos($trimmed_tagless_code, "eighth") === 0) {
				return array("text", $order_indicator, 8);
			} elseif(stripos($trimmed_tagless_code, "ninth") === 0) {
				return array("text", $order_indicator, 9);
			} elseif(stripos($trimmed_tagless_code, "tenth") === 0) {
				return array("text", $order_indicator, 10);
			} elseif(stripos($trimmed_tagless_code, "eleventh") === 0) {
				return array("text", $order_indicator, 11);
			} elseif(stripos($trimmed_tagless_code, "twelfth") === 0) {
				return array("text", $order_indicator, 12);
			} elseif(stripos($trimmed_tagless_code, "thirteenth") === 0) {
				return array("text", $order_indicator, 13);
			} elseif(stripos($trimmed_tagless_code, "fourteenth") === 0) {
				return array("text", $order_indicator, 14);
			} elseif(stripos($trimmed_tagless_code, "fifteenth") === 0) {
				return array("text", $order_indicator, 15);
			} elseif(stripos($trimmed_tagless_code, "sixteenth") === 0) {
				return array("text", $order_indicator, 16);
			} elseif(stripos($trimmed_tagless_code, "seventeenth") === 0) {
				return array("text", $order_indicator, 17);
			} elseif(stripos($trimmed_tagless_code, "eighteenth") === 0) {
				return array("text", $order_indicator, 18);
			} elseif(stripos($trimmed_tagless_code, "ninteenth") === 0) {
				return array("text", $order_indicator, 19);
			} elseif(stripos($trimmed_tagless_code, "twentieth") === 0) {
				return array("text", $order_indicator, 20);
			}
		}
		if(strlen($order_indicator_type) > 0) {
			if($order_indicator_type === "number") {
				$order = $order_indicator;
			} elseif($order_indicator_type === "complex number") {
				//print('here29305-056-1<br>');
				preg_match('/[0-9]+/', $order_indicator, $order_indicator_number_matches);
				$order = $order_indicator_number_matches[0];
				if($order > 100 && stripos($trimmed_tagless_code, "canada") !== false && stripos($trimmed_tagless_code, "ottawa") !== false) { // very specific case...; we call this an address section
					//print('here29305-056-1---000<br>');
					return false;
				}
			} elseif($order_indicator_type === "lower roman" || $order_indicator_type === "lower roman") {
				//print('here29305-056-2<br>');
				preg_match('/[ivxlc]+/i', $order_indicator, $order_indicator_roman_matches);
				$order = $order_indicator_roman_matches[0];
			} elseif($order_indicator_type === "lower letter" || $order_indicator_type === "upper letter") {
				//print('here29305-056-3<br>');
				preg_match('/[a-z]+/i', $order_indicator, $order_indicator_letter_matches);
				$order = ReTidy::alphabetical_to_decimal($order_indicator_letter_matches[0]);
			} else { // presumably bullets
			
			}
			//print('order indicator array: ');var_dump(array($order_indicator_type, $order_indicator, $order));
			return array($order_indicator_type, $order_indicator, $order);
		}
		return false;
	}
	
	function getLetterCase($string) {
		// simplistic function that is currently (2011-08-18) only used for simplistic cases
		// uppercase 65-90
		// lowercase 97-122
		$is_uppercase = true;
		$is_lowercase = true;
		$string_length = strlen($string);
		$counter = 0;
		while($counter < $string_length) {
			$char = $string[$counter];
			if(ord($char) >= 65 && ord($char) <= 90) {
				$is_lowercase = false;
			} elseif(ord($char) >= 97 && ord($char) <= 122) {
				$is_uppercase = false;
			} else {
				return "unknown";
			}
			$counter++;
		}
		if($is_uppercase) {
			return "upper";
		}
		if($is_lowercase) {
			return "lower";
		}
		return "mixed";
	}
	
	function determine_heading_level($code) {
		//print("here384950<br>\r\n");
		//print('code: ');var_dump($code);
		$level_guess = false;
		preg_match('/<(\w{1,})[^<>]*?>(.*?)<\/\1>/is', $code, $section_heading_matches);
		if($section_heading_matches[0] !== false && $section_heading_matches[0] !== NULL && strlen($section_heading_matches[0]) > 0) {
			$section_heading_code = $section_heading_matches[0];
		} else {
			$section_heading_code = $code;
		}
		$trimmed_tagless_section_heading_code = ReTidy::trim_nbsp(ReTidy::tagless($section_heading_code));
		preg_match('/' . $this->order_indicator_regex_with_complex_number . '/is', $trimmed_tagless_section_heading_code, $order_indicator_matches, PREG_OFFSET_CAPTURE);
		$order_indicator = $order_indicator_matches[1][0];
		$order_indicator_offset = $order_indicator_matches[1][1];
		$space = $order_indicator_matches[sizeof($this->array_order_indicator_types_with_complex_number) + 1][0];
		//print("here384951<br>\r\n");
		if($order_indicator_offset === 0) {
			//print("here384952<br>\r\n");
		} else {
			//print("here384953<br>\r\n");
			return false;
		}
		//print("here384954<br>\r\n");
		if(strlen($order_indicator) === 0) {
			return false;
		}
		//print("here384955<br>\r\n");
		//if(strpos($order_indicator, "&") === false && strlen($order_indicator) > 6) {
		//	return false;
		//}
		//print("here384956<br>\r\n");
		foreach($this->array_order_indicator_types_with_complex_number as $order_indicator_type_index => $order_indicator_type_value) {
			if($order_indicator === $order_indicator_matches[$order_indicator_type_index][0]) {
				$order_indicator_type = $order_indicator_type_value;
				break;
			}
		}
		//print("order_indicator_type: ");var_dump($order_indicator_type);
		//if($order_indicator_type_value === "letter") {
		//	$section = $last_number . "_" . substr($section, 0, strpos($section, $matches8[1]));
		//	$level = 3;
		//}
		if($order_indicator_type_value === "number") { // is a number
			preg_match_all('/[0-9]{1,}/', $order_indicator, $order_indicator_parts_matches);
			$level_guess = sizeof($order_indicator_parts_matches[0]) + 1;
		}
		//print('order_indicator_type_value: ');var_dump($order_indicator_type_value);
		if($order_indicator_type_value === "complex number") { // is a number
			//print("here384959<br>\r\n");
			preg_match_all('/[0-9]{1,}/', $order_indicator, $order_indicator_parts_matches);
			$beginning_number_part_of_order_indicator = $order_indicator_parts_matches[0][0];
			if(!ReTidy::isProbablyAYear($beginning_number_part_of_order_indicator)) {
				//print("here384960<br>\r\n");
				$level_guess = sizeof($order_indicator_parts_matches[0]) + 1;
				//print('level guess: ');var_dump($level_guess);
			}
		}
		if(strpos(strtolower($trimmed_tagless_section_heading_code), "table") === 0) { // is a table
			$level_guess = "?";						
		}
		if(strpos(strtolower($trimmed_tagless_section_heading_code), "appendi") === 0) { // is an appendix
			$level_guess = 2;						
		}
		if(strpos(strtolower($trimmed_tagless_section_heading_code), "annex") === 0) { // is an annex
			$level_guess = 2;						
		}
		if($level_guess === 1 && $this->did_an_h1) { // only allow one <h1>
			$level_guess = 2;
		}
		if(is_numeric($level_guess) && ($level_guess < 1 || $level_guess > 6)) {
			$level_guess = "?";
		}
		return $level_guess;
	}
	
	protected function get_first_indexical($string) {
		$content_piece_matches = OM::getAllTags($string);
		$size = sizeof($content_piece_matches);
		if($size > 0) {
			$content_piece_counter = 0;
			while(!ReTidy::isIndexical($content_piece_matches[$content_piece_counter][0])) {
				$content_piece_counter++;
				if($content_piece_counter === $size) {
					return false;
				}
			}
			return $content_piece_matches[$content_piece_counter][0];
		}
		return false;
	}
	
	protected function TOCheadingified_mark($to_headingify) {
		$to_headingify = preg_replace('/<(\w+)([^<>]*?)>/is', '<$1$2 TOCheadingified="true">', $to_headingify, 1);
		return $to_headingify;
	}
	
	protected function headingify($to_headingify, $level) {
		// there could be more than one heading in a chunk of code to be headinigified so de-headingifying all the heading will remove those that we do not want and after we apply the one we do want
		$to_headingify = preg_replace('/<(h[1-6])([^<>]*?)>(.*?)<\/\1>/is', '<p$2>$3</p>', $to_headingify);
		preg_match('/<(\w+)/is', $to_headingify, $tagname_matches, PREG_OFFSET_CAPTURE, 0);
		$pre_heading_OString_offset = $tagname_matches[0][1];
		$tagname = $tagname_matches[1][0];
		while($tagname === "div") {
			preg_match('/<(\w+)/is', $to_headingify, $tagname_matches, PREG_OFFSET_CAPTURE, $pre_heading_OString_offset + strlen($tagname) + 1);
			$pre_heading_OString_offset = $tagname_matches[0][1];
			$tagname = $tagname_matches[1][0];
		}
		$pre_heading_OString = substr($to_headingify, 0, $pre_heading_OString_offset);
		$heading_OString = OM::getOString($to_headingify, "<" . $tagname, "</" . $tagname . ">");
		//print('$heading_OString: ');var_dump($heading_OString);
		$strlen_heading_OString = strlen($heading_OString);
		if(is_numeric($level) && $level > 0 && $level < 7) {
			//print('$heading_OString: ');var_dump($heading_OString);
			$heading_OString = preg_replace('/<(\w+)([^<>]*?)>/is', '<h' . $level . '$2>', $heading_OString, 1);
			$heading_OString = ReTidy::remove_tags($heading_OString, "strong");
			//print('$heading_OString: ');var_dump($heading_OString);
			$heading_OString = substr($heading_OString, 0, strlen($heading_OString) - strlen($tagname) - 1) . "h" . $level . ">";
			//print('$heading_OString: ');var_dump($heading_OString);
		} else {
			$pos_lt = strpos($heading_OString, '>');
			$pos_gt = ReTidy::strpos_last($heading_OString, '<');
			$heading_OString = substr($heading_OString, 0, $pos_lt + 1) . '<strong>' . substr($heading_OString, $pos_lt + 1, $pos_gt - ($pos_lt + 1)) . '</strong>' . substr($heading_OString, $pos_gt);
		}
		$headingified = $pre_heading_OString . $heading_OString . substr($to_headingify, strlen($pre_heading_OString) + $strlen_heading_OString);
		return $headingified;
	}
	
	protected function structure_content() {
		// this function is intended to be used on pages in government templates so that the junk in them (<h2>-type stuff for sidemenu and 
		// institutional links and maybe others) does not get fixed.
		//if($this->config['WET'] !== false) {
		//	ReTidy::DOM_init();
		//	ReTidy::DOM_clean_redundant_tags();
		//	ReTidy::DOM_save();
		//}
		//if($this->config['trust_headings'] !== true) {
			ReTidy::remove_page_structure(true);
		//}
		ReTidy::build_page_structure(true);
		//if($this->config['trust_headings'] !== true) {
			//ReTidy::check_page_structure();
			ReTidy::fix_page_structure();
		//}
		ReTidy::build_page_from_structure_arrays(true);
		if($this->config["normalize_heading_text"] === 'all_indexical_content') {
			ReTidy::normalize_all_indexical_content(true);
		}
	}
	
	protected function structure() {
		ReTidy::remove_page_structure();
		ReTidy::build_page_structure();
		//ReTidy::check_page_structure();
		ReTidy::fix_page_structure();
		ReTidy::build_page_from_structure_arrays();
		if($this->config["normalize_heading_text"] === 'all_indexical_content') {
			ReTidy::normalize_all_indexical_content();
		}
	}

	protected function get_heading_level_from_code($code) {
		//print('$code' . $code);
		if(preg_match('/<h([1-6])/is', $code, $heading_matches)) {
			$level = $heading_matches[1];
		} else {
			$level = "?";
		}
		//print('level from code' . $level . '<br>');
		return $level;
	}
	
	protected function build_page_structure($content_only = false) {
		// HTML4 and XHTML1 have the concept of a block level element while HTML5 does not...
		// see http://www.w3.org/TR/html5/content-models.html#kinds-of-content
		if(DTD::getDTDfile() === 'DTD/html5.dtd') { // HTML5
			$blocks = DTD::getAllElements();
		} else {
			$blocks = DTD::getBlock();
		}
		// I am not sure whether DOM or OM is faster; hopefully OM is faster while retaining the advantage of working across objects...
		// I would guess that that is the case since there may be non-overwhelming nesting
		// Further consideration; while combine_inline must be able to simultaneously see the code as a string and a hierarchical document object
		// node tree structure because the relevant (inline) tags do not hold any necessary ancestral relation (<span style="color: red;"><em>text</em></span> and <em><span style="color: red;">text</span></em> 
		// are both valid, <p><strong>text</strong></p> and <strong><p>text</p></strong> are not both valid; in HTML4 or XHTML1...
		// Is this still the case in HTML5? In HTML5 there is no dichotomy between inline and block elements.
		
		// heading content and sectioning content
		
		// blah; we are only concerned with headings and later (for HTML5) section and header and footer
		
		
		if($this->config['trust_headings'] !== true) {
			// first remove old anchors that we are sure we do not want (and maybe should have already been removed)
			// <h1 id="_Toc221073567"><a id="_Toc165697264"></a>1. CONTEXTE</h1>
			$this->code = preg_replace('/<a (name|id)="_Toc[0-9]+">(.*?)<\/a>/is', '$2', $this->code);
			$this->code = preg_replace('/ (name|id)="_Toc[0-9]+"/is', '', $this->code);
			
			// destroy the absurdity that is an image with alt text that says table of contents...
			$this->code = preg_replace('/<img([^<>]*?) alt="(((TABLE OF CONTENTS)|(Table des mati)|(TABLE DES MATI)|(INDEX))[^"]*?)"([^<>]*?)>/is', '$2', $this->code);
			//print('$this->code 385485489489: ' . $this->code);exit(0);
			
			// remove page number references before doing any further work
			$content_piece_matches = OM::getAllBlockOStrings_for_structure($this->code, $position_after_pre);
			//print('$content_piece_matches: ');var_dump($content_piece_matches);exit(0);
			foreach($content_piece_matches as $index => $value) {
				$content_piece = $value[0];
				$content_piece_page_reference_trimmed = ReTidy::trim_page_reference($content_piece);
				//print('here303049505<br>');exit(0);
				if($content_piece != $content_piece_page_reference_trimmed) {
					//print('here303049506<br>');exit(0);
					$this->code = str_replace($content_piece, $content_piece_page_reference_trimmed, $this->code);
				}
			}
			//print('$this->code 385485489490: ' . $this->code);exit(0);
			//$this->code = ReTidy::remove_page_number_references($this->code);
			// not sophisticated enough
		}
		//print('here30940958059509851<br>');exit(0);
		if($content_only) {
			$contentArray = ReTidy::getContentArray($this->code);
			$this->bodyCode = $contentArray[0];
		} else {
			$this->bodyCode = ReTidy::getBodyCode($this->code);
		}
		
		if($this->config['trust_headings'] !== true) {
			//print('$this->code 2: ' . $this->code);exit(0);
			// if the table of contents is not in a block; fix this
			if(preg_match('/((TABLE OF CONTENTS)|(Table des mati)|(TABLE DES MATI)|(INDEX))/is', $this->bodyCode, $TOC_heading_matches, PREG_OFFSET_CAPTURE)) {
				//print('TOC_heading_matches: ');var_dump($TOC_heading_matches);
				//print('$this->code 1: ' . $this->code);exit(0);
				$pos_TOC_heading_text = $TOC_heading_matches[0][1];
				//print('100 characters pre TOC heading: ');var_dump(substr($this->bodyCode, $pos_TOC_heading_text - 100, 120));
				$containingBlockArray = OM::getContainingBlock($this->bodyCode, $pos_TOC_heading_text);
				//print('containing block array: ');var_dump(OM::getContainingBlock($this->bodyCode, $pos_TOC_heading_text));
				// the simple case but it may be sufficient
				if($containingBlockArray === false) { // then we have to blockify it
					$blockString = DTD::getBlock();
					preg_match_all('/<\/(' . $blockString . ')>/is', substr($this->bodyCode, 0, $pos_TOC_heading_text), $last_block_matches, PREG_OFFSET_CAPTURE);
					$end_of_last_block_offset = $last_block_matches[0][sizeof($last_block_matches[0]) - 1][1] + strlen($last_block_matches[0][sizeof($last_block_matches[0]) - 1][0]);
					preg_match('/<(' . $blockString . ')(>|\s)/is', $this->bodyCode, $first_block_matches, PREG_OFFSET_CAPTURE, $pos_TOC_heading_text);
					$first_block_offset = $first_block_matches[0][1];
					$blockless_TOC_text = substr($this->bodyCode, $end_of_last_block_offset, $first_block_offset - $end_of_last_block_offset);
					//print('blockless_TOC_text: ');var_dump($blockless_TOC_text);exit(0);
					$this->bodyCode = substr($this->bodyCode, 0, $end_of_last_block_offset) . '<p>' . ReTidy::tagless($blockless_TOC_text) . '</p>' . substr($this->bodyCode, $first_block_offset);
					//print('this->code: ' . $this->code);
				}
			}
			
			//print('this->bodyCode 1: ' . $this->bodyCode);exit(0);
			// sometimes we cannot rely on overt indexicality indicators; like punctuation on indexical content.
			// in this case we must rely only on length and the juxtaposition of content
			//print('test 1_1: ');print(substr($this->bodyCode, 8000, 500));
			//print('test 1_2: ');print(substr($this->bodyCode, 2115, 40));
			//print('test 1_3: ');print(substr($this->bodyCode, 4098, 71));
			//print('test 1_4: ');print(substr($this->bodyCode, 7556, 44));
			//print('TOC4?: ' . substr($this->bodyCode, 2077, 9722 - 2077));
			$headings_extracted_from_paragraphs = 0;
			preg_match_all('/<p([^<>]*?)><strong([^<>]*?)>(.*?)<\/strong><br([^<>]*?)>(.*?)<\/p>/is', $this->bodyCode, $length_content_matches, PREG_OFFSET_CAPTURE);
			$counter = sizeof($length_content_matches[0]) - 1;
			while($counter > -1) {
				$text_part = $length_content_matches[5][$counter][0];
				if(strpos($text_part, "<br") === false) { // then it is a candidate for structuring in spite of a possible lack of markers
					$strong_part = $length_content_matches[3][$counter][0];
					if(ReTidy::isIndexical($strong_part) && !ReTidy::isIndexical($text_part) && (2 * strlen(ReTidy::tagless($strong_part)) < strlen(ReTidy::tagless($text_part)))) { // text is twice as long as potential heading
						$offset = $length_content_matches[0][$counter][1];
						$paragraph = $length_content_matches[0][$counter][0];
						$new_paragraph = '<p' . $length_content_matches[1][$counter][0] . '><strong' . $length_content_matches[2][$counter][0] . '>' . $length_content_matches[3][$counter][0] . '</strong></p>
<p>' . $length_content_matches[5][$counter][0] . '</p>';
						$this->bodyCode = substr($this->bodyCode, 0, $offset) . $new_paragraph . substr($this->bodyCode, $offset + strlen($paragraph));
						$headings_extracted_from_paragraphs++;
					}
				}
				$counter--;
			}
			$this->logMsgIf('headings extracted from paragraphs', $headings_extracted_from_paragraphs);
		}
		//print('here30940958059509850<br>');exit(0);
		//print('this->bodyCode 2: ' . $this->bodyCode);exit(0);
		$this->findingTOC = true;
		$TOCOStringsArray = OM::getTOCOStringsArray($this->bodyCode);
		$this->findingTOC = false;
		//print("TOCOStringsArray 2452353: ");var_dump($TOCOStringsArray);
		//print('test: ');print(substr($this->bodyCode, 8000, 500));
		//print('test2: ');print(substr($this->bodyCode, 2115, 40));
		//print('test3: ');print(substr($this->bodyCode, 4098, 71));
		//print('test4: ');print(substr($this->bodyCode, 7556, 44));
		//print('TOC3?: ' . substr($this->bodyCode, 2077, 9722 - 2077));exit(0);
		if($TOCOStringsArray === false) {
			$this->TOCStructureArray = false;
		} elseif(sizeof($TOCOStringsArray) == 0) {
			// did not find a table of contents
			$this->TOCStructureArray = false;
		} else {
			// we may still need to deal with two tables of contents...
			$this->TOCStructureArray = array();
			foreach($TOCOStringsArray as $index => $value) {
				$item = $value[0];
				$offset = $value[1];
				$level = $value[2];
				// remove headings in table of contents items. 
				$item = preg_replace('/<h[1-6]/is', '<p', $item);
				$item = preg_replace('/<\/h[1-6]>/is', '</p>', $item);
				// get rid of classes
				$item = preg_replace('/ class="[^"]*"/is', '', $item);
				$this->TOCStructureArray[] = array($level, $item);
			}
		}
		if($this->foundTOC) {
			$newTOCStructureArray = array();
			foreach($this->TOCStructureArray as $index => $value) {
				$level = $value[0];
				$section_code = $value[1];
				//$level_guess = "?";
				if($level === "pre" || $level === "post") {
					//$newTOCStructureArray[$index] = array($level, $section_code, $level);
					$newTOCStructureArray[$index] = array($level, $section_code);
					continue;
				}
				$level_guess = ReTidy::determine_heading_level($section_code);
				if($level_guess === false) { // if the function cannot determine it, then use one level lower than the previous heading in the table of contents
					//$newTOCStructureArray[$index] = array($level, $section_code, $level);
					$newTOCStructureArray[$index] = array($level, $section_code);
				} else {
					//$newTOCStructureArray[$index] = array($level_guess, $section_code, $level_guess);
					$newTOCStructureArray[$index] = array($level_guess, $section_code);
				}
			}
			$this->TOCStructureArray = $newTOCStructureArray;
		}
		
		// we are finished working on the TOCStructureArray in this function I guess
		//print("TOC structure array 2452355: ");var_dump($this->TOCStructureArray);exit(0);
		$this->foundPage = true;
		$this->no_h1 = false;
		preg_match_all('/<h1[^<>]*?>.*?<\/h1>/is', $this->bodyCode, $h1matches, PREG_OFFSET_CAPTURE);
		if(sizeof($h1matches[0]) > 1) {
			ReTidy::warning('Found ' . sizeof($h1matches[0]) . ' &lt;h1&gt;s');
		}
		if(sizeof($h1matches[0]) === 0) {
			ReTidy::warning('Did not find an &lt;h1&gt;!');
			$this->no_h1 = true;
		}
		// the question here is whether to try to pick apart the page without the help of <h#> tags at this point or to wait
		// for things like comparison to a table of contents.
		$this->pageStructureArray = array();
		if(sizeof($TOCOStringsArray) !== 0 && $TOCOStringsArray !== false) {
			foreach($TOCOStringsArray as $index => $value) {
				if($value[2] === "pre") {
					$this->TOC_pre_code = $value[0];
					$TOC_pre_offset = $value[1];
				}
			}
			//print('last TOC item: ');var_dump($value[0]);
			$TOC_end_offset = $value[1] + strlen($value[0]);
			//print('TOC_end_offset: ');var_dump($TOC_end_offset);
			//print('TOC_pre_offset: ');var_dump($TOC_pre_offset);
			//$TOC_end_offset = $value[1];
			//print('strlen(this->bodyCode)');var_dump(strlen($this->bodyCode));
			//print('this->bodyCode');print($this->bodyCode);exit(0);
			//print('TOC?: ' . substr($this->bodyCode, $TOC_pre_offset, $TOC_end_offset - $TOC_pre_offset));
			$first_indexical = ReTidy::get_first_indexical($this->bodyCode);
			//print("first indexical:");var_dump($first_indexical);
			$first_indexical_position = strpos($this->bodyCode, $first_indexical);
			//if($first_indexical_position <= $TOC_pre_offset) {
			//	$position_after_pre = $first_indexical_position;
			//} else {
			//	// shouldn't ever get here...
			//	print("We shouldn't get here and yet we did hmm... 49906093u399060<be>\r\n");
			//	$position_after_pre = $TOC_pre_offset;
			//}
			$pre = ReTidy::get_pre($this->bodyCode, $first_indexical_position);
		} else {
			//$this->pageStructureArray = false;
			$pre = ReTidy::get_pre($this->bodyCode);
		}
		//print("pre:");var_dump($pre);
		$this->pageStructureArray[] = array("pre", $pre);
		if(strlen($pre) === 0) {
			$position_after_pre = 0;
		} else {
			$position_after_pre = strpos($this->bodyCode, $pre) + strlen($pre);
		}
		//print("this->TOCStructureArray 3483983: ");var_dump($this->TOCStructureArray);
		//print("this->pageStructureArray 3483983: ");var_dump($this->pageStructureArray);exit(0);
		//var_dump(substr($this->bodyCode, $TOC_pre_offset, $TOC_end_offset - $TOC_pre_offset));
		//$content_piece_matches = OM::getAllTagsAtThisLevel($this->bodyCode, $position_after_pre);
		// an idealistic approach; if there are any containers of headings in the document it messes us up...
		// idealistic no longer
		//$content_piece_matches = OM::getSortedAllNonBlockContainingBlockOStrings_for_structure($this->bodyCode, $position_after_pre);
		$content_piece_matches = OM::getAllBlockOStrings_for_structure($this->bodyCode, $position_after_pre);
		//print('content_piece_matches: ');var_dump($content_piece_matches);exit(0);
		// the following is a hack that allows simpler coding below by including the end of the bodyCode offset for determining what to add in the last structure piece
		$content_piece_matches[][1] = strlen($this->bodyCode);
		$size = sizeof($content_piece_matches);
		if($size > 0) {
			if($this->foundTOC) { // then build the page structure from the table of contents
				$added_TOC_to_page_structure_array = false;
				$to_add = "";
				$level = "?";
				$this->did_an_h1 = false;
				$content_piece_counter = 0;
				$TOC_counter = 0;
				// have the TOC_counter skip any "pre" (table of contents headings) parts
				while($this->TOCStructureArray[$TOC_counter][0] === "pre" || $this->TOCStructureArray[$TOC_counter][0] === "?") {
					//print('here39439340404<br>');
					$previous_TOC_level = $this->TOCStructureArray[$TOC_counter][0];
					$TOC_counter++;
				}
				$first_TOC_item_index = $TOC_counter; // this seems unused...
				while($content_piece_counter < $size) {
					//print('here39439340405<br>');
					while(!ReTidy::isIndexical($content_piece_matches[$content_piece_counter][0])) {
						//print('here39439340406<br>');
						//print("content piece 77: ");var_dump($content_piece_matches[$content_piece_counter][0]);
						//$to_add .= $content_piece_matches[$content_piece_counter][0] . '
//';
						$to_add .= substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
						$content_piece_counter++;
						if($content_piece_counter === $size) {
							break 2;
						}
					}
					//print("content piece: ");var_dump($content_piece_matches[$content_piece_counter][0]);
					//print("TOC piece: ");var_dump($this->TOCStructureArray[$TOC_counter][1]);
					
					if(!$added_TOC_to_page_structure_array) {
						if($content_piece_matches[$content_piece_counter][1] <= $TOC_pre_offset && $content_piece_matches[$content_piece_counter][1] + strlen($content_piece_matches[$content_piece_counter][0]) >= $TOC_pre_offset) { // then we are assuming this heading is the TOC pre
							$this->pageStructureArray[] = array($level, $to_add);
							//print('to_add 001: ');var_dump($to_add);
							//print("page structure array 001: ");var_dump($this->pageStructureArray);
							if($level === 1) {
								$this->did_an_h1 = true;
							}
							$previous_level = $level;
							//$to_add = $content_piece_matches[$content_piece_counter][0] . '
//';
							$to_add = substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
							$content_piece_counter++;
							//print("to_add1:");var_dump($to_add);
							//print("content_piece_matches[content_piece_counter][1]:");var_dump($content_piece_matches[$content_piece_counter][1]);
							//print("strlen(content_piece_matches[content_piece_counter][0]):");var_dump(strlen($content_piece_matches[$content_piece_counter][0]));
							//print("TOC_pre_offset:");var_dump($TOC_pre_offset);
							//print("TOC_end_offset:");var_dump($TOC_end_offset);
							//while($content_piece_matches[$content_piece_counter][1] + strlen($content_piece_matches[$content_piece_counter][0]) < $TOC_end_offset) {
							//while($content_piece_matches[$content_piece_counter][1] + strlen($content_piece_matches[$content_piece_counter][0]) <= $TOC_end_offset) {
							while($content_piece_matches[$content_piece_counter][1] <= $TOC_end_offset) {
								//print('here39439340407<br>');exit(0);
								//$to_add .= $content_piece_matches[$content_piece_counter][0] . '
//';
								$to_add .= substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
								$content_piece_counter++;
								//print("to_add2:");var_dump($to_add);
							}
							//$to_add .= substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
							//$content_piece_counter++;
							//print('TOC to_add: ' . $to_add);
							$this->pageStructureArray[] = array("TOC", $to_add);
							unset($this->array_order_indicators_not_in_TOC);
							//print('to_add 002: ');var_dump($to_add);
							//print("page structure array 002: ");var_dump($this->pageStructureArray);
							$previous_level = "TOC";
							$added_TOC_to_page_structure_array = true;
							$to_add = '';
							$level = "?";
							//$content_piece_counter++;
							// this previous line caused to take a lot of time figuring out that the first TOC item was neing skipped by it;
							// it is not fully considered why it was here.
							continue;
						}
					}
					//print('content_piece_matches[content_piece_counter][0]: ');var_dump($content_piece_matches[$content_piece_counter][0]);
					//print('this->TOCStructureArray[TOC_counter][1]: ');var_dump($this->TOCStructureArray[$TOC_counter][1]);
					if(ReTidy::indexical_match($content_piece_matches[$content_piece_counter][0], $this->TOCStructureArray[$TOC_counter][1])) { // it approximates the next text from the table of contents, then good; otherwise break
						//print('yes indexical_match<br>');
						$this->pageStructureArray[] = array($level, $to_add);
						//print('to_add 003: ');var_dump($to_add);
						//print("page structure array 003: ");var_dump($this->pageStructureArray);
						if($level === 1) {
							$this->did_an_h1 = true;
						}
						$previous_level = $level;
						$to_headingify = substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
						if($this->config['trust_headings'] !== true) {
							$level = $this->TOCStructureArray[$TOC_counter][0];
							$to_headingify = ReTidy::TOCheadingified_mark($to_headingify);
						} else {
							$level = ReTidy::get_heading_level_from_code($to_headingify);
						}
						$to_add = $to_headingify . '
';
						unset($this->array_order_indicators_not_in_TOC);
						$previous_TOC_level = $this->TOCStructureArray[$TOC_counter][0];
						//print('this->TOCStructureArray: ');var_dump($this->TOCStructureArray);exit(0);
						$TOC_counter++;
					} else { // we still have to add the indexical content to be fixed later (it may be headings even though they are not in the table of contents).
						//print('not indexical_match<br>');
						if(ReTidy::isAFootnote($content_piece_matches[$content_piece_counter][0])) {
							//$to_add .= $content_piece_matches[$content_piece_counter][0] . '
//';
							$to_add .= substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
						} else {
							// skip a single TOC item that cannot be matched if the match is on the next TOC item
							// only synchronize if absolutely necessary; that is, if the TOC item we are on cannot be matched at all...
							$there_is_a_future_match = false;
							$temp_content_piece_counter = 1;
							while($content_piece_counter + $temp_content_piece_counter < $size) {
								if(ReTidy::indexical_match($content_piece_matches[$content_piece_counter + $temp_content_piece_counter][0], $this->TOCStructureArray[$TOC_counter][1])) {
									$there_is_a_future_match = true;
									break;
								}
								$temp_content_piece_counter++;
							}
							// I guess this could be generalized into synchronicity code... (by making it a while instead of an if)
							if(ReTidy::indexical_match($content_piece_matches[$content_piece_counter][0], $this->TOCStructureArray[$TOC_counter + 1][1]) && !$there_is_a_future_match) {
								//print('synchronization: <br>');
								//print('synch content piece: ');var_dump($content_piece_matches[$content_piece_counter][0]);
								//print('synch TOC piece: ');var_dump($this->TOCStructureArray[$TOC_counter + 1][1]);
								while(!ReTidy::isIndexical($content_piece_matches[$content_piece_counter][0])) {
									$to_add .= substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
									$content_piece_counter++;
								}
								$this->pageStructureArray[] = array("?", $to_add);
								//if($this->config['trust_headings'] === false) {
									$this->TOCStructureArray[$TOC_counter][0] = "?";
								//}
								$previous_TOC_level = $this->TOCStructureArray[$TOC_counter][0];
								$TOC_counter++;
								$level = $this->TOCStructureArray[$TOC_counter][0];
								if($level === 1) {
									$this->did_an_h1 = true;
								}
								$previous_level = $level;
								$to_headingify = substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
								if($this->config['trust_headings'] !== true) {
									$level = $this->TOCStructureArray[$TOC_counter][0];
								} else {
									$level = ReTidy::get_heading_level_from_code($to_headingify);
								}
								$to_add = $to_headingify . '
';
								unset($this->array_order_indicators_not_in_TOC);
								$previous_TOC_level = $this->TOCStructureArray[$TOC_counter][0];
								$TOC_counter++;
							} else {
								// if we get here meaning that we think we have a heading but that it is not in the table of contents and so its heading
								// level has not been determined, then we need to attempt to determine it.
								$this->pageStructureArray[] = array($level, $to_add);
								//print('to_add 004: ');var_dump($to_add);
								//print("page structure array 004: ");var_dump($this->pageStructureArray);
								if($level === 1) {
									$this->did_an_h1 = true;
								}
								$previous_level = $level;
								//$to_headingify = $content_piece_matches[$content_piece_counter][0];
								$to_headingify = substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
								//print('to_headingify: ');var_dump($to_headingify);
								//$previous_TOC_level = $this->TOCStructureArray[$TOC_counter - 1][0];
								if($this->config['trust_headings'] !== true) {
									//print('trusting headings 609:<br>');
									$level = ReTidy::get_level_based_on_array_order_indicators_not_in_TOC($to_headingify, $previous_TOC_level, $previous_level);
								} else {
									//print('not trusting headings 609:<br>');
									$level = ReTidy::get_heading_level_from_code($to_headingify);
								}
								//print('level _1_: ');var_dump($level);
								//print('to_headingify: ');var_dump($to_headingify);
								$to_add = $to_headingify . '
';
							}
						}
					}
					$content_piece_counter++;
				}
				$this->pageStructureArray[] = array($level, $to_add);
				//print('to_add 005: ');var_dump($to_add);
				//print("page structure array 005: ");var_dump($this->pageStructureArray);
				if($level === 1) {
					$this->did_an_h1 = true;
				}
				$previous_level = $level;
				//print("this->TOCStructureArray 3983983: ");var_dump($this->TOCStructureArray);
				//print("this->pageStructureArray 3983983: ");var_dump($this->pageStructureArray);
				if(sizeof($this->TOCStructureArray) === $TOC_counter) { // then we found a match in the content for every TOC item
					
				} else {
					//print("Attempting sub-TOC processing<br>\r\n");
					// if we get to here and have not done the last TOC item, there is the possibility that we have a "sub-TOC" whose domain is 
					// over the same content so that we may still have to (de)headingify stuff even though the pageStructureArray is presumably complete
					$TOC_size = sizeof($this->TOCStructureArray);
					$page_structure_array_size = sizeof($this->pageStructureArray);
					//print("TOC_counter: ");var_dump($TOC_counter);
					//print("TOC_size: ");var_dump($TOC_size);
					while($TOC_counter < $TOC_size) {
						while($this->TOCStructureArray[$TOC_counter][0] === "?") {
							$previous_TOC_level = $this->TOCStructureArray[$TOC_counter][0];
							$TOC_counter++;
						}
						$page_structure_counter = 0;
						while($page_structure_counter < $page_structure_array_size) {
							$to_headingify = $this->pageStructureArray[$page_structure_counter][1];
							if(strpos($to_headingify, "<caption>") !== false) {
								preg_match('/<caption[^<>]*?>(.*?)<\/caption>/is', $to_headingify, $heading_part_matches);
								$heading_part = $heading_part_matches[0];
							} else {
								preg_match('/<(\w+)[^<>]*?>(.*?)<\/\1>/is', $to_headingify, $heading_part_matches);
								$heading_part = $heading_part_matches[0];
							}
							$TOC_piece = $this->TOCStructureArray[$TOC_counter][1];
							while($page_structure_counter !== $page_structure_array_size && (strpos($heading_part, ' TOCheadingified="true"') !== false || !ReTidy::indexical_match($heading_part, $TOC_piece))) {
								//print("heading_part: ");var_dump($heading_part);
								//print("TOC_piece: ");var_dump($TOC_piece);
								$page_structure_counter++;
								$to_headingify = $this->pageStructureArray[$page_structure_counter][1];
								if(strpos($to_headingify, "<caption>") !== false) {
									preg_match('/<caption[^<>]*?>(.*?)<\/caption>/is', $to_headingify, $heading_part_matches);
									$heading_part = $heading_part_matches[0];
								} else {
									preg_match('/<(\w+)[^<>]*?>(.*?)<\/\1>/is', $to_headingify, $heading_part_matches);
									$heading_part = $heading_part_matches[0];
								}
							}
							if($page_structure_counter === $page_structure_array_size) {
								$previous_TOC_level = $this->TOCStructureArray[$TOC_counter][0];
								$TOC_counter++;
								continue 2;
							}
							//print("heading_part (match): ");var_dump($heading_part);
							//print("TOC_piece (match): ");var_dump($TOC_piece);
							//if(strpos($to_headingify, "<caption") !== false) { // then we need to repair our pageStructureArray so that it does not break into the starts of <table>s
								//print("need to repair our pageStructureArray");exit(0);
							//	$to_headingify = preg_replace('/<caption([^<>]*?)>/is', '<caption$1 TOCheadingified="true">', $to_headingify, 1);
							//} else {
							//	$to_headingify = preg_replace('/<(\w+)([^<>]*?)>(.*?)<\/\1>/is', '<$1$2 TOCheadingified="true">$3</$1>', $to_headingify, 1);
							//}
							$to_headingify = ReTidy::TOCheadingified_mark($to_headingify);
							$level = $this->TOCStructureArray[$TOC_counter][0];
							$this->pageStructureArray[$page_structure_counter] = array($level, $to_headingify);
							$previous_level = $level;
							//unset($this->array_order_indicators_not_in_TOC); // probably not needed
							$previous_TOC_level = $this->TOCStructureArray[$TOC_counter][0];
							$TOC_counter++;
							$page_structure_counter++;
						}
					}
					//print("this->TOCStructureArray 3983984: ");var_dump($this->TOCStructureArray);
					//print("this->pageStructureArray 3983984: ");var_dump($this->pageStructureArray);exit(0);
					if(sizeof($this->TOCStructureArray) > $TOC_counter) {
						ReTidy::warning('Was trying to generate page structure from the table of contents but got stuck on table of contents item: ');
						print("this->TOCStructureArray[TOC_counter][0]");var_dump($this->TOCStructureArray[$TOC_counter][0]);
						print("sizeof(this->TOCStructureArray): ");var_dump(sizeof($this->TOCStructureArray));
						print("TOC_counter: ");var_dump($TOC_counter);
						ReTidy::warning('If the table of contents indicates more than is in the content (such as a page that is only a table of contents), then this is okay.');
					}
				}
			} else { // still try to determine heading levels based on their and previous order indicators.
				$to_add = "";
				$level = "?";
				$content_piece_counter = 0;
				$previous_TOC_level = 1; // we are treating all the headings as under a fictional <h1> that is the only heading in the fictional table of contents
				while($content_piece_counter < $size) {
					if(ReTidy::isIndexical($content_piece_matches[$content_piece_counter][0])) {
						// we need to prevent improperly written footnotes (missing punctuation at the end, etc...) from becoming headings.
						if(ReTidy::isAFootnote($content_piece_matches[$content_piece_counter][0])) {
							$to_add .= substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
							//$to_add .= $content_piece_matches[$content_piece_counter][0] . '
//';
						} else {
							$this->pageStructureArray[] = array($level, $to_add);
							if($level === 1) {
								$this->did_an_h1 = true;
							}
							$previous_level = $level;
							//$to_headingify = $content_piece_matches[$content_piece_counter][0];
							$to_headingify = substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
							// this does not account for non-paragraph or heading tags that are indeixical; oh well maybe...
							//print('to_headingify: ');var_dump($to_headingify);
							//print('level: ');var_dump($level);
							if($this->config['trust_headings'] !== true) {
								//print('trusting headings 610:<br>');
								$level = ReTidy::get_level_based_on_array_order_indicators_not_in_TOC($to_headingify, $previous_TOC_level, $previous_level);
							} else {
								//print('not trusting headings 610:<br>');
								$level = ReTidy::get_heading_level_from_code($to_headingify);
							}
							//print('$level _2_: ');var_dump($level);
							//print('$to_headingify _2_: ');var_dump($to_headingify);
							$to_add = $to_headingify;
						}
					} else {
						$to_add .= substr($this->bodyCode, $content_piece_matches[$content_piece_counter][1], $content_piece_matches[$content_piece_counter + 1][1] - $content_piece_matches[$content_piece_counter][1]);
						//$to_add .= $content_piece_matches[$content_piece_counter][0] . '
//';
					}
					$content_piece_counter++;
				}
				$this->pageStructureArray[] = array($level, $to_add);
				if($level === 1) {
					$this->did_an_h1 = true;
				}
				$previous_level = $level;
			}
		} else { // this page has no content...
			$this->pageStructureArray[] = array("?", "");
		}
		$post = ReTidy::get_post($this->bodyCode);
		$this->pageStructureArray[] = array("post", $post);
		
		//print("TOC structure array 2452354: ");var_dump($this->TOCStructureArray);
		//print("page structure array 2452354: ");var_dump($this->pageStructureArray);exit(0);
		foreach($this->pageStructureArray as $index => $value) {
			$this->pageStructureArray[$index] = array($value[0], str_replace(' TOCheadingified="true"', '', $value[1]));
		}
		// here we decide whether we think that the program can improve the structure of the page
		if($this->config['trust_headings'] === 'if_they_seem_sufficient') {
			$headings_found_in_structure = 0;
			foreach($this->pageStructureArray as $index => $value) {
				$level = $value[0];
				if(is_numeric($level) && $level > 0 && $level < 7) {
					$headings_found_in_structure++;
				}
			}
			$page_h2s_found = 0;
			$page_h3s_found = 0;
			$page_h4s_found = 0;
			$page_h5s_found = 0;
			$page_h6s_found = 0;
			preg_match_all('/<h([1-6])/is', $this->bodyCode, $matches);
			foreach($matches as $index => $value) {
				$level = $value[1];
				if($level === 2) {
					$page_h2s_found++;
				} elseif($level === 3) {
					$page_h3s_found++;
				} elseif($level === 4) {
					$page_h4s_found++;
				} elseif($level === 5) {
					$page_h5s_found++;
				} elseif($level === 6) {
					$page_h6s_found++;
				}
			}
			//print('$matches: ');var_dump($matches);
			$headings_found = sizeof($matches[0]);
			//print('headings_found_in_structure: ');var_dump($headings_found_in_structure);
			//print('headings_found: ');var_dump($headings_found);
			//print('bcdiv(headings_found, headings_found_in_structure, 2): ');var_dump(bcdiv($headings_found, $headings_found_in_structure, 2));
			if(($headings_found_in_structure - $headings_found < 2 && $headings_found - $headings_found_in_structure < 2) // there is an absolute difference of less than 2
			|| (bcdiv($headings_found, $headings_found_in_structure, 2) > 0.5 && bcdiv($headings_found, $headings_found_in_structure, 2) < 2)) {
				if($this->foundTOC) {
					$TOC_h2s_found = 0;
					$TOC_h3s_found = 0;
					$TOC_h4s_found = 0;
					$TOC_h5s_found = 0;
					$TOC_h6s_found = 0;
					$headings_found_in_TOC_structure = 0;
					foreach($this->TOCStructureArray as $index => $value) {
						$level = $value[0];
						if(is_numeric($level) && $level > 0 && $level < 7) {
							$headings_found_in_TOC_structure++;
							if($level === 2) {
								$TOC_h2s_found++;
							} elseif($level === 3) {
								$TOC_h3s_found++;
							} elseif($level === 4) {
								$TOC_h4s_found++;
							} elseif($level === 5) {
								$TOC_h5s_found++;
							} elseif($level === 6) {
								$TOC_h6s_found++;
							}
						}
					}
					if(!($page_h2s_found - $TOC_h2s_found < 2 && $TOC_h2s_found - $page_h2s_found < 2)) {
						//print('not trusting headings 34456<br>');
						$this->config['trust_headings'] = false;
					} elseif($page_h2s_found > 0 && $TOC_h2s_found > 0 && 
					!(bcdiv($TOC_h2s_found, $page_h2s_found, 2) > 0.5 && bcdiv($TOC_h2s_found, $page_h2s_found, 2) < 2)) {
						//print('not trusting headings 34457<br>');
						$this->config['trust_headings'] = false;
					} elseif(!($page_h3s_found - $TOC_h3s_found < 2 && $TOC_h3s_found - $page_h3s_found < 2)) {
						//print('not trusting headings 34458<br>');
						$this->config['trust_headings'] = false;
					} elseif($page_h3s_found > 0 && $TOC_h3s_found > 0 && 
					!(bcdiv($TOC_h3s_found, $page_h3s_found, 2) > 0.5 && bcdiv($TOC_h3s_found, $page_h3s_found, 2) < 2)) {
						//print('not trusting headings 34459<br>');
						$this->config['trust_headings'] = false;
					} elseif(!($page_h4s_found - $TOC_h4s_found < 2 && $TOC_h4s_found - $page_h4s_found < 2)) {
						//print('not trusting headings 34460<br>');
						$this->config['trust_headings'] = false;
					} elseif($page_h4s_found > 0 && $TOC_h4s_found > 0 && 
					!(bcdiv($TOC_h4s_found, $page_h4s_found, 2) > 0.5 && bcdiv($TOC_h4s_found, $page_h4s_found, 2) < 2)) {
						//print('not trusting headings 34461<br>');
						$this->config['trust_headings'] = false;
					} elseif(!($page_h5s_found - $TOC_h5s_found < 2 && $TOC_h5s_found - $page_h5s_found < 2)) {
						//print('not trusting headings 34462<br>');
						$this->config['trust_headings'] = false;
					} elseif($page_h5s_found > 0 && $TOC_h5s_found > 0 && 
					!(bcdiv($TOC_h5s_found, $page_h5s_found, 2) > 0.5 && bcdiv($TOC_h5s_found, $page_h5s_found, 2) < 2)) {
						//print('not trusting headings 34463<br>');
						$this->config['trust_headings'] = false;
					} elseif(!($page_h6s_found - $TOC_h6s_found < 2 && $TOC_h6s_found - $page_h6s_found < 2)) {
						//print('not trusting headings 34464<br>');
						$this->config['trust_headings'] = false;
					} elseif($page_h6s_found > 0 && $TOC_h6s_found > 0 && 
					!(bcdiv($TOC_h6s_found, $page_h6s_found, 2) > 0.5 && bcdiv($TOC_h6s_found, $page_h6s_found, 2) < 2)) {
						//print('not trusting headings 34465<br>');
						$this->config['trust_headings'] = false;
					} else {
						$this->config['trust_headings'] = true;
					}
				} else {
					//print('trusting headings<br>');
					$this->config['trust_headings'] = true;
				}
			} else {
				//print('not trusting headings<br>');
				//print('$headings_found_in_structure: ');var_dump($headings_found_in_structure);
				//print('$headings_found: ');var_dump($headings_found);
				$this->config['trust_headings'] = false;
			}
		}
		
		// for structure to be applicable beyond simple cases (like documents coming from clean_word) we have to ensure proper nesting of the 
		// page structure array given that semantic sections may not be coincidentally detected with their properly nested code.
		/*$this->pageStructureArray = array(
		array('pre', ''),
		array('TOC', ''),
		array(2, '<h2>Heading level 2 number 1</h2>'),
		);*/
		//print("page structure array 2452351: ");var_dump($this->pageStructureArray);
		ReTidy::ensure_proper_pageStructureArray_nesting();
		//print('$this->pageStructureArray[9][1]: ' . $this->pageStructureArray[9][1]);
		if(!isset($this->config["anchor_text"])) {
			$this->config["anchor_text"] = 'section';
		}
		if(!isset($this->config['TOC_sub'])) {
			$this->config['TOC_sub'] = 'lists';
		}
		// if we are doing a CED document, then override the anchor text
		if($this->department === 'DEC') {
			$this->config['TOC_sub'] = 'CED';
		}
		if($this->config['TOC_sub'] === 'CED') {
			$this->config["anchor_text"] = 'chp';
			if($this->language === "french") {
				$this->CED_top_page_string = '<div class="topPage"><a title="Retourner au haut de la page" href="#tphp"><img height="12" alt="Haut de la page" width="19" src="http://www.dec-ced.gc.ca/docs/images/tphp.gif" /><br />
Haut de la page</a></div>
';
			} else {
				$this->CED_top_page_string = '<div class="topPage"><a title="Return to Top of Page" href="#tphp"><img height="12" alt="Top of Page" width="19" src="http://www.dec-ced.gc.ca/docs/images/tphp.gif" /><br />
Top of Page</a></div>
';
			}
		}
		$this->existing_anchors_array = array();
		if($this->foundTOC) {
			foreach($this->TOCStructureArray as $index => $value) {
				$level = $value[0];
				if(is_numeric($level)) {
					$code = $value[1];
					preg_match('/ href="([^"]*?)"/is', $code, $link_matches);
					//var_dump($link_matches);
					if(preg_match('/#(.+)/is', $link_matches[1], $anchor_matches, PREG_OFFSET_CAPTURE)) {
						$anchor = strtolower($anchor_matches[1][0]);
						$anchor_position = $anchor_matches[0][1];
						$page = substr($link_matches[1], 0, $anchor_position);
					} else {
						$page = $link_matches[1];
					}
					// prevent invalid anchors
					preg_match('/[0-9]/is', $anchor, $anchor_matches, PREG_OFFSET_CAPTURE);
					if(sizeof($anchor_matches[0]) > 0 && $anchor_matches[0][0][1] === 0) {
						$anchor = $this->config["anchor_text"] . '_' . $anchor;
					}
					$this->existing_anchors_array[] = array($level, $anchor, $page);
				}
			}
		}
		if($this->config['preserve_existing_ids'] === true) {

		} else {
			$this->config['preserve_existing_ids'] = false;
		}
		//print('$this->existing_anchors_array: ');var_dump($this->existing_anchors_array);exit(0);
		
		/*
		// testing only... it has to go somewhere...
		$counter = 0;
		$array_letters = array();
		while($counter < 100) {
			$array_letters[] = ReTidy::decimal_to_alphabetical($counter);
			$counter++;
		}
		var_dump($array_letters);
		foreach($array_letters as $index => $letter) {
			print($index . '. ' . ReTidy::alphabetical_to_decimal($letter) . '<br>');
		}
		exit(0);*/
		
		
		//print("TOC structure array 2452356: ");var_dump($this->TOCStructureArray);
		//print("page structure array 2452356: ");var_dump($this->pageStructureArray);exit(0);
		return true;
	}
	
	protected function ensure_proper_pageStructureArray_nesting() {
		// try to test a harder version of the problematic case
		// this really has the potential to explode... oh well
		// it is currently not perfect but possibly sufficient since the type of multiple nesting that this function does not handle
		// may never occur
		//print('$this->pageStructureArray[9][1]: ' . $this->pageStructureArray[9][1]);
		//print('before: ');var_dump($this->pageStructureArray);
		$newPageStructureArray = array();
		$to_add = '';
		$to_retroactively_add = '';
		foreach($this->pageStructureArray as $index => $value) {
			//print('<br>code: ' . $value[1]);
			$ancestryArray = OM::getAncestryArray($value[1]);
			//print('ancestry array: ');var_dump($ancestryArray);
			$new_value1 = $value[1];
			if(strlen($to_add) > 0) {
				//$this->pageStructureArray[$index] = array($this->pageStructureArray[$index][0], $to_add . $this->pageStructureArray[$index][1]);
				//$value = array($value[0], $to_add . $value[1]);
				$to_retroactively_add = $to_add;
				$to_add = '';
			}
			if(sizeof($ancestryArray) > 0) { // throw the tags in it onto the beginning of the the next page structure element
				//print('substr($new_value1, 0, $first_offset): ' . substr($new_value1, 0, $first_offset));
				//print('substr($new_value1, $first_offset): ' . substr($new_value1, $first_offset));
				//$this->pageStructureArray[$index] = array($value[0], substr($value[1], 0, $first_offset));
				$ancestry_new_value1 = '';
				//$to_add = '';
				$keep_open_offset = 0;
				foreach($ancestryArray as $a_index => $a_value) {
					$keep_close_offset = $ancestryArray[$a_index][2];
					$ancestry_new_value1 .= substr($new_value1, $keep_open_offset, $keep_close_offset - $keep_open_offset);
					$keep_open_offset = $keep_close_offset + strlen($a_value[1]);
					$to_add .= $a_value[1] . '
';
				}
				$keep_close_offset = strlen($new_value1);
				$ancestry_new_value1 .= substr($new_value1, $keep_open_offset, $keep_close_offset - $keep_open_offset);
				$new_value1 = $ancestry_new_value1;
				//$this->pageStructureArray[$index + 1] = array($this->pageStructureArray[$index + 1][0], $to_add . $this->pageStructureArray[$index + 1][1]);
				//var_dump($this->pageStructureArray);
			}
			if(strlen($to_retroactively_add) > 0) {
				//$this->pageStructureArray[$index] = array($this->pageStructureArray[$index][0], $to_add . $this->pageStructureArray[$index][1]);
				$new_value1 = $to_retroactively_add . $new_value1;
				$to_retroactively_add = '';
			}
			//print('$new_value1: ' . $new_value1);
			$newPageStructureArray[$index] = array($value[0], $new_value1);
		}
		$this->pageStructureArray = $newPageStructureArray;
		//print('$this->pageStructureArray[9][1]: ' . $this->pageStructureArray[9][1]);
		//print('after: ');var_dump($this->pageStructureArray);exit(0);
	}
	
	protected function check_page_structure() {
		// this function is now (2011-11-01) a derelict since it has been gutted by build_page_structure
		if($this->foundPage && sizeof($this->pageStructureArray) > 0 && $this->pageStructureArray !== false) {
			/*
			// first check for the unlikely case of (an?) improper h1(s?)
			// ok, so by definition: any h1 after non-indexical content is improper.
			// therefore, if such an h1 is found then try to assign it the proper level otherwise make it a paragraph.
			// by indexical content before...
			foreach($this->pageStructureArray as $index => $value) {
				$found_previous_indexical_content = false;
				$level = $value[0];
				if($level == 1) { // then check if there is indexical content before it.
					$counter = $index - 1;
					while($counter > -1) {
						preg_match_all('/<p[^<>]*?>(.*?)<\/p>/is', $this->pageStructureArray[$index][1], $p_matches);
						// not perfect although it should be quite unlikely for <p>s to be nested;
						// if they were, we would need to use OM
						foreach($p_matches as $p_index => $p_value) {
							if(ReTidy::isIndexical($p_matches[1][$p_index])) {
								$found_previous_indexical_content = true;
								foreach($this->pageStructureArray as $i_for_h1s_to_change => $v_for_h1s_to_change) {
									if($v_for_h1s_to_change[0] == 1) {
										$replaced = preg_replace('/<h1([^<>]*?>.*?)<\/h1>/is', '<p$1</p>', $this->pageStructureArray[$i_for_h1s_to_change][1]);
										$this->pageStructureArray[$i_for_h1s_to_change] = array(0, $replaced);
									}
								}
								break 2;
							}
						}
						$counter--;
					}
				}
			}
			$found_self_validating_heading = false;
			$newPageStructureArray = array();
			foreach($this->pageStructureArray as $index => $value) {
				$level = $value[0];
				$section_code = $value[1];
				$level_guess = "?";
				if($level == 1 || $level == 2 || $level == 3 || $level == 4 || $level == 5 || $level == 6) {
					$level_guess = ReTidy::determine_heading_level($section_code);
				}
				if(!$found_self_validating_heading && $level_guess !== "?" && $level_guess !== "0" && $level_guess !== false) {
					$found_self_validating_heading = true;
				}
				$newPageStructureArray[$index] = array($level, $section_code, $level_guess);
			}
			$this->pageStructureArray = $newPageStructureArray;
			// could there be more than one post section?
			$post_array = $this->pageStructureArray[sizeof($this->pageStructureArray) - 1];
			// build the page structure array from paragraph headings corresponding to the table of contents
			$pre = false;
			$TOC = false;
			$post = false;
			foreach($this->pageStructureArray as $index => $value) {
				if($value[0] === "pre") {
					$pre = $value[1];
				}
				if($value[0] === "TOC") {
					$TOC = $value[1];
				}
				if($value[0] === "post") {
					$post = $value[1];
				}
			}
			if($pre === false) {
				print("Maybe should never happen...?388849000fh<br>\r\n");
				$pre = ReTidy::get_pre($this->bodyCode);
			}
			if($post === false) {
				print("Maybe should never happen...?388849000fj<br>\r\n");
				$post = ReTidy::get_post($this->bodyCode);
			}*/
			// right here we are resetting the pageStructureArray so any work previous is wasted!!!
		//	$this->pageStructureArray = array();
		//	$this->pageStructureArray[] = array("pre", $pre);
		//	if(strlen($pre) === 0) {
		//		$position_of_pre = 0;
		//	} else {
		//		$position_of_pre = strpos($this->bodyCode, $pre);
		//	}
			
			// try to identify the h1?
			
		}
		// clean up the page strcuture array of marking comments used for sub-TOC processing
		
		return true;
	}
	
	function isAFootnote($string) {
		// <p><sup><a href="#_ftnref13" id="_ftn13">[13]</a></sup> I<em>bid</em>., at p.406.</p>
		if(strpos($string, 'href="#_ftnref') !== false) {
			return true;
		}
		if(strpos($string, 'id="_ftn') !== false) {
			return true;
		}
		if(strpos($string, 'id="footnote') !== false) {
			return true;
		}
		return false;
	}
	
	function remove_word_styles() { // stupid function just to test
		$this->code = preg_replace('/<style[^<>]*?>(.*?)<\/style>/is', '<style type="text/css"></style>', $this->code);
	}
	
	function remove_tags($string, $tagNames) {
		if(!isset($string)) {
			print("No string was supplied in function remove_tags.<br>\r\n");
			return false;
		}
		if(isset($string) && !isset($tagNames)) {
			print("No tagNames were supplied in function remove_tags.<br>\r\n");
			return $string;
		}
		if(!is_array($tagNames)) {
			$tagNames = array($tagNames);
		}
		foreach($tagNames as  $tagName) {
			// how should we deal with attributes on the tag we are removing?
			$string = preg_replace('/<' . $tagName . '([^<>]*?)>/is', '', $string);
			// apparently hope this function is only called on tags we absolutely want to get rid of (including attributes)
			$string = str_replace('</' . $tagName . '>', '', $string);
		}
		return $string;
	}
	
	function indexical_match($item1, $item2) {
		ReTidy::words_init();
		if($item1 === false || $item2 === false || $item1 === NULL || $item2 === NULL || strlen($item1) === 0 || strlen($item2) === 0 || strlen(ReTidy::tagless($item1)) === 0 || strlen(ReTidy::tagless($item2)) === 0) {
			//print('here034044-<br>');
			return false;
		}
		//print("item1: ");var_dump($item1);
		//print("item2: ");var_dump($item2);
		$item1 = mb_strtolower($item1);
		$item2 = mb_strtolower($item2);
		// stop words should be ignored
		foreach($this->stop_words_array as $stop_word) {
			$item1 = ReTidy::str_replace_whole_word($stop_word, '', $item1);
			$item2 = ReTidy::str_replace_whole_word($stop_word, '', $item2);
		}
		//print("single_charactersified_item1 _3_: ");var_dump($item1);
		//print("single_charactersified_item2 _3_: ");var_dump($item2);
		$single_charactersified_item1 = ReTidy::taglessSingleCharactersify($item1);
		$single_charactersified_item2 = ReTidy::taglessSingleCharactersify($item2);
		//print("single_charactersified_item1 _4_: ");var_dump($single_charactersified_item1);
		//print("single_charactersified_item2 _4_: ");var_dump($single_charactersified_item2);
		$single_charactersified_item1 = trim($single_charactersified_item1);
		$single_charactersified_item2 = trim($single_charactersified_item2);
		//print("single_charactersified_item1 _2_: ");var_dump($single_charactersified_item1);
		//print("single_charactersified_item2 _2_: ");var_dump($single_charactersified_item2);
		// clean these up even more to facilitate matching
		// page number references
		$single_charactersified_item1 = ReTidy::trim_page_reference($single_charactersified_item1);
		$single_charactersified_item2 = ReTidy::trim_page_reference($single_charactersified_item2);
		//print("single_charactersified_item1 _: ");var_dump($single_charactersified_item1);
		//print("single_charactersified_item2 _: ");var_dump($single_charactersified_item2);
		if($single_charactersified_item1 === false || 
		$single_charactersified_item2 === false || 
		$single_charactersified_item1 === NULL || 
		$single_charactersified_item2 === NULL || 
		strlen($single_charactersified_item1) === 0 ||
		strlen($single_charactersified_item2) === 0
		) {
			//print('here034045-<br>');
			return false;
		}
		// order indicators
		$initial_s_t = "XXX9o9LoopingDummyText9o9XXX";
		while($initial_s_t !== $single_charactersified_item2) { // loop for stupid cases
			$initial_s_t = $single_charactersified_item2;
			preg_match('/(chapter|chart){0,1}(chapitre){0,1}\s{1,}/is', $single_charactersified_item2, $s_t_matches1, PREG_OFFSET_CAPTURE);
			if($s_t_matches1[0][1] === 0) { // it is at the start of the string
				$single_charactersified_item2 = substr($single_charactersified_item2, strlen($s_t_matches1[0][0]));
			}
			preg_match('/([ivxlcdm]{1,}[\.\)]\s*){0,}([^a-z]{0,}\s*)/is', $single_charactersified_item2, $s_t_matches2, PREG_OFFSET_CAPTURE);
			if($s_t_matches2[0][1] === 0) { // it is at the start of the string
				$single_charactersified_item2 = substr($single_charactersified_item2, strlen($s_t_matches2[0][0]));
			}
		}
		$initial_s_p = "XXX9o9LoopingDummyText9o9XXX";
		while($initial_s_p !== $single_charactersified_item1) { // loop for stupid cases
			$initial_s_p = $single_charactersified_item1;
			preg_match('/(chapter|chart){0,1}(chapitre){0,1}\s{1,}/is', $single_charactersified_item1, $s_p_matches1, PREG_OFFSET_CAPTURE);
			if($s_p_matches1[0][1] === 0) { // it is at the start of the string
				$single_charactersified_item1 = substr($single_charactersified_item1, strlen($s_p_matches1[0][0]));
			}
			preg_match('/([ivxlcdm]{1,}[\.\)]\s*){0,}([^a-z]{0,}\s*)/is', $single_charactersified_item1, $s_p_matches2, PREG_OFFSET_CAPTURE);
			if($s_p_matches2[0][1] === 0) { // it is at the start of the string
				$single_charactersified_item1 = substr($single_charactersified_item1, strlen($s_p_matches2[0][0]));
			}
		}
		
		//print("single_charactersified_item1: ");var_dump($single_charactersified_item1);
		//print("single_charactersified_item2: ");var_dump($single_charactersified_item2);
		//$test_string = '';
		//var_dump(explode('8', $test_string));exit(0);
		if(strlen($single_charactersified_item1) < 2 ||
		strlen($single_charactersified_item2) < 2) { // we call this non-indexical
			return false;
		}
		$item1_words_array = explode(" ", $single_charactersified_item1);
		$item2_words_array = explode(" ", $single_charactersified_item2);
		$item1_words_array_size = sizeof($item1_words_array);
		$item2_words_array_size = sizeof($item2_words_array);
		if(bcdiv($item1_words_array_size, $item2_words_array_size, 3) > 0.5 && 2 > bcdiv($item1_words_array_size, $item2_words_array_size, 3)) {
			$word_matches = 0;
			// simplistic comparison that will lessen the influence of common words (such as stop words) 
			// said otherwise; the more stop words-ish words, the more likely this will be called a match
			// notice also that if, for example, the first item has 4 "word"s and the second item has one "word", the word matches count will increment four times
			// to prevent tis we would need some sort of sophisticated progressive comparison
			foreach($item1_words_array as $item1_word_index => $item1_word_value) {
				foreach($item2_words_array as $item2_word_index => $item2_word_value) {
					if(strlen($item1_word_value) === 0) {
						print("item1_word_value strlen 0");var_dump($item1_word_value);
						print('item1: ');var_dump($item1);
						print('item2: ');var_dump($item2);
						print('single_charactersified_item1: ');var_dump($single_charactersified_item1);
						print('single_charactersified_item2: ');var_dump($single_charactersified_item2);
						print('item1_words_array: ');var_dump($item1_words_array);
						exit(0);
					}
					if(strlen($item2_word_value) === 0) {
						print("item2_word_value strlen 0");var_dump($item2_word_value);
						print('item1: ');var_dump($item1);
						print('item2: ');var_dump($item2);
						print('single_charactersified_item1: ');var_dump($single_charactersified_item1);
						print('single_charactersified_item2: ');var_dump($single_charactersified_item2);
						print('item2_words_array: ');var_dump($item2_words_array);
						exit(0);
					}
					if(
					(strlen($item1_word_value) - strlen($item2_word_value) < 2) && (strlen($item1_word_value) - strlen($item2_word_value) > -2) // they are within 1 length 
					&& (strpos($item1_word_value, $item2_word_value) === 0 || strpos($item2_word_value, $item1_word_value) === 0) // one contains the other
					) {
						//var_dump($item1_word_value);
						//var_dump($item2_word_value);
						$word_matches++;
					}
				}
			}
			if(bcdiv($word_matches, $item2_words_array_size, 3) > 0.5) {
				//print('Indexical match<br>');
				return true;
			}
		}
		//print('Indexical non-match<br>');
		return false;
	}
	
	protected function remove_duplicate_anchors($code) {
		//print('code: ');var_dump($code);
		// we could make this generalized and do something like remove the second one in any case if there is a duplicate
		// but keeping it very specific, as we will, allows us to preserve idiosyncratic anchoring; such as preserving anchors on <a> tags.
		$code = preg_replace('/<h([1-6])([^<>]*?) id="([^"]*?)"([^<>]*?)><a([^<>]*?) id="\3"([^<>]*?)>(.*?)<\/h\1>/is', '<h$1$2$4><a$5 id="$3"$6>$7</h$1>', $code);
		return $code;
	}
	
	function acronyms_and_abbr_encode_retaining_offsets($string) {
		// probably will only be used since "<a" is a substring of "<acronym" and "<abbr"
		$string = preg_replace('/<acronym title="([^"]*?)">(.*?)<\/acronym>/is', '^acronym title="$1"^$2^/acronym^', $string);
		$string = preg_replace('/<abbr title="([^"]*?)">(.*?)<\/abbr>/is', '^abbr title="$1"^$2^/abbr^', $string);
		return $string;
	}
	
	function acronyms_and_abbr_retaining_offsets_decode($string) {
		//print('pre $string: ');var_dump($string);
		// probably will only be used since "<a" is a substring of "<acronym" and "<abbr"
		$string = preg_replace('/\^acronym title="([^"]*?)"\^(.*?)\^\/acronym\^/is', '<acronym title="$1">$2</acronym>', $string);
		$string = preg_replace('/\^abbr title="([^"]*?)"\^(.*?)\^\/abbr\^/is', '<abbr title="$1">$2</abbr>', $string);
		//print('post $string: ');var_dump($string);
		return $string;
	}
	
	protected function remove_preexisting_id($string) {
		//print('$string: ');var_dump($string);
		preg_match('/<(\w+)([^<>]*?) id="([^"]*?)"([^<>]*?)>/is', $string, $attribute_anchor_matches, PREG_OFFSET_CAPTURE);
		if($attribute_anchor_matches[0][1] === 0) { // it is at the start
			$initial_tag = $attribute_anchor_matches[0][0];
			$tag = '<' . $attribute_anchor_matches[1][0] . $attribute_anchor_matches[2][0] . $attribute_anchor_matches[4][0] . '>';
			$string = ReTidy::str_replace_first($initial_tag, $tag, $string);
		}
		//print('$string: ');var_dump($string);
		preg_match('/<(\w+)([^<>]*?)>((<[^<>]+?>\s*)*?)<a ([^<>]*?)id="([^"]*?)"([^<>]*?)>/is', $string, $first_child_anchor_matches, PREG_OFFSET_CAPTURE);
		//var_dump($first_child_anchor_matches);
		if($first_child_anchor_matches[0][1] === 0) { // it is at the start
			$initial_tag = $first_child_anchor_matches[0][0];
			$tag = '<' . $first_child_anchor_matches[1][0] . $first_child_anchor_matches[2][0] . '>' . $first_child_anchor_matches[3][0] . '<a ' . $first_child_anchor_matches[5][0] . $first_child_anchor_matches[7][0] . '>';
			$string = ReTidy::str_replace_first($initial_tag, $tag, $string);
		}
		//print('$string: ');var_dump($string);
		return $string;
	}
	
	protected function cleanPageStructureArray($array) {
		// clean the page structure array of extraneous entries (probably created by trusting heading levels and adjusting partisanship od content accordingly)
		$newPageStructureArray = array();
		foreach($array as $index => $value) {
			if($value[0] === "?" && strlen($value[1]) === 0) {
			
			} else {
				$newPageStructureArray[] = $value;
			}
		}
		return $newPageStructureArray;
	}
	
	protected function fix_page_structure() {
		//print("this->TOCStructureArray4443737345: ");var_dump($this->TOCStructureArray);
		//print("this->pageStructureArray4443737345: ");var_dump($this->pageStructureArray);exit(0);
		// trim page number references...
		// besides the fact that this could make mistakes (where a heading ends with a number), 
		// page number references should have already been removed
		//if($this->foundTOC && sizeof($this->TOCStructureArray) > 0 && $this->TOCStructureArray !== false) {
		//	foreach($this->TOCStructureArray as $index => $value) {
		//		$this->TOCStructureArray[$index][1] = ReTidy::trim_page_reference($this->TOCStructureArray[$index][1]);
		//	}
		//}
		$this->pageStructureArray = ReTidy::cleanPageStructureArray($this->pageStructureArray);
		$yours_sincerely_array = array(
		'Yours sincerely,',
		'La présidente,',
		'Yours truly,',
		);
		if($this->foundPage && sizeof($this->pageStructureArray) > 0 && $this->pageStructureArray !== false) {
			//$skipped_first = false;
			foreach($this->pageStructureArray as $index => $value) {
				// "yours sincerely" sections
				//if(!$skipped_first) {
				//	$skipped_first = true;
				//	continue;
				//}
				if(strlen($this->pageStructureArray[$index - 1][1]) > 0) {
					foreach($yours_sincerely_array as $yours_sincerely_text) {
						$yours_sincerely_pos = stripos($this->pageStructureArray[$index - 1][1], $yours_sincerely_text);
						//print('her33--506-5<br>');
						//print('her305005606-7-477: ');var_dump($this->pageStructureArray[$index - 1][1]);
						//print('her305005606-7-478: ');var_dump(substr($this->pageStructureArray[$index - 1][1], $yours_sincerely_pos + strlen($yours_sincerely_text)));
						//print('her305005606-7-479: ');var_dump(trim(ReTidy::tagless(substr($this->pageStructureArray[$index - 1][1], $yours_sincerely_pos + strlen($yours_sincerely_text)))));
						if($yours_sincerely_pos !== false && strlen(trim(ReTidy::tagless(substr($this->pageStructureArray[$index - 1][1], $yours_sincerely_pos + strlen($yours_sincerely_text))))) === 0) {
							$this->pageStructureArray[$index][0] = "?";
							$this->pageStructureArray[$index - 1][1] .= $this->pageStructureArray[$index][1];
							$this->pageStructureArray[$index][1] = "";
							continue;
						}
					}
				}
				$level = $value[0];
				if($this->config['trust_headings'] !== true) {
					if(is_numeric($level) || strpos($level, 'tab') === 0 || strpos($level, 'fig') === 0 || strpos($level, 'a') === 0) {
						$this->pageStructureArray[$index][1] = ReTidy::headingify($this->pageStructureArray[$index][1], $level);
					}
					/*$section_code = $value[1];
					$level_guess = $value[2];
					if(isset($level_guess) && $level_guess != "?" && $level != $level_guess) {
						// go with the level guess
						if($level_guess === 0 || $level_guess === false) {
							$this->pageStructureArray[$index] = array(
							$level_guess, 
							preg_replace('/<h' . $level . '([^<>]*?)>(.*?)<\/h' . $level . '>/is', '<p$1>$2</p>', $section_code, 1), 
							$level_guess);
						} else {
							$this->pageStructureArray[$index] = array(
							$level_guess, 
							preg_replace('/<h' . $level . '([^<>]*?)>(.*?)<\/h' . $level . '>/is', '<h' . $level_guess . '$1>$2</h' . $level_guess . '>', $section_code, 1), 
							$level_guess);
						}
					}*/
					
					if(($this->noh1 === false && ($level == 2 || $level == 3 || $level == 4 || $level == 5 || $level == 6)) ||
					($this->noh1 === true && ($level == 3 || $level == 4 || $level == 5 || $level == 6))) {
						// check if the same or one higher heading was before
						// change all subsequent headings with this problem to comply with the previous heading
						if($this->pageStructureArray[$index - 1][0] < $level && $this->pageStructureArray[$index - 1][0] != $level && $this->pageStructureArray[$index - 1][0] != $level - 1) {
							$index_counter = $index;
							while($index_counter < sizeof($this->pageStructureArray) && $this->pageStructureArray[$index_counter][0] == $level /* the initially bad one */) {
								$replace_plus = $this->pageStructureArray[$index - 1][0] + 1;
								$replace = '<h' . $replace_plus . '$1>$2</h' . $replace_plus . '>';
								$this->pageStructureArray[$index_counter] = array(
								$this->pageStructureArray[$index - 1][0] + 1, 
								preg_replace('/<h' . $this->pageStructureArray[$index_counter][0] . '([^<>]*?)>(.*?)<\/h' . $this->pageStructureArray[$index_counter][0] . '>/is', $replace, $this->pageStructureArray[$index_counter][1], 1), 
								$this->pageStructureArray[$index - 1][0] + 1);
								$index_counter++;
							}
							print("Error: The heading before this one is not the same or one higher level.<br>\r\n");
						}
					}
				} else { // adjust the levels to correspond to the heading tags
					foreach($this->pageStructureArray as $index => $value) {
						if($value[0] == "pre" || $value[0] == "post" || $value[0] == "TOC") {
						
						} elseif(preg_match('/<h([1-6])/is', $value[1], $heading_matches, PREG_OFFSET_CAPTURE) && $heading_matches[0][1] === 0) {
							$this->pageStructureArray[$index][0] = (int)$heading_matches[1][0];
						} else {
							$this->pageStructureArray[$index][0] = "?";
							$previous_numbered_heading_index = false;
							$counter = $index - 1;
							while($counter > -1) {
								if(is_numeric($this->pageStructureArray[$counter][0])) {
									$previous_numbered_heading_index = $counter;
									break;
								}
								$counter--;
							}
							$this->pageStructureArray[$previous_numbered_heading_index][1] .= '
' . $this->pageStructureArray[$index][1];
							$this->pageStructureArray[$index][1] = '';
						}
					}
				}
			}
		}
		$this->pageStructureArray = ReTidy::cleanPageStructureArray($this->pageStructureArray);
		//print("this->TOCStructureArray4443737345.5: ");var_dump($this->TOCStructureArray);
		//print("this->pageStructureArray4443737345.5: ");var_dump($this->pageStructureArray);exit(0);
		// headings with no content after them should not be headings
		$skipped_first = false;
		$size = sizeof($this->pageStructureArray);
		foreach($this->pageStructureArray as $index => $value) {
			if($value[0] == "pre" || $value[0] == "post" || $value[0] == "TOC") {
				continue;
			}
			$level = $value[0];
			if(is_numeric($level)) {
				if(!$skipped_first) {
					$skipped_first = true;
					continue;
				}
				//print('trim(ReTidy::tagless($this->pageStructureArray[$index][1])): ');var_dump(trim(ReTidy::tagless($this->pageStructureArray[$index][1])));
				//print('her39494505-060<br>');
				$length_of_content = strlen(trim(ReTidy::tagless($this->pageStructureArray[$index][1]))); // notice the tagless for template comments
				//print('$this->pageStructureArray[$index][1]: ');var_dump($this->pageStructureArray[$index][1]);
				// notice that this will not catch headings without <h#> tags
				if(preg_match('/<h([1-6])[^<>]*?>(.*?)<\/h\1>/is', $this->pageStructureArray[$index][1], $heading_matches)) {
					//print('$heading_matches[0]: ');var_dump($heading_matches[0]);
					//print('her39494505-061<br>');
					$length_of_heading = strlen(ReTidy::tagless($heading_matches[0]));
					//print('her39494505-062<br>');
					if($length_of_content === $length_of_heading) {
						$counter = $index + 1;
						while($counter < $size) {
							//print('her39494505-063<br>');
							if(strlen(trim(ReTidy::tagless($this->pageStructureArray[$counter][1]))) > 0) { // there is content after this heading
								//print('is content after<br>');
								continue 2;
							}
							//print('her39494505-064<br>');
							$counter++;
						}
						// if we get to here we say there is no content after the heading we are interested in
						//print('is no content after<br>');
						$this->pageStructureArray[$index - 1][1] .= '
' . $this->pageStructureArray[$index][1];
						$this->pageStructureArray[$index][1] = '';
						$this->pageStructureArray[$index][0] = "?";
					}/* else {
						print('$length_of_content: ');var_dump($length_of_content);
						print('$length_of_heading: ');var_dump($length_of_heading);
					}*/
				}
			}
		}
		$this->pageStructureArray = ReTidy::cleanPageStructureArray($this->pageStructureArray);
		//print('$this->pageStructureArray[8][1]: ' . $this->pageStructureArray[8][1]);
		//print("this->TOCStructureArray4443737346: ");var_dump($this->TOCStructureArray);
		//print("this->pageStructureArray4443737346: ");var_dump($this->pageStructureArray);exit(0);
		// two consecutive headings of the same level with the first not having any content
		// notice the the attributes on the second "heading" are dropped
		// currently (2011-10-27) too risky as even sweeper's heading assignment is fallible enough to assign two consecutive headings of the same level...
		// so instead make the second heading be of the next heading level
		//if($this->config['trust_headings'] !== true) {
		$skipped_first = false;
		$look_for_consecutive_headings_of_same_level = true;
		while($look_for_consecutive_headings_of_same_level) {
			$look_for_consecutive_headings_of_same_level = false;
			//$array_indices_to_combine_with_previous = array();
			foreach($this->pageStructureArray as $index => $value) {
				if(!$skipped_first) {
					$skipped_first = true;
					continue;
				}
				$level = $value[0];
				$previous_level = $this->pageStructureArray[$index - 1][0];
				//if(is_numeric($level) && $level === $previous_level) {
				if(is_numeric($level) && is_numeric($previous_level) && $level === $previous_level) { // I am completely unsure about what to do about what to do with, for example, an <h6> with no content followed by an <h4>
					$length_of_content = strlen(trim($this->pageStructureArray[$index - 1][1]));
					preg_match('/<h([1-6])[^<>]*?>(.*?)<\/h\1>/is', $this->pageStructureArray[$index - 1][1], $heading_matches);
					$length_of_heading = strlen($heading_matches[0]);
					if($length_of_content === $length_of_heading) {
						/*
						//preg_match('/<h' . $level . '[^<>]*?>(.*?)<\/h' . $level . '>(.*)/is', $this->pageStructureArray[$index][1], $second_heading_matches);
						//$second_heading_code = $second_heading_matches[1];
						//$after_second_heading_code = $second_heading_matches[2];
						//$this->pageStructureArray[$index - 1][1] = str_replace('</h' . $level . '>', '<br />' . $second_heading_code . '</h' . $level . '>' . $after_second_heading_code, $this->pageStructureArray[$index - 1][1]);
						//$this->pageStructureArray = ReTidy::array_delete($this->pageStructureArray, $index, true);
						//$look_for_consecutive_headings_of_same_level = true;
						*/
						if($level < 6) {
							$this->pageStructureArray[$index][0] = $previous_level + 1;
							$this->pageStructureArray[$index][1] = ReTidy::headingify($this->pageStructureArray[$index][1], $previous_level + 1);
						} else {
							$this->pageStructureArray[$index][0] = "?";
							$this->pageStructureArray[$index][1] = ReTidy::headingify($this->pageStructureArray[$index][1], 7);
						}
					}
				}
			}
		}
		//}
		
		//print("this->TOCStructureArray4443737347: ");var_dump($this->TOCStructureArray);
		//print("this->pageStructureArray4443737347: ");var_dump($this->pageStructureArray);
		
		if(!isset($this->config["trust_anchors"])) {
			$this->config["trust_anchors"] = false;
		}
		
		if(!$this->config["trust_anchors"] && $this->foundPage && sizeof($this->pageStructureArray) > 0 && $this->pageStructureArray !== false) {
			// should we first check if the TOC and page arrays match?
			// now do page anchors
			$h1_counter = 0;
			$first_numbered_h2_order_indicator_number_in_page = 0;
			// let's be a little smart and pick the h2_counter according to the headings in the document (instead of assuming the document is properly structured in this particular way)
			$page_h2s_found = 0;
			$found_page_order_indicator = false;
			foreach($this->pageStructureArray as $index => $value) {
				$level = $value[0];
				$section_code = $value[1];
				if($level === 2 || $level === "?") {
					//var_dump(ReTidy::get_order_indicator_type($section_code));
					$page_h2s_found++;
					$order_indicator_array = ReTidy::get_order_indicator_type($section_code);
					//print('$section_code for page h2 order determination<br>');var_dump($section_code);
					$order_indicator = $order_indicator_array[1];
					if($order_indicator !== false && $order_indicator !== NULL) {
						//print('$order_indicator_array :');var_dump($order_indicator_array);
						//print('$section_code :');var_dump($section_code);
						//print('Found a page h2 order indicator of type' . var_dump($order_indicator_array[0]) . '<br>');
						$found_page_order_indicator = true;
						//preg_match('/[0-9]+/', $order_indicator, $order_indicator_number_matches);
						//$first_numbered_h2_order_indicator_number_in_page = $order_indicator_number_matches[0];
						$first_numbered_h2_order_indicator_number_in_page = $order_indicator_array[2];
						break;
					}
				}
			}
			$TOC_h2s_found = 0;
			$found_TOC_order_indicator = false;
			$first_numbered_h2_order_indicator_number_in_page = $first_numbered_h2_order_indicator_number_in_page - $h2s_found;
			if($this->foundTOC) {
				$first_numbered_h2_order_indicator_number_in_TOC = 0;
				foreach($this->TOCStructureArray as $index => $value) {
					$level = $value[0];
					$section_code = $value[1];
					if($level === 2 || $level === "?") {
						$TOC_h2s_found++;
						$order_indicator_array = ReTidy::get_order_indicator_type($section_code);
						//print('$section_code for TOC h2 order determination<br>');var_dump($section_code);
						$order_indicator = $order_indicator_array[1];
						if($order_indicator !== false && $order_indicator !== NULL) {
							//print('Found a TOC h2 order indicator of type' . var_dump($order_indicator_array[0]) . '<br>');
							$found_TOC_order_indicator = true;
							//preg_match('/[0-9]+/', $order_indicator, $order_indicator_number_matches);
							//$first_numbered_h2_order_indicator_number_in_TOC = $order_indicator_number_matches[0];
							$first_numbered_h2_order_indicator_number_in_TOC = $order_indicator_array[2];
							break;
						}
					}
				}
			}
			if($found_TOC_order_indicator) {
				if($found_page_order_indicator) {
					//print('here9395405-06<br>');
					// use the smallest one
					if($first_numbered_h2_order_indicator_number_in_page < $first_numbered_h2_order_indicator_number_in_TOC) {
						$first_numbered_h2_order_indicator_number = $first_numbered_h2_order_indicator_number_in_page;
					} else {
						$first_numbered_h2_order_indicator_number = $first_numbered_h2_order_indicator_number_in_TOC;
					}
				} else {
					//print('here9395405-07<br>');
					$first_numbered_h2_order_indicator_number = $first_numbered_h2_order_indicator_number_in_TOC;
				}
			} else {
				if($found_page_order_indicator) {
					//print('here9395405-08<br>');
					$first_numbered_h2_order_indicator_number = $first_numbered_h2_order_indicator_number_in_page;
				} else { // make it less computerish and more humanish by starting the count at 1?
					//print('here9395405-09<br>');
					$first_numbered_h2_order_indicator_number = 1;
				}
			}
			$first_numbered_h2_order_indicator_number--; // since it is incremented every time an <h2> is come upon
			//print('first_numbered_h2_order_indicator_number_in_page: ');var_dump($first_numbered_h2_order_indicator_number_in_page);
			//print('first_numbered_h2_order_indicator_number_in_TOC: ');var_dump($first_numbered_h2_order_indicator_number_in_TOC);
			//print('first_numbered_h2_order_indicator_number: ');var_dump($first_numbered_h2_order_indicator_number);
			//$h2_counter = $first_numbered_h2_order_indicator_number - 1;
			if($found_page_order_indicator) {
				//print('here39393901<br>');
				$h2_counter = $first_numbered_h2_order_indicator_number - $page_h2s_found + 1;
			} else {
				//print('here39393902<br>');
				$h2_counter = $first_numbered_h2_order_indicator_number;
			}
			// manipulation of id h2 counter
			$h2_counter = 0;
			$h3_counter = 0;
			$h4_counter = 0;
			$h5_counter = 0;
			$h6_counter = 0;
			// we can be simplistic and only use numbers for the structure progression or we could use letters or other things...
			$headings_done_counter = 0;
			$did_TOC = false;
			$existing_id_index = 0;
			$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
			//print('existing_id_level: ');var_dump($existing_id_level);
			$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
			$existing_id_page = $this->existing_anchors_array[$existing_id_index][2];
			//print('here47495601<br>');
			foreach($this->pageStructureArray as $index => $value) {
				//print('here47495602<br>');
				//print('here3894384095<br>');
				//print('$value: ');var_dump($value);
				$level = $value[0];
				if($this->foundTOC && !$did_TOC) { // do not apply anchors to headings before the TOC; this could be configurable?
					// if it were configurable then the h2 counter for the TOC and page would have to somehow be synchronized.
					if($level === "TOC") {
						$did_TOC = true;
					}
					continue;
				}
				$section_code = $value[1];
				//$level_guess = $value[2];
				if($level == "1") {
					// do not add an anchor for the <h1>
					$new_section_code = $section_code;
					$headings_done_counter++;
				} elseif($level == "2") {
					//print('here47495603<br>');
					//print('here3894384097<br>');
					$h2_counter++;
					$h3_counter = 0;
					$h4_counter = 0;
					$h5_counter = 0;
					$h6_counter = 0;
					// remove a possibly pre-existing id
					$section_code = ReTidy::remove_preexisting_id($section_code);
					if($this->config['preserve_existing_ids'] === true && $existing_id_level === 2) {
						//print('here47495604<br>');
						$anchor = $existing_id_anchor;
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
					} else {
						//print('here47495605<br>');
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter;
					}
					$new_section_code = preg_replace('/<(\w+)([^<>]*?)>/is', '<$1 id="' . $anchor . '"$2>', $section_code, 1, $replace_count);
					if($replace_count !== 1) {
						print('<span style="color: red;">Could not create an anchor for this section: </span><br />
');
						var_dump($value);
					}
					$headings_done_counter++;
				} elseif($level == "3") {
					$h3_counter++;
					$h4_counter = 0;
					$h5_counter = 0;
					$h6_counter = 0;
					// remove a possibly pre-existing id
					$section_code = ReTidy::remove_preexisting_id($section_code);
					if($this->config['preserve_existing_ids'] === true && $existing_id_level === 3) {
						//print('here47495604-<br>');
						$anchor = $existing_id_anchor;
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
					} else {
						//print('here47495605-<br>');
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter . '_' . $h3_counter;
					}
					$new_section_code = preg_replace('/<(\w+)([^<>]*?)>/is', '<$1 id="' . $anchor . '"$2>', $section_code, 1, $replace_count);
					if($replace_count !== 1) {
						print('<span style="color: red;">Could not create an anchor for this section: </span><br />
');
						var_dump($value);
					}
					$headings_done_counter++;
				} elseif($level == "4") {
					$h4_counter++;
					$h5_counter = 0;
					$h6_counter = 0;
					// remove a possibly pre-existing id
					$section_code = ReTidy::remove_preexisting_id($section_code);
					if($this->config['preserve_existing_ids'] === true && $existing_id_level === 4) {
						$anchor = $existing_id_anchor;
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
					} else {
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter . '_' . $h3_counter . '_' . $h4_counter;
					}
					$new_section_code = preg_replace('/<(\w+)([^<>]*?)>/is', '<$1 id="' . $anchor . '"$2>', $section_code, 1, $replace_count);
					if($replace_count !== 1) {
						print('<span style="color: red;">Could not create an anchor for this section: </span><br />
');
						var_dump($value);
					}
					$headings_done_counter++;
				} elseif($level == "5") {
					$h5_counter++;
					$h6_counter = 0;
					// remove a possibly pre-existing id
					$section_code = ReTidy::remove_preexisting_id($section_code);
					if($this->config['preserve_existing_ids'] === true && $existing_id_level === 5) {
						$anchor = $existing_id_anchor;
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
					} else {
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter . '_' . $h3_counter . '_' . $h4_counter . '_' . $h5_counter;
					}
					$new_section_code = preg_replace('/<(\w+)([^<>]*?)>/is', '<$1 id="' . $anchor . '"$2>', $section_code, 1, $replace_count);
					if($replace_count !== 1) {
						print('<span style="color: red;">Could not create an anchor for this section: </span><br />
');
						var_dump($value);
					}
					$headings_done_counter++;
				} elseif($level == "6") {
					$h6_counter++;
					// remove a possibly pre-existing id
					$section_code = ReTidy::remove_preexisting_id($section_code);
					if($this->config['preserve_existing_ids'] === true && $existing_id_level === 6) {
						$anchor = $existing_id_anchor;
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
					} else {
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter . '_' . $h3_counter . '_' . $h4_counter . '_' . $h5_counter . '_' . $h6_counter;
					}
					$new_section_code = preg_replace('/<(\w+)([^<>]*?)>/is', '<$1 id="' . $anchor . '"$2>', $section_code, 1, $replace_count);
					if($replace_count !== 1) {
						print('<span style="color: red;">Could not create an anchor for this section: </span><br />
');
						var_dump($value);
					}
					$headings_done_counter++;
				} elseif(strpos($level, "tab") === 0 || strpos($level, "fig") === 0 || strpos($level, "a") === 0) {
					// remove a possibly pre-existing id
					if(strpos($section_code, "<caption>") !== false) {
						$section_code = preg_replace('/<caption([^<>]*?) id="([^"]*?)"([^<>]*?)>/is', '<caption$1$3>', $section_code);
						$new_section_code = preg_replace('/<caption([^<>]*?)>/is', '<caption id="' . $level . '"$1>', $section_code, 1, $replace_count);
					} else {
						$section_code = preg_replace('/<p([^<>]*?) id="([^"]*?)"([^<>]*?)>/is', '<p$1$3>', $section_code);
						$new_section_code = preg_replace('/<p([^<>]*?)>/is', '<p id="' . $level . '"$1>', $section_code, 1, $replace_count);
					}
					if($replace_count !== 1) {
						print('<span style="color: red;">Could not create an anchor for this section: </span><br />
');
						var_dump($value);
					}
				} elseif($level == "pre" || $level == "post" || $level == "TOC" || $level == "?" || $level === false) { // just leave it.
					$new_section_code = $section_code;
				} else {
					print('<span style="color: red;">we should not get to this part of the applying headings ids code!!! level is: ' . $level . '</span><br>
');
					// this may be a pre or a post section but in any case it does not require an anchor
					// this would be a catch-all if there were arbitrarily named levels but currently (2011-08-11) we handle all the ones we want to.
				}
				if($this->config['TOC_sub'] === 'CED' && ($level === 3 || $level === 4 || $level === 5 || $level === 6)) { // add the top of page link
					$new_section_code .= $this->CED_top_page_string;
				}
				$new_section_code = ReTidy::remove_duplicate_anchors($new_section_code);
				//print('here3894384096<br>');
				
				//print("level: ");var_dump($level);
				//print("new_section_code: ");var_dump($new_section_code);
				//print("level_guess: ");var_dump($level_guess);
				//$this->pageStructureArray[$index] = array($level, $new_section_code, $level_guess);
				$this->pageStructureArray[$index] = array($level, $new_section_code);
			}
		}
		//print("TOC structure arraaa4y: ");var_dump($this->TOCStructureArray);
		//print("page structure arraaa4y: ");var_dump($this->pageStructureArray);exit(0);
		// TOC generation (from the headings in the document)
		$this->generated_TOC = false;
		$this->pre_generation_TOC_string = "";
		if($this->config['generate_TOC'] === true || ($this->foundTOC === false && $this->config['generate_TOC'] === 'if_non_existent')) {
			$this->TOCStructureArray = array();
			if($this->language === "french") {
				$this->TOCStructureArray[] = array('pre', '<h2>Table des mati&egrave;res</h2>', 'pre');
			} else {
				$this->TOCStructureArray[] = array('pre', '<h2>Table of Contents</h2>', 'pre');
			}
			//print('$this->pageStructureArray: ');var_dump($this->pageStructureArray);
			foreach($this->pageStructureArray as $index => $value) {
				$heading = $value[1];
				if(preg_match('/<(\w+)[^<>]*?>(.*?)<\/\1>/is', $heading, $matches) === 1) {
					$level = $value[0];
					if(is_numeric($level) && $level > 1 && $level < 7 && $level <= $this->config['lowest_generated_TOC_level']) {
						$heading_text = $matches[2];
						if(!ReTidy::isAFootnote($heading_text)) {
							$trimmed_heading_text = $heading_text;
							$this->TOCStructureArray[] = array($level, $trimmed_heading_text, $level);
						}
					}
				}
			}
			//print('$this->TOCStructureArray: ');var_dump($this->TOCStructureArray);exit(0);
			// create the TOC section if needed
			$TOC_index = false;
			$this->created_TOC = false;
			foreach($this->pageStructureArray as $index => $value) {
				if($value[0] === "TOC") {
					$TOC_index = $index;
					$this->pre_generation_TOC_string = $this->pageStructureArray[$index][1];
				}
			}
			if($TOC_index === false) {
				// put it before the first heading that is not an <h1>
				$newPageStructureArray = array();
				$structure_counter = 0;
				// failing that, put it after the pre
				while($this->pageStructureArray[$structure_counter][0] === "pre") {
					$newPageStructureArray[] = $this->pageStructureArray[$structure_counter];
					$structure_counter++;
				}
				$newPageStructureArray[] = array("TOC", "", "TOC");
				while(isset($this->pageStructureArray[$structure_counter])) {
					$newPageStructureArray[] = $this->pageStructureArray[$structure_counter];
					$structure_counter++;
				}
				$this->pageStructureArray = $newPageStructureArray;
				$this->created_TOC = true;
			}
			$this->generated_TOC = true;
		}
		//print("TOC structure arraaay: ");var_dump($this->TOCStructureArray);
		//print("page structure arraaay: ");var_dump($this->pageStructureArray);exit(0);// level_guess
		// now do table of contents links (and formatting...)
		// first remove any block/containing elements
		$last_one = false;
		$in_sub_TOC_section = false;
		if($this->TOCStructureArray !== false && sizeof($this->TOCStructureArray) > 0) {
			foreach($this->TOCStructureArray as $index => $value) {
				$this->TOCStructureArray[$index][1] = OM::deblockForTOC($this->TOCStructureArray[$index][1]);
			}
			// now apply anchors and formatting
			$h1_counter = 0;
			if($found_TOC_order_indicator) {
				//print('here39393903<br>');
				$h2_counter = $first_numbered_h2_order_indicator_number - $TOC_h2s_found + 1;
			} else {
				//print('here39393904<br>');
				$h2_counter = $first_numbered_h2_order_indicator_number;
			}
			// manipulation of TOC h2 counter
			$h2_counter = 0;
			$h3_counter = 0;
			$h4_counter = 0;
			$h5_counter = 0;
			$h6_counter = 0;
			$existing_id_index = 0;
			$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
			//print('existing_id_level: ');var_dump($existing_id_level);
			$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
			$existing_id_page = $this->existing_anchors_array[$existing_id_index][2];
			//var_dump($this->existing_anchors_array);exit(0);
			// we can be simplistic and only use numbers for the structure progression of we could use letters or other things...
			// notice that the indentation formatting is simplistic but it may never be used since indentation is not accessible...
			$previous_level = false;
			foreach($this->TOCStructureArray as $index => $value) {
				$level = $value[0];
				$section_code = $value[1];
				//$level_guess = $value[2];
				//print("section_code: ");var_dump($section_code);
				if($level == "1") {
					// do not add an anchor for the <h1>
					$new_section_code = $section_code;
				} elseif($level == "2") {
					$h2_counter++;
					$h3_counter = 0;
					$h4_counter = 0;
					$h5_counter = 0;
					$h6_counter = 0;
					if($this->config['preserve_existing_ids'] === true) {
						//print('here47495606<br>');
						$anchor = $existing_id_page . '#' . $existing_id_anchor;
					} else {
						//print('here47495607<br>');
						// check if there is a page (as well as anchor) link
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter;
						if(isset($existing_id_page)) {
							//print('$existing_id_page: ');var_dump($existing_id_page);
							//print('$anchor: ');var_dump($anchor);
							$anchor = $existing_id_page . '#' . $anchor;
						} else {
							$anchor = '#' . $anchor;
						}
					}
					if($existing_id_level === 2) {
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
						$existing_id_page = $this->existing_anchors_array[$existing_id_index][2];
					}
					/*if($this->config['TOC_sub'] === 'CED') {
						$section_code = ReTidy::trim_nbsp(ReTidy::remove_tags($section_code, "strong"));
						$pos = strpos($section_code, " ");
						if($pos === false || $pos === 0) {
							$after_order_indicator = $section_code;
							$new_section_code = '<div class="row-list indent1">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
						} else {
							$order_indicator = substr($section_code, 0, $pos);
							if(!ReTidy::isOrderIndicator($order_indicator)) {
								$after_order_indicator = $section_code;
								$new_section_code = '<div class="row-list indent1">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							} else {
							$after_order_indicator = substr($section_code, $pos + 1);
							$new_section_code = '<div class="row-list indent1">
<div class="numero-list">' . $order_indicator . '</div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							}
						}
					}*/
					if($this->config['TOC_sub'] === 'indent') {
						$new_section_code = '<p><a href="' . $anchor . '">' . $section_code . '</a></p>';
					} else {
					//if($this->config['TOC_sub'] === 'lists') {
						$new_section_code = '<a href="' . $anchor . '">' . $section_code . '</a>';
					}
				} elseif($level == "3") {
					$h3_counter++;
					$h4_counter = 0;
					$h5_counter = 0;
					$h6_counter = 0;
					if($this->config['preserve_existing_ids'] === true) {
						$anchor = $existing_id_page . '#' . $existing_id_anchor;
					} else {
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter . '_' . $h3_counter;
						if(isset($existing_id_page)) {
							$anchor = $existing_id_page . '#' . $anchor;
						} else {
							$anchor = '#' . $anchor;
						}
					}
					if($existing_id_level === 3) {
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
						$existing_id_page = $this->existing_anchors_array[$existing_id_index][2];
					}
					/*if($this->config['TOC_sub'] === 'CED') {
						$section_code = ReTidy::trim_nbsp(ReTidy::remove_tags($section_code, "strong"));
						$pos = strpos($section_code, " ");
						if($pos === false || $pos === 0) {
							$after_order_indicator = $section_code;
							$new_section_code = '<div class="row-list indent2">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
						} else {
							$order_indicator = substr($section_code, 0, $pos);
							if(!ReTidy::isOrderIndicator($order_indicator)) {
								$after_order_indicator = $section_code;
								$new_section_code = '<div class="row-list indent2">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							} else {
							$after_order_indicator = substr($section_code, $pos + 1);
							$new_section_code = '<div class="row-list indent2">
<div class="numero-list">' . $order_indicator . '</div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							}
						}
					}*/
					if($this->config['TOC_sub'] === 'indent') {
						$new_section_code = '<p class="indent1"><a href="' . $anchor . '">' . $section_code . '</a></p>';
					} else {
					//if($this->config['TOC_sub'] === 'lists') {
						$new_section_code = '<a href="' . $anchor . '">' . $section_code . '</a>';
					}
				} elseif($level == "4") {
					$h4_counter++;
					$h5_counter = 0;
					$h6_counter = 0;
					if($this->config['preserve_existing_ids'] === true) {
						$anchor = $existing_id_page . '#' . $existing_id_anchor;
					} else {
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter . '_' . $h3_counter . '_' . $h4_counter;
						if(isset($existing_id_page)) {
							$anchor = $existing_id_page . '#' . $anchor;
						} else {
							$anchor = '#' . $anchor;
						}
					}
					if($existing_id_level === 4) {
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
						$existing_id_page = $this->existing_anchors_array[$existing_id_index][2];
					}
					/*if($this->config['TOC_sub'] === 'CED') {
						$section_code = ReTidy::trim_nbsp(ReTidy::remove_tags($section_code, "strong"));
						$pos = strpos($section_code, " ");
						if($pos === false || $pos === 0) {
							$after_order_indicator = $section_code;
							$new_section_code = '<div class="row-list indent3">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
						} else {
							$order_indicator = substr($section_code, 0, $pos);
							if(!ReTidy::isOrderIndicator($order_indicator)) {
								$after_order_indicator = $section_code;
								$new_section_code = '<div class="row-list indent3">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							} else {
							$after_order_indicator = substr($section_code, $pos + 1);
							$new_section_code = '<div class="row-list indent3">
<div class="numero-list">' . $order_indicator . '</div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							}
						}
					}*/
					if($this->config['TOC_sub'] === 'indent') {
						$new_section_code = '<p class="indent2"><a href="' . $anchor . '">' . $section_code . '</a></p>';
					} else {
					//if($this->config['TOC_sub'] === 'lists') {
						$new_section_code = '<a href="' . $anchor . '">' . $section_code . '</a>';
					}
				} elseif($level == "5") {
					$h5_counter++;
					$h6_counter = 0;
					if($this->config['preserve_existing_ids'] === true) {
						$anchor = $existing_id_page . '#' . $existing_id_anchor;
					} else {
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter . '_' . $h3_counter . '_' . $h4_counter . '_' . $h5_counter;
						if(isset($existing_id_page)) {
							$anchor = $existing_id_page . '#' . $anchor;
						} else {
							$anchor = '#' . $anchor;
						}
					}
					if($existing_id_level === 5) {
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
						$existing_id_page = $this->existing_anchors_array[$existing_id_index][2];
					}
					/*if($this->config['TOC_sub'] === 'CED') {
						$section_code = ReTidy::trim_nbsp(ReTidy::remove_tags($section_code, "strong"));
						$pos = strpos($section_code, " ");
						if($pos === false || $pos === 0) {
							$after_order_indicator = $section_code;
							$new_section_code = '<div class="row-list indent4">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
						} else {
							$order_indicator = substr($section_code, 0, $pos);
							if(!ReTidy::isOrderIndicator($order_indicator)) {
								$after_order_indicator = $section_code;
								$new_section_code = '<div class="row-list indent4">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							} else {
							$after_order_indicator = substr($section_code, $pos + 1);
							$new_section_code = '<div class="row-list indent4">
<div class="numero-list">' . $order_indicator . '</div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							}
						}
					}*/
					if($this->config['TOC_sub'] === 'indent') {
						$new_section_code = '<p class="indent3"><a href="' . $anchor . '">' . $section_code . '</a></p>';
					} else {
					//if($this->config['TOC_sub'] === 'lists') {
						$new_section_code = '<a href="' . $anchor . '">' . $section_code . '</a>';
					}
				} elseif($level == "6") {
					$h6_counter++;
					if($this->config['preserve_existing_ids'] === true) {
						$anchor = $existing_id_page . '#' . $existing_id_anchor;
					} else {
						$anchor = $this->config["anchor_text"] . '_' . $h2_counter . '_' . $h3_counter . '_' . $h4_counter . '_' . $h5_counter . '_' . $h6_counter;
						if(isset($existing_id_page)) {
							$anchor = $existing_id_page . '#' . $anchor;
						} else {
							$anchor = '#' . $anchor;
						}
					}
					if($existing_id_level === 6) {
						$existing_id_index++;
						$existing_id_level = $this->existing_anchors_array[$existing_id_index][0];
						$existing_id_anchor = $this->existing_anchors_array[$existing_id_index][1];
						$existing_id_page = $this->existing_anchors_array[$existing_id_index][2];
					}
					// not accessible
					/*if($this->config['TOC_sub'] === 'CED') {
						$section_code = ReTidy::trim_nbsp(ReTidy::remove_tags($section_code, "strong"));
						$pos = strpos($section_code, " ");
						if($pos === false || $pos === 0) {
							$after_order_indicator = $section_code;
							$new_section_code = '<div class="row-list indent5">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
						} else {
							$order_indicator = substr($section_code, 0, $pos);
							if(!ReTidy::isOrderIndicator($order_indicator)) {
								$after_order_indicator = $section_code;
								$new_section_code = '<div class="row-list indent5">
<div class="numero-list"></div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							} else {
							$after_order_indicator = substr($section_code, $pos + 1);
							$new_section_code = '<div class="row-list indent5">
<div class="numero-list">' . $order_indicator . '</div>
<div class="text-list menu"><a href="' . $anchor . '">' . $after_order_indicator . '</a></div>
</div>';
							}
						}
					}*/
					if($this->config['TOC_sub'] === 'indent') {
						$new_section_code = '<p class="indent4"><a href="' . $anchor . '">' . $section_code . '</a></p>';
					} else {
					//if($this->config['TOC_sub'] === 'lists') {
						$new_section_code = '<a href="' . $anchor . '">' . $section_code . '</a>';
					}
				} elseif($level == "pre") {
					// h2ify it; (should we always do this???)
					$new_section_code = '<h2>' . $section_code . '</h2>';
				} elseif($level == "?") {
					// table of contents "sub-headings"
					$new_section_code = '<h3>' . $section_code . '</h3>';
				} elseif(strpos($level, "tab") === 0 || strpos($level, "fig") === 0 || strpos($level, "a") === 0) {
					$h2_counter++;
					$h3_counter = 0;
					$h4_counter = 0;
					$h5_counter = 0;
					$h6_counter = 0;
					// this is not accessible
					/*if($this->config['TOC_sub'] === 'CED') {
						$section_code = ReTidy::trim_nbsp(ReTidy::remove_tags($section_code, "strong"));
						$pos = strpos($section_code, " ");
						if($pos === false || $pos === 0) {
							$after_order_indicator = $section_code;
							$new_section_code = '<div class="row-list indent1">
<div class="numero-list"></div>
<div class="text-list menu"><a href="#' . $level . '">' . $after_order_indicator . '</a></div>
</div>';
						} else {
							$order_indicator = substr($section_code, 0, $pos);
							if(!ReTidy::isOrderIndicator($order_indicator)) {
								$after_order_indicator = $section_code;
								$new_section_code = '<div class="row-list indent1">
<div class="numero-list"></div>
<div class="text-list menu"><a href="#' . $level . '">' . $after_order_indicator . '</a></div>
</div>';
							} else {
								$after_order_indicator = substr($section_code, $pos + 1);
								$new_section_code = '<div class="row-list indent1">
<div class="numero-list">' . $order_indicator . '</div>
<div class="text-list menu"><a href="#' . $level . '">' . $after_order_indicator . '</a></div>
</div>';
							}
						}
					}*/
					if($this->config['TOC_sub'] === 'indent') {
						$new_section_code = '<p><a href="#' . $level . '">' . $section_code . '</a></p>';
					} else { // default
					//if($this->config['TOC_sub'] === 'lists') {
						$new_section_code = '<a href="#' . $level . '">' . $section_code . '</a>';
					}
				} else {
					print('<span style="color: red;">we should not get to this part of the applying TOC links code!!!</span><br>
');
					// this may be a pre or a post section but in any case it does not require a link
				}
				//if($this->config['TOC_sub'] === 'lists') {
				if($this->config['TOC_sub'] !== 'indent') {
					if($level === 1 || $level === "pre") {
						// do not put a <li> tag on the <h1>
					} elseif(strpos($new_section_code, "<h3") === 0) {
						if($previous_level !== "pre") {
							$new_section_code = '</ul>
' . $new_section_code;
							while($previous_level > 2) {
								$new_section_code = '</li>
</ul>' . $new_section_code;
								$previous_level--;
							}
						}
					} elseif(strpos($level, "tab") === 0 || strpos($level, "fig") === 0 || strpos($level, "a") === 0) {
						// this probably does not account for many sub-TOCs
						if(isset($this->TOCStructureArray[$index + 1][0]) && $this->TOCStructureArray[$index + 1][0] != "post") {
							if(!$in_sub_TOC_section) {
								$new_section_code = '<ul>
<li>' . $new_section_code . '</li>';
							} else {
								$new_section_code = '<li>' . $new_section_code . '</li>';
							}
							$in_sub_TOC_section = true;
						} else { // the last one
							$new_section_code = '<li>' . $new_section_code . '</li>
</ul>';
						}
					} elseif($previous_level === false) {
						$new_section_code = '<ul>
<li>' . $new_section_code;
					} else {
						if($previous_level < $level) {
							$new_section_code = '<ul>
<li>' . $new_section_code;
						} else {
							$new_section_code = '<li>' . $new_section_code;
						}
						if(is_numeric($level)) {
							if(isset($this->TOCStructureArray[$index + 1][0]) && $this->TOCStructureArray[$index + 1][0] != "post") {
								$next_level = $this->TOCStructureArray[$index + 1][0];
							} else { // the last one
								$new_section_code .= '</li>';
								while($level > 2) {
									$new_section_code .= '
</ul>
</li>';
									$level--;
								}
								// </ul> for the table of contents
								$new_section_code .= '
</ul>';
								$last_one = true;
							}
							if(!$last_one) {
								if(is_numeric($next_level)) {
									if($level > $next_level) {
										$new_section_code .= '</li>';
										while($level > $next_level) {
											$new_section_code .= '
</ul>
</li>';
											$next_level++;
										}
									} elseif($level < $next_level) {

									} else {
										$new_section_code .= '</li>';
									}
								} else {
									$new_section_code .= '</li>';
								}
							}
						} else {
							// do we need this else? apparently yes; for ? (levelless sections) (that aren't sub-TOCs)
							//if($in_sub_TOC_section && $level === "?") {
							//	$new_section_code .= '</li>
//</ul>';
							//	$in_sub_TOC_section = false;
							//} else {
								$new_section_code .= '</li>';
							//}
						}
					}
					$previous_level = $level;
				}
				//$this->TOCStructureArray[$index] = array($level, $new_section_code, $level_guess);
				$this->TOCStructureArray[$index] = array($level, $new_section_code);
			}
		}
		//print("TOC structure arraay: ");var_dump($this->TOCStructureArray);exit(0);
		//print("page structure arraay: ");var_dump($this->pageStructureArray);exit(0);//tagless
		// Make headings text the appropriate case if it is not being done for all indexical content of the document.
		if($this->config["normalize_heading_text"] === 'headings') {
			ReTidy::words_init();
			$this->headings_normalized = 0;
			if($this->foundPage) {
				foreach($this->pageStructureArray as $index => $value) {
					$level = $value[0];
					if(is_numeric($level)) {
						$heading = $value[1];
						//print('heading: ');var_dump($heading);
						if(preg_match('/<(\w+)[^<>]*?>(.*?)<\/\1>/is', $heading, $matches) === 1) {
							$initial_heading_text = $matches[2];
							$normalized_heading_text = $initial_heading_text;
							$normalized_heading_text = ReTidy::normalize_heading($normalized_heading_text);
							$this->pageStructureArray[$index][1] = ReTidy::str_replace_first($initial_heading_text, $normalized_heading_text, $heading);
						}
					}
				}
			}
			if($this->foundTOC) {
				foreach($this->TOCStructureArray as $index => $value) {
					$level = $value[0];
					if(is_numeric($level)) {
						$heading = $value[1];
						if(preg_match('/<(\w+)[^<>]*?>(.*?)<\/\1>/is', $heading, $matches) === 1) {
							$initial_heading_text = $matches[2];
							$normalized_heading_text = $initial_heading_text;
							$normalized_heading_text = ReTidy::normalize_heading($normalized_heading_text);
							$this->TOCStructureArray[$index][1] = ReTidy::str_replace_first($initial_heading_text, $normalized_heading_text, $heading);
						}
					}
				}
			}
			$this->logMsgIf("headings normalized", $this->headings_normalized);
		}
		$this->logMsgIf("headings done", $headings_done_counter);
		return true;
	}
	
	function normalize_all_indexical_content($content_only = false) {
		// we are not changing heading levels so we are not assigning trust of headings in that sense, but rather in whether they should be all
		// capitalized; in other words, do not trust that about them.
		$initial_trust_headings = $this->config['trust_headings'];
		$this->config['trust_headings'] = false;
		$this->findingTOC = true;
		ReTidy::words_init();
		$this->headings_normalized = 0;
		if($content_only) {
			$initial_code = $this->code;
			$contentArray = ReTidy::getContentArray($this->code);
			$content = $contentArray[0];
			$strpos = strpos($this->code, $content);
			$pre_content = substr($this->code, 0, $strpos);
			$post_content = substr($this->code, $strpos + strlen($content));
			$this->code = $content;
		}
		//$allTags = OM::getAllTags($this->code);
		// any inline tags may be indexical by ignoring their heredity...
		$allTags = OM::getAllBlockOStrings_for_normalize_indexical_content($this->code);
		//print('all tags: ');var_dump($allTags);
		foreach($allTags as $tagStringValue) {
			$tagString = $tagStringValue[0];
			//print('tagString: ');var_dump($tagString);
			if(ReTidy::isIndexical($tagString)) {
				//print('ReTidy::normalize_heading(tagString): ');var_dump(ReTidy::normalize_heading($tagString));
				$this->code = ReTidy::str_replace_first($tagString, ReTidy::normalize_heading($tagString), $this->code);
			}// else {
			//	print('not indexical<br>');
			//}
		}
		if($content_only) {
			$this->code = $pre_content . $this->code . $post_content;
		}
		$this->findingTOC = false;
		$this->logMsgIf("headings normalized", $this->headings_normalized);
		$this->config['trust_headings'] = $initial_trust_headings;
	}
	
	function trim_replace_intra_word_characters_with_spaces($string) {
		//print('pre: ');var_dump($string);
		$string = preg_replace('/&quot;|&apos;|&laquo;|&raquo;|&lsquo;|&rsquo;|&sbquo;|&ldquo;|&rdquo;|&bdquo;|&lsaquo;|&rsaquo;/is', ' ', $string);
		//print('one: ');var_dump($string);
		//$string = mb_ereg_replace('[,~`!\(\)\-=\+\{\}\[\]\\\|:"\'<>\.\?\/"«»‘’‚“”„‹›]', ' ', $string);
		//$string = mb_ereg_replace('[,~`!\(\)\-=\+\{\}\[\]\\\|:"\'<>\.\?\/"«»‘’‚“”„]', ' ', $string); // why the two single guillemets should matter; I can't imagine
		$string = preg_replace('/[,~`!\(\)\-=\+\{\}\[\]\\\|:"\'<>\.\?\/"«»‘’‚“”„]/is', ' ', $string);
		//print('two: ');var_dump($string);
		$string = preg_replace('/\s+/is', ' ', $string);
		//print('three: ');var_dump($string);
		$string = trim($string);
		//print('post: ');var_dump($string);
		return $string;
	}
	
	function get_heading_word_pieces($string) {
		$string_array = array($string);
		$breakCharactersArray = array(',', '~', '`', '!', '(', ')', '-', '=', '+', '{', '}', '[', ']', '\\', '|', ':', ';', '"', '\'', '<', '>', '.', '?', '/', '"', '«', '»', '‘', '’', '‚', '“', '”', '„', '‹', '›');
		foreach($breakCharactersArray as $breakCharacter) {
			$found_one = false;
			$new_array = array();
			foreach($string_array as $string_piece) {
				if(strpos($string_piece, $breakCharacter) !== false) {
					$found_one = true;
					$explodeds = explode($breakCharacter, $string_piece);
					foreach($explodeds as $exploded) {
						$new_array[] = $exploded;
					}
				}
			}
			if($found_one) {
				$string_array = $new_array;
			}
		}
		return $string_array;
	}
	
	function remove_entities($string) {
		return preg_replace('/&[^&;]+;/is', '', $string);
	}
	
	function remove_entities_and_french_characters($string) {
		$string = preg_replace('/&[^&;]+;/is', '', $string);
		//$string = preg_replace('/[ŒÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝ]/is', '', utf8_encode($string));
		$string = preg_replace('/[ŒÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝ]/is', '', $string);
		return $string;
	}
	
	function isOrderIndicator($string) {
		preg_match('/' . $this->order_indicator_regex_with_complex_number_without_space . '/is', $string, $matches);
		return ($string === $matches[1]);
	}
	
	function normalize_heading($string) {
		$initial_string = $string;
		//print('string: ');var_dump($string);
		// french (and maybe some other) lowercase characters: œàáâãäåæçèéêëìíîïðñòóôõöøùúûüý
		// french (and maybe some other) uppercase characters: ŒÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝ
		
		// notice that mb_strtolower is currently (2011-11-11) only used for french; this may need to be rectified
		
		$tagless = trim(ReTidy::space_to_whitespace_nbsp(ReTidy::tagless($string)));
		$tagless = html_entity_decode($tagless);
		if(preg_match('/[a-z]/is', $tagless) === 1) {
			$tagless = ReTidy::remove_entities_and_french_characters($tagless); // aggresive but works?
			$tagless = html_entity_decode($tagless);
			//$tagless = utf8_decode($tagless);
			$tagless = ReTidy::trim_replace_intra_word_characters_with_spaces($tagless);
			$heading_words = explode(" ", $tagless);
			// first check that all the words are uppercase as a criterion for normalizing them
			//print('her4859506<br>');
			$all_uppercase = true;
			foreach($heading_words as $heading_word) {
				//print('$heading_word: ');var_dump($heading_word);
				//print('her4859507<br>');
				$heading_word = html_entity_decode($heading_word);
				if(preg_match('/[a-z]/is', $heading_word) === 1) { // to avoid things like dashes and colons
					//print('her4859508<br>');
					// allow the order indicators
					if(preg_match('/[\(\{\[]{0,3}[a-z0-9]{1,3}[\)\}\]\.:-]{1,3}/is', $heading_word) === 1) {
						//print('her4859509<br>');
						continue;
					}
					if(preg_match('/[a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]/s', $heading_word, $lowercase_matches) === 0) { // no lowercase letters found in this word
						//print('her4859510<br>');
					} else {
						//print('her4859511<br>');
						//print('$lowercase_matches: ');var_dump($lowercase_matches);
						$all_uppercase = false;
						break;
					}
				}
			}
			if($all_uppercase) {
				//print('normalizing...<br>');
				$tagless = trim(ReTidy::space_to_whitespace_nbsp(ReTidy::tagless($string)));
				$tagless = ReTidy::trim_replace_intra_word_characters_with_spaces($tagless);
				$heading_words = explode(" ", $tagless);
				$offset = 0;
				if($this->language === "french") {
					
					// because even if the first word is a stop word, we still want to have the first letter uppercase 
					$did_first = false;
					foreach($heading_words as $heading_words_index => $heading_word) {
						//print('heading_word: ');var_dump($heading_word);
						//$lowered_heading_word = utf8_encode(mb_strtolower($heading_word));
						$lowered_heading_word = mb_strtolower($heading_word);
						//print('lowered_heading_word: ');var_dump($lowered_heading_word);
						if(!$did_first) {
							if(strlen($lowered_heading_word) === 1) {
								// hmm, french seems to have quite a few letters used in contractions
								if($lowered_heading_word == 'c' ||
								$lowered_heading_word == 'd' ||
								$lowered_heading_word == 'j' ||
								$lowered_heading_word == 'l' ||
								$lowered_heading_word == 'm' ||
								$lowered_heading_word == 'n' ||
								$lowered_heading_word == 'q' ||
								$lowered_heading_word == 's' ||
								$lowered_heading_word == 't'
								) {
									$new_offset = ReTidy::strpos_whole_word($string, $heading_word, $offset) + 1;
									$string = ReTidy::str_replace_first_whole_word($heading_word, $heading_word, $string, $offset);
									$offset = $new_offset;
									$did_first = true;
									continue;
								}
							}
							foreach($this->words_array as $word) {
								if($word === $lowered_heading_word) {
									$new_offset = ReTidy::strpos_whole_word($string, $heading_word, $offset) + 1;
									$string = ReTidy::str_replace_first_whole_word($heading_word, $heading_word[0] . mb_strtolower(substr($heading_word, 1)), $string, $offset);
									$offset = $new_offset;
									$did_first = true;
									continue 2;
								}
							}
						} else {
							if(strlen($lowered_heading_word) === 1) {
								// hmm, french seems to have quite a few letters used in contractions
								if($lowered_heading_word == 'c' ||
								$lowered_heading_word == 'd' ||
								$lowered_heading_word == 'j' ||
								$lowered_heading_word == 'l' ||
								$lowered_heading_word == 'm' ||
								$lowered_heading_word == 'n' ||
								$lowered_heading_word == 'q' ||
								$lowered_heading_word == 's' ||
								$lowered_heading_word == 't'
								) {
									if(substr($heading_words[$heading_words_index - 1], 0, 7) === "APPENDI" ||
									substr($heading_words[$heading_words_index - 1], 0, 5) === "ANNEX" ||
									substr($heading_words[$heading_words_index - 1], 0, 5) === "TABLE" ||
									$heading_words[$heading_words_index - 1] === "SECTION"
									) {
										continue;
									} else {
										$new_offset = ReTidy::strpos_whole_word($string, $heading_word, $offset) + 1;
										//print('string 1:');var_dump($string);
										$string = ReTidy::str_replace_first_whole_word($heading_word, mb_strtolower($heading_word), $string, $offset);
										//print('string 1 post:');var_dump($string);
										$offset = $new_offset;
										continue;
									}
								}
							}
							foreach($this->words_array as $word) {
								if($word === $lowered_heading_word) {
									$new_offset = ReTidy::strpos_whole_word($string, $heading_word, $offset) + 1;
									//print('mb_strtolower(heading_word): ');var_dump(mb_strtolower($heading_word));
									//print('string 2:');var_dump($string);
									$string = ReTidy::str_replace_first_whole_word($heading_word, mb_strtolower($heading_word), $string, $offset);
									//print('string 2 post:');var_dump($string);
									$offset = $new_offset;
									continue 2;
								}
							}
						}
					}
					// here is a meagre attempt to reconcile the nonsense of some things like names of people and places
					// taking uppercase first letters while the general pattern is to not in french.
					// It is far from exhaustive...
					foreach($this->french_headings_normalization_exceptions as $search => $replace) {
						$string = str_replace($search, $replace, $string);
					}
				} else {
					// because even if the first word is a stop word, we still want to have the first letter uppercase 
					$did_first = false;
					foreach($heading_words as $heading_words_index => $heading_word) {
						//$lowered_heading_word = utf8_encode(mb_strtolower($heading_word));
						$lowered_heading_word = mb_strtolower($heading_word);
						if($did_first) {
							foreach($this->stop_words_array as $stop_word) {
								if($stop_word === $lowered_heading_word) {
									// A very specific exception... should we also go to the trouble of hyphenated words which part of is the letter a ?!?
									if($lowered_heading_word === "a" && (
									substr($heading_words[$heading_words_index - 1], 0, 7) === "APPENDI" ||
									substr($heading_words[$heading_words_index - 1], 0, 5) === "ANNEX" ||
									substr($heading_words[$heading_words_index - 1], 0, 5) === "TABLE" ||
									$heading_words[$heading_words_index - 1] === "SECTION"
									)) {
										continue 2;
									} else {
										$new_offset = ReTidy::strpos_whole_word($string, $heading_word, $offset) + 1;
										//print('string 3:');var_dump($string);
										$string = ReTidy::str_replace_first_whole_word($heading_word, mb_strtolower($heading_word), $string, $offset);
										//print('string 3 post:');var_dump($string);
										$offset = $new_offset;
										//$string = ReTidy::str_replace_whole_word($heading_word, mb_strtolower($heading_word), $string);
										continue 2;
									}
								}
							}
						} else {
							$did_first = true;
						}
						foreach($this->words_array as $word) {
							if($word === $lowered_heading_word) {
								$new_offset = ReTidy::strpos_whole_word($string, $heading_word, $offset) + 1;
								//print('string 4:');var_dump($string);
								$string = ReTidy::str_replace_first_whole_word($heading_word, $heading_word[0] . mb_strtolower(substr($heading_word, 1)), $string, $offset);
								//print('string 4 post:');var_dump($string);
								$offset = $new_offset;
								//$string = ReTidy::str_replace_whole_word($heading_word, mb_strtolower($heading_word), $string);
								continue 2;
							}
						}
					}
					$string = preg_replace('/($apos;|&rsquo;|&#8217;)S/s', '$1s', $string); // for apostraphe s
				}
			}
		}
		// all this encoding and decoding is really problematic...
		//$string = htmlentities($string);
		//$string = htmlspecialchars_decode($string);
		//print('end of heading normalization string: ');var_dump($string);
		if($initial_string != $string) {
			$this->headings_normalized++;
		}
		return $string;
	}
	
	function space_to_whitespace($string) {
		$string = preg_replace('/\s+/is', ' ', $string);
		return $string;
	}
	
	function space_to_whitespace_nbsp($string) {
		$string = str_replace('&nbsp;', ' ', $string);
		$string = str_replace('&#160;', ' ', $string);
		$string = str_replace('&#xa0;', ' ', $string);
		$string = preg_replace('/\s+/is', ' ', $string);
		return $string;
	}
	
	function strip_space($string) {
		$string = preg_replace('/\s+/is', '', $string);
		return $string;
	}
	
	function strip_space_nbsp($string) {
		$string = preg_replace('/\s+/is', '', $string);
		$string = str_replace('&nbsp;', '', $string);
		$string = str_replace('&#160;', '', $string);
		$string = str_replace('&#xa0;', '', $string);
		$string = str_replace('&#xA0;', '', $string);
		return $string;
	}
	
	function add_BOM() {
		$this->code = chr(0xEF) . chr(0xBB) . chr(0xBF) . $this->code;
	}
	
	function post_update_to_WET4() {
		$this->code = preg_replace('/<aside([^<>]*?)>(.*?)<\/aside>\s*<\/section>/is', '</section>
<aside$1>$2</aside>', $this->code);
	}
	
	function undo_SIRC_CSS() {
		$class_replaces = array(
		'annual-report-recommendation' => 'well',
		'annual-report-2014-box' => '', // they all already have the well class
		'space-bottom' => '',
		'whiteBG' => '',
		'blue-italic' => '',
		'uppercase' => 'text-uppercase',
		'noIndent' => 'mrgn-lft-0',
		//'normalize' => '',
		'borderBottom' => 'brdr-bttm',
		//'borderBottomDouble' => 'brdr-bttm',
		'borderTopBottom' => 'brdr-top brdr-bttm',
		//.archived
		'margin-left-none' => 'mrgn-lft-0',
		'margin-left-small' => 'mrgn-lft-sm',
		'margin-left-medium' => 'mrgn-lft-md',
		'margin-left-large' => 'mrgn-lft-lg',
		'margin-left-xlarge' => 'mrgn-lft-xl',
		'margin-bottom-none' => 'mrgn-bttm-0',
		'margin-bottom-small' => 'mrgn-bttm-sm',
		'margin-bottom-medium' => 'mrgn-bttm-md',
		'margin-bottom-large' => 'mrgn-bttm-lg',
		'margin-bottom-xlarge' => 'mrgn-bttm-xl',
		'margin-top-none' => 'mrgn-tp-0',
		'margin-top-small' => 'mrgn-tp-sm',
		'margin-top-medium' => 'mrgn-tp-md',
		'margin-top-large' => 'mrgn-tp-lg',
		'margin-top-xlarge' => 'mrgn-tp-xl',
		'margin-right-none' => 'mrgn-rght-0',
		'margin-right-small' => 'mrgn-rght-sm',
		'margin-right-medium' => 'mrgn-rght-md',
		'margin-right-large' => 'mrgn-rght-lg',
		'margin-right-xlarge' => 'mrgn-rght-xl',
		// home page manually
		//.module
		'width33' => '',
		'width34' => '',
		//.whiteBG
		//.image-left
		//.image-right
		//.image-left-margin
		//.image-right-margin
		// ignore endnote stuff and fix it when joining pages
		'align-top' => 'media-body',
		'align-middle' => 'media-middle',
		'align-bottom' => 'media-bottom',
		);
		foreach($class_replaces as $search => $replace) {
			$this->code = preg_replace('/ class="([^"]*?)' . $search . '([^"]*?)"/is', ' class="$1' . $replace . '$2"', $this->code, -1, $count);
			$this->logMsgIf($search, $count);
		}
		$array_preg_replaces = array(
		'<(\w+)([^<>]*?) class="image-left-margin"([^<>]*?)>\s*<img' => '<$1$2$3><img class="media-left pull-left"',
		'<(\w+)([^<>]*?) class="image-right-margin"([^<>]*?)>\s*<img' => '<$1$2$3><img class="media-right pull-right"',
		'<(\w+)([^<>]*?) class="image-left"([^<>]*?)>\s*<img' => '<$1$2$3><img class="media-left pull-left"',
		'<(\w+)([^<>]*?) class="image-right"([^<>]*?)>\s*<img' => '<$1$2$3><img class="media-right pull-right"',
		//'<div([^<>]*?) id="archived"([^<>]*?)>' => '<div$1 class="alert alert-danger"$2>',
		' class="([^"]*?)normalize([^"]*?)"' => ' class="$1$2" style="font-weight: normal; font-style: normal; background: #FFFFFF;"',
		' class="([^"]*?)redacted([^"]*?)"' => ' class="$1$2" style="background-color: #000; color: #000;"',
		//' class="([^"]*?)annual-report-signature([^"]*?)"' => ' class="$1$2" style="font-weight: normal; font-style: normal; background: #FFFFFF;"',
		//' class="([^"]*?)annual-report-member-photo1([^"]*?)"' => ' class="$1$2" style="font-weight: normal; font-style: normal; background: #FFFFFF;"',
		//' class="([^"]*?)annual-report-member-photo2([^"]*?)"' => ' class="$1$2" style="font-weight: normal; font-style: normal; background: #FFFFFF;"',
		//' class="([^"]*?)align-top([^"]*?)"' => ' class="$1$2" style="vertical-align: top;"',
		//' class="([^"]*?)align-middle([^"]*?)"' => ' class="$1$2" style="vertical-align: middle;"',
		//' class="([^"]*?)align-bottom([^"]*?)"' => ' class="$1$2" style="vertical-align: bottom;"',
		' class="webFeedLinkLeft"([^<>]*?)><a ' => '$1><a style="background: url(/images/feed-fil/feed-fil-14x14.png) center left no-repeat !important; padding-left: 16px;" ',
		' class="webFeedLinkRight"([^<>]*?)><a ' => '$1><a style="background: url(/images/feed-fil/feed-fil-14x14.png) center right no-repeat !important; padding-right: 16px;" ',
		);
		foreach($array_preg_replaces as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $count);
			$this->logMsgIf(htmlentities($search), $count);
		}
		
		// check that there are none left
		$checking_array = array(
		'annual-report-recommendation',
		'inconspicuous',
		'space-bottom',
		'space-top',
		'uppercase',
		'normalize',
		'redacted',
		'annual-report-signature',
		'annual-report-member-photo1',
		'annual-report-member-photo2',
		'noIndent',
		'width33',
		'width34',
		'blackborder',
		'black',
		'white',
		'red',
		'blue',
		'green',
		'grey',
		'container',
		//'row',
		'margin-bottom-none',
		'margin-bottom-small',
		'margin-bottom-medium',
		'margin-bottom-large',
		'margin-bottom-xlarge',
		'margin-top-none',
		'margin-top-small',
		'margin-top-medium',
		'margin-top-large',
		'margin-top-xlarge',
		'margin-right-none',
		'margin-right-small',
		'margin-right-medium',
		'margin-right-large',
		'margin-right-xlarge',
		'margin-left-none',
		'margin-left-small',
		'margin-left-medium',
		'margin-left-large',
		'margin-left-xlarge',
		'borderBottom',
		'borderBottomDouble',
		'borderTopBottom',
		'align-middle',
		'numbered',
		'lettered',
		'bracketed',
		'right-bracketed',
		'left-bracketed',
		'lower-alpha-bracketed',
		'lower-alpha-right-bracketed',
		'lower-alpha-left-bracketed',
		'upper-alpha-bracketed',
		'upper-alpha-right-bracketed',
		'upper-alpha-left-bracketed',
		'lower-roman-bracketed',
		'lower-roman-right-bracketed',
		'lower-roman-left-bracketed',
		'upper-roman-bracketed',
		'upper-roman-right-bracketed',
		'upper-roman-left-bracketed',
		'bold',
		'italic',
		'start1',
		'start2',
		'start3',
		'start4',
		'start5',
		'start6',
		'start7',
		'start8',
		'start9',
		'start10',
		'start11',
		'start12',
		'start13',
		'start14',
		'start15',
		'start16',
		'start17',
		'start18',
		'start19',
		'start20',
		'start21',
		'start22',
		'start23',
		'start24',
		'start25',
		'start26',
		'start27',
		'start28',
		'start29',
		'start30',
		'start31',
		'start32',
		'annual-report-2014-box',
		'whiteBG',
		'align-top',
		'align-middle',
		'align-bottom ',
		'webFeedLinkLeft',
		'image-left',
		'image-right',
		'image-left-margin',
		'image-right-margin',
		);
		foreach($checking_array as $to_check) {
			preg_match_all('/ class="([^"]*?)' . $to_check . '([^"]*?)"/is', $this->code, $matches);
			$to_check_found = 0;
			foreach($matches[0] as $index => $value) {
				if(strlen($matches[1][$index]) === 0 || substr($matches[1][$index], strlen($matches[1][$index]) - 1) === ' ') {
					$to_check_found++;
				}
			}
			if($to_check_found > 0) {
				print('<span style="color: red;">Found ' . $to_check_found . ' ' . $to_check . '!</span><br>');
			}
		}
		ReTidy::extra_style_attributes();
		$this->code = preg_replace('/ class="\s*"/is', '', $this->code);
		if(strpos($this->code, '<style') !== false) {
			print('<span style="color: red;">Found &lt;style!</span><br>');
		}
		// site issues
		preg_match_all('/<table([^<>]*?)>(.*?)<\/table>/is', $this->code, $table_matches);
		foreach($table_matches[0] as $index => $value) {
			$count = substr_count($table_matches[2][$index], '<caption');
			if($count === 0) {
				$this->code = str_replace($value, '<table' . $table_matches[1][$index] . '>
<caption class="text-left">FIX_MANUALLY</caption>' . $table_matches[2][$index] . '</table>', $this->code);
			} elseif($count > 1) {
				print('wa?');exit(0);
			}
		}
		
	}
	
	function undo_MGERC_CSS() {
		$class_replaces = array(
		'image-caption' => 'text-center',
		//.MGERC-border-top
		'longdesc' => 'text-center',
		//figure
		//figure img
		//figcaption
	//	'GraphicSection' => 'text-center',
		'HighlightSection' => 'well col-md-12',
		//.HighlightSectionRight
		//.HighlightTextCentered
		//.eBulletin
		//#eBulletinDate
		'normalize' => '',
		//.archived
		'margin-left-none' => 'mrgn-lft-0',
		'margin-left-small' => 'mrgn-lft-sm',
		'margin-left-medium' => 'mrgn-lft-md',
		'margin-left-large' => 'mrgn-lft-lg',
		'margin-left-xlarge' => 'mrgn-lft-xl',
		'margin-bottom-none' => 'mrgn-bttm-0',
		'margin-bottom-small' => 'mrgn-bttm-sm',
		'margin-bottom-medium' => 'mrgn-bttm-md',
		'margin-bottom-large' => 'mrgn-bttm-lg',
		'margin-bottom-xlarge' => 'mrgn-bttm-xl',
		'margin-top-none' => 'mrgn-tp-0',
		'margin-top-small' => 'mrgn-tp-sm',
		'margin-top-medium' => 'mrgn-tp-md',
		'margin-top-large' => 'mrgn-tp-lg',
		'margin-top-xlarge' => 'mrgn-tp-xl',
		'margin-right-none' => 'mrgn-rght-0',
		'margin-right-small' => 'mrgn-rght-sm',
		'margin-right-medium' => 'mrgn-rght-md',
		'margin-right-large' => 'mrgn-rght-lg',
		'margin-right-xlarge' => 'mrgn-rght-xl',
		// home page manually
		//.module
		'width-33' => '',
		'width-34' => '',
		//.whiteBG
		//.image-left
		//.image-right
		//.image-left-margin
		//.image-right-margin
		// ignore endnote stuff and fix it when joining pages
		'align-top' => 'media-body',
		'align-middle' => 'media-middle',
		'align-bottom' => 'media-bottom',
		);
		foreach($class_replaces as $search => $replace) {
			$this->code = preg_replace('/ class="([^"]*?)' . $search . '([^"]*?)"/is', ' class="$1' . $replace . '$2"', $this->code, -1, $count);
			$this->logMsgIf($search, $count);
		}
		$array_preg_replaces = array(
		'<(\w+)([^<>]*?) class="GraphicSectionLeft"([^<>]*?)>\s*<img' => '<$1$2$3><img class="media-left pull-left"',
		'<(\w+)([^<>]*?) class="GraphicSectionRight"([^<>]*?)>\s*<img' => '<$1$2$3><img class="media-right pull-right"',
		'<span class="WN-date">(.*?)<\/span>' => '<strong>$1</strong>',
		'<(\w+)([^<>]*?) class="WN-date"([^<>]*?)>(.*?)<\/\1>' => '<$1$2$3><strong>$4</strong></$1>',
		'<(\w+)([^<>]*?) class="PerspectivesDate"([^<>]*?)>(.*?)<\/\1>' => '<$1$2 class="pull-right"$3><strong>$4</strong></$1>',
		'<div id="eBulletinEndmatter">(.*?)<(h[0-9])>(.*?)<\/\2>(.*?)<\/div>' => '<section class="panel panel-primary">
  <header class="panel-heading">
    <h2 class="panel-title">$3</h2>
  </header>
  <div class="panel-body">
    $4
  </div>
</section>',
		'<p class="cs-subjet">(.*?)<\/p>' => '<section class="panel panel-primary">
  <div class="panel-body">
    $1
  </div>
</section>',
		'<div([^<>]*?) id="archived"([^<>]*?)>' => '<div$1 class="alert alert-danger"$2>',
		//' class="([^"]*?)align-top([^"]*?)"' => ' class="$1$2" style="vertical-align: top;"',
		//' class="([^"]*?)align-middle([^"]*?)"' => ' class="$1$2" style="vertical-align: middle;"',
		//' class="([^"]*?)align-bottom([^"]*?)"' => ' class="$1$2" style="vertical-align: bottom;"',
		' class="webFeedLinkLeft"([^<>]*?)><a ' => '$1><a style="background: url(/images/feed-fil/feed-fil-14x14.png) center left no-repeat !important; padding-left: 16px;" ',
		' class="webFeedLinkRight"([^<>]*?)><a ' => '$1><a style="background: url(/images/feed-fil/feed-fil-14x14.png) center right no-repeat !important; padding-right: 16px;" ',
		);
		foreach($array_preg_replaces as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $count);
			$this->logMsgIf(htmlentities($search), $count);
		}
		
		// check that there are none left
		$checking_array = array(
		'image-caption',
		'MGERC-border-top',
		'longdesc',
		'GraphicSectionLeft', // manual
		'GraphicSectionRight', // manual
		'GraphicSection', // manual
		'HighlightSection',
		'HighlightSectionRight',
		'HighlightTextCentered',
		'eBulletin',
		'normalize',
		'archived',
		'margin-left-none',
		'margin-left-small',
		'margin-left-medium',
		'margin-left-large',
		'margin-left-xlarge',
		'margin-bottom-none',
		'margin-bottom-small',
		'margin-bottom-medium',
		'margin-bottom-large',
		'margin-bottom-xlarge',
		'margin-top-none',
		'margin-top-small',
		'margin-top-medium',
		'margin-top-large',
		'margin-top-xlarge',
		'margin-right-none',
		'margin-right-small',
		'margin-right-medium',
		'margin-right-large',
		'margin-right-xlarge',
		// home page manually
		'width-33',
		'width-34',
		'whiteBG',
		'image-left',
		'image-right',
		'image-left-margin',
		'image-right-margin',
		);
		foreach($checking_array as $to_check) {
			preg_match_all('/ class="([^"]*?)' . $to_check . '([^"]*?)"/is', $this->code, $matches);
			if(sizeof($matches[0]) > 0) {
				print('<span style="color: red;">Found ' . sizeof($matches[0]) . ' ' . $to_check . '!</span><br>');
			}
		}
		ReTidy::extra_style_attributes();
		$this->code = preg_replace('/ class="\s*"/is', '', $this->code);
		if(strpos($this->code, '<style') !== false) {
			print('<span style="color: red;">Found &lt;style!</span><br>');
		}
		// site issues
		preg_match_all('/<table([^<>]*?)>(.*?)<\/table>/is', $this->code, $table_matches);
		foreach($table_matches[0] as $index => $value) {
			$count = substr_count($table_matches[2][$index], '<caption');
			if($count === 0) {
				$this->code = str_replace($value, '<table' . $table_matches[1][$index] . '>
<caption class="text-left">FIX_MANUALLY</caption>' . $table_matches[2][$index] . '</table>', $this->code);
			} elseif($count > 1) {
				print('wa?');exit(0);
			}
		}
		
	}
	
	function update_to_WET4() {
		
		// do this first
		ReTidy::update_to_WET3();
		
		$this->code = str_replace('<div class="wet-boew-footnotes" role="note">', '<aside class="wb-fnote" role="note">', $this->code);
		$this->code = str_replace('<div class="wet-boew-footnotes">', '<aside class="wb-fnote">', $this->code);
		$this->code = str_replace('<h2 id="fnb" class="wb-invisible">Footnotes</h2>', '<h3 id="fn">Footnotes</h3>', $this->code);
		$this->code = str_replace('<h2 id="fnb" class="wb-invisible">Notes de bas de page</h2>', '<h3 id="fn">Notes de bas de page</h3>', $this->code);
		
		$this->code = preg_replace('/<aside class="wb-fnote" role="note">\s*<section>(.*?)<\/section>/is', '<aside class="wb-fnote" role="note">$1</aside>', $this->code);
		
		$array_replaces = array(
		// search => replace
		// notice that superstrings must come before
		
		'align-justify' => 'text-justify',
		'align-left align-right' => 'text-right',
		'align-left align-left' => 'text-left',
		'align-left' => 'text-left',
		'align-center' => 'text-center',
		'align-centre' => 'text-center',
		'align-right' => 'text-right',
		//'align-justify' => 'text-justify',
		'alignLeft' => 'text-left',
		'alignCenter' => 'text-center',
		'alignRight' => 'text-right',
		'alignTop' => 'align-top',
		'alignBottom' => 'align-bottom',
		//'' => 'center-block',
		'indent-medium' => 'mrgn-lft-md',
		'indent-large' => 'mrgn-lft-lg',
		'indent-xlarge' => 'mrgn-lft-xl',
		'margin-left-medium' => 'mrgn-lft-md',
		'margin-right-medium' => 'mrgn-rght-md',
		'margin-top-medium' => 'mrgn-tp-md',
		'margin-bottom-medium' => 'mrgn-bttm-md',
		'margin-bottom-small' => 'mrgn-bttm-sm',
		//'' => 'image-left',
		//'' => 'image-right',
		'width-20 float-left' => 'image-left-margin',
		'width-20 float-right' => 'image-right-margin',
		'float-right' => 'pull-right',
		'float-left' => 'pull-left',
		'list-bullet-none indent-none' => 'list-unstyled',
		'list-bullet-none' => 'list-unstyled',
		'indent-none' => 'list-unstyled',
		'noBullet' => 'list-unstyled',
		'wrap-none' => 'text-nowrap',
		'nowrap' => 'text-nowrap',
		'noWrap' => 'text-nowrap',
		'uppercase' => 'text-uppercase',
		'lowercase' => 'text-lowercase',
		'list-lower-alpha' => 'lst-lwr-alph',
		'list-upper-alpha' => 'lst-upr-alph',
		'list-lower-roman' => 'lst-lwr-rmn',
		'list-upper-roman' => 'lst-upr-rmn',
		'lower-alpha' => 'lst-lwr-alph',
		'upper-alpha' => 'lst-upr-alph',
		'lower-roman' => 'lst-lwr-rmn',
		'upper-roman' => 'lst-upr-rmn',
		//'' => 'lst-num',
		
		'border-left' => 'brdr-lft',
		'border-right' => 'brdr-rght',
		'border-top' => 'brdr-tp',
		'border-bottom' => 'brdr-bttm',
		'border-all' => '',
		
		'button-group' => 'btn-group',
		'button' => 'btn',
		
		'footnote-link' => 'fn-lnk',
		'footnote-return' => 'fn-rtn',
		'wb-invisible' => 'wb-inv',
		
		'module span-8' => 'well col-md-12',
		'module' => 'well col-md-12',
		'module-attention span-8' => 'alert alert-warning col-md-12',
		'module-alert span-8' => 'alert alert-danger col-md-12',
		'span-10' => 'col-md-11',
		'span-9' => 'col-md-9',
		'span-8' => 'col-md-12',
		'span-7' => 'col-md-11',
		'span-6' => 'col-md-9',
		'span-5' => 'col-md-8',
		'span-4' => 'col-md-6',
		'span-3' => 'col-md-4',
		'span-2' => 'col-md-3',
		'span-1' => 'col-md-1',
		
		'font-xxlarge' => 'h1',
		'font-xlarge' => 'h2',
		'font-large' => 'h3',
		'fontSize80' => 'h4',
		'font-small' => 'h4',
		'font-xsmall' => 'h5',
		'font-xxsmall' => 'h6',
		
		'wet-boew-charts' => 'wb-charts',
		
		'clear' => 'clearfix',
		
		'square' => '',
		'disc' => '',
		'width-10' => '',
		'width-20' => '',
		'width-30' => '',
		'width-40' => '',
		'width-50' => '',
		'width-60' => '',
		'width-70' => '',
		'width-80' => '',
		'width-90' => '',
		'clear-left' => '',
		'clear-right' => '',
		'image-actual' => '',
		'first' => '',
		'grid-12' => '',
		'background-light' => '',
		'bg-lightgrey' => '',
		'char-style-override-1' => '',
		'quote-smaller' => '',
		'color-black' => '',
		'new_class3' => '',
		'eBulletinMainHeading' => '',
		'PerspectivesDateRight' => '',
		'MsoNormal' => '',
		'MsoListParagraphCxSpFirst' => '',
		'MsoListParagraphCxSpMiddle' => '',
		'MsoListParagraphCxSpLast' => '',
		'background-dark' => '',

		);
		preg_match_all('/ class="([^"]*?)"/is', $this->code, $class_attribute_matches, PREG_OFFSET_CAPTURE);
		$counter = sizeof($class_attribute_matches[0]) - 1;
		while($counter > -1) {
			$initial_attribute_value = $attribute_value = $class_attribute_matches[1][$counter][0];
			foreach($array_replaces as $search => $replace) {
				//$attribute_value = str_replace($search, $replace, $attribute_value);
				$attribute_value = ReTidy::str_replace_whole_word_for_styles($search, $replace, $attribute_value);
			}
			if($initial_attribute_value != $attribute_value) {
				//print('here30450506-6-67<br>');
				$this->code = substr($this->code, 0, $class_attribute_matches[1][$counter][1]) . $attribute_value . substr($this->code, $class_attribute_matches[1][$counter][1] + strlen($initial_attribute_value));
			}
			$counter--;
		}
		
		$this->code = preg_replace('/<li><a href="([^"]*?)" class="btn">(.*?)<\/a><\/li>/is', '<a href="$1" class="btn btn-default">$2</a>', $this->code);
		$this->code = preg_replace('/<ul class="btn-group">(.*?)<\/ul>/is', '<div class="btn-group">$1</div>', $this->code);
		// have to use ostring for this errors have already occured due to not doing so...
		$this->code = preg_replace('/<span class="font-small">(.*?)<\/span>/is', '<small>$1</small>', $this->code);
		$this->code = preg_replace('/<div class="font-small">(.*?)<\/div>/is', '<small>$1</small>', $this->code);
		$this->code = preg_replace('/<(\w+)([^<>]*?) class="([^"]*?)\s*font-xsmall([^"]*?)"([^<>]*?)>(.*?)<\/\1>/is', '<$1$2 class="$3$4"$5><small>$6</small></$1>', $this->code);
		$this->code = preg_replace('/<(\w+)([^<>]*?) class="([^"]*?)\s*font-small([^"]*?)"([^<>]*?)>(.*?)<\/\1>/is', '<$1$2 class="$3$4"$5><small>$6</small></$1>', $this->code);
		$this->code = preg_replace('/<table([^<>]*?) class="([^"]*?)wb\-charts\-([^"\s\-]+)\-([^"\s\-]+)([^"]*?)"([^<>]*?)>/is', '<table$1 class="$2$5"$6 data-wb-charts=\'{"$3": $4}\'>', $this->code);
		$count = -1;
		while($count != 0) {
			$this->code = preg_replace('/<table([^<>]*?) class="([^"]*?)wb\-charts\-([^"\s\-]+)\-([^"\s\-]+)([^"]*?)"([^<>]*?) data\-wb\-charts=\'\{([^\{\}]*?)\}\'>/is', '<table$1 class="$2$5"$6 data-wb-charts=\'{$7, "$3": $4}\'>', $this->code, -1, $count);
		}
		
		$this->code = str_replace('<div class="clear"></div>', '', $this->code);
		$this->code = str_replace('<table', '<table class="table table-bordered"', $this->code);
		$this->code = str_replace('<thead', '<thead class="well"', $this->code);
		$array_replaces = array();
		preg_match_all('/<tr(.*?)<\/tr>/is', $this->code, $tr_matches);
		foreach($tr_matches[0] as $index => $value) {
			$th_count = substr_count($value, '<th');
			$cell_count = $th_count + substr_count($value, '<td');
			if($th_count && $cell_count === 1) {
				$new_tr_string = str_replace('<tr', '<tr class="well"', $value);
				$array_replaces[$value] = $new_tr_string;
			}
		}
		foreach($array_replaces as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code);
		}
		$this->code = preg_replace('/<(\w+)([^<>]*?) class="([^"]*?)"([^<>]*?) class="([^"]*?)"([^<>]*?)>/is', '<$1$2 class="$3 $5"$4$6>', $this->code);
		
		$array_classes_to_uniquate = array(
		'table',
		'well',
		'table-bordered',
		);
		foreach($array_classes_to_uniquate as $class_name) {
			$array_replaces = array();
			preg_match_all('/ class="([^"]*?)"/is', $this->code, $class_matches);
			foreach($class_matches[0] as $index => $value) {
				$classes_string = $class_matches[1][$index];
				$classes = explode(' ', $classes_string);
				$array_indices_to_remove = array();
				foreach($classes as $index => $class) {
					foreach($classes as $index2 => $class2) {
						if($index2 <= $index) {
							continue;
						}
						if($class === $class2) {
							//print('matched ' . $class . ' to ' . $class2 . '.<br>');
							$array_indices_to_remove[] = $index2;
						}
					}
				}
				//var_dump($classes_string, $array_indices_to_remove);
				$new_classes_string = '';
				foreach($classes as $index => $class) {
					if($index === 0) {
						$new_classes_string .= $class;
						continue;
					} else {
						foreach($array_indices_to_remove as $index_to_remove) {
							if($index === $index_to_remove) {
								continue 2;
							}
						}
					}
					$new_classes_string .= ' ' . $class;
				}
				$array_replaces[$value] = ' class="' . $new_classes_string . '"';
			}
			//var_dump($array_replaces);
			foreach($array_replaces as $search => $replace) {
				$this->code = str_replace($search, $replace, $this->code);
			}
		}
		
		
		//$arrayClassNamesFromStyleInformation = ReTidy::getArrayClassNamesFromStyleInformation(file_get_contents($this->template));
		//ReTidy::setArrayClassNamesFromStyleInformation(file_get_contents($this->template));
		// extreme hack warning!!
		ReTidy::setArrayClassNamesFromStyleInformation(file_get_contents('C:\wamp\www\sweeper\sample_file_for_css.html'));
		//var_dump(time());
		$array_class_name_counts = array();
		preg_match_all('/ class="([^"]*?)"/is', $this->code, $class_attribute_matches);
		foreach($class_attribute_matches[0] as $index => $value) {
			//var_dump($class_attribute_matches[1][$index]);
			preg_match_all('/[^\s]+/is', $class_attribute_matches[1][$index], $class_name_matches);
			foreach($class_name_matches[0] as $index2 => $value2) {
				if(isset($array_class_name_counts[$value2])) {
					$array_class_name_counts[$value2]++;
				} else {
					$array_class_name_counts[$value2] = 1;
				}
			}
		}
		// definately a hack
		$this->arrayClassNamesFromStyleInformation['page'] = false;
		$this->arrayClassNamesFromStyleInformation['core'] = false;
		$this->arrayClassNamesFromStyleInformation['left'] = false;
		$this->arrayClassNamesFromStyleInformation['center'] = false;
		$this->arrayClassNamesFromStyleInformation['wb-inv'] = false;
		$this->arrayClassNamesFromStyleInformation['cn-left-col-default'] = false;
		//var_dump($this->arrayClassNamesFromStyleInformation['width-50']);
		$array_class_names_instantiated = array();
		//var_dump($array_class_name_counts, $this->arrayClassNamesFromStyleInformation);
		foreach($array_class_name_counts as $index => $value) {
			//$array_class_names_instantiated[] = $index;
			if(isset($this->arrayClassNamesFromStyleInformation[$index])) {
				
			} else {
				//print($this->code);
		//		print('Nope nope nope. An instantiated class: ' . $index . ' does not exist in the referenced stylesheets.');exit(0);
			}
		}
		if(strpos($this->code, 'Dummy') !== false) {
			print('Probably found a dummy h1 indicating a problem templating code in an abstract template...');exit(0);
		}
		//var_dump(time());
		//$merged_instantiated_and_referred_to_class_names_array = array_merge($arrayClassNamesFromStyleInformation, $array_class_names_instantiated);
		//sort($merged_instantiated_and_referred_to_class_names_array);
		
	}
	
	function update_to_WET3() {
		//var_dump(time());
		$array_replaces = array(
		// search => replace
		// notice that superstrings must come before
	//	' border="0"' => '',
	//	' cellpadding="0"' => '',
	//	' cellspacing="0"' => ' style="border-collapse: collapse; border-spacing: 0;"',
		
		'width100' => 'width-100',
		'width97' => 'width-90',
		'width95' => 'width-90',
		'width90' => 'width-90',
		'width85' => 'width-80',
		'width80' => 'width-80',
		'width75' => 'width-70',
		'width70' => 'width-70',
		'width65' => 'width-60',
		'width60' => 'width-60',
		'width55' => 'width-60',
		'width50' => 'width-50',
		'width45' => 'width-40',
		'width40' => 'width-40',
		'width35' => 'width-30',
		'width30' => 'width-30',
		'width25' => 'width-20',
		'width20' => 'width-20',
		'width15' => 'width-10',
		'width10' => 'width-10',
		'width5' => 'width-10',
		'width33' => 'width-33',
		'width34' => 'width-34',
		
		'Width100' => 'width-100',
		'Width97' => 'width-90',
		'Width95' => 'width-90',
		'Width90' => 'width-90',
		'Width85' => 'width-80',
		'Width80' => 'width-80',
		'Width75' => 'width-70',
		'Width70' => 'width-70',
		'Width65' => 'width-60',
		'Width60' => 'width-60',
		'Width55' => 'width-60',
		'Width50' => 'width-50',
		'Width45' => 'width-40',
		'Width40' => 'width-40',
		'Width35' => 'width-30',
		'Width30' => 'width-30',
		'Width25' => 'width-20',
		'Width20' => 'width-20',
		'Width15' => 'width-10',
		'Width10' => 'width-10',
		'Width5' => 'width-10',
		'Width33' => 'width-33',
		'Width34' => 'width-34',
		
		'clearLeft' => 'clear-left',
		'clearRight' => 'clear-right',
		'ClearLeft' => 'clear-left',
		'ClearRight' => 'clear-right',
		'clearBoth' => 'clear',
		'bx-clr' => 'clear',
		'bx-clrrt' => 'clear-right',
		'bx-clrlf' => 'clear-left',
		'floatleft' => 'float-left',
		'floatright' => 'float-right',
		
		'TE-date' => '',
		'TE-Date' => '',
		'TE-Dates' => '',
		'TE-Destination' => '',
		'TE-Fare' => '',
		'TE-OT' => '',
		'TE-Accommondation' => '',
		'TE-Meals' => '',
		'TE-Other' => '',
		'TE-Total' => '',
		'TE-caption' => '',
		'tns' => '',
		'special' => '',
		'imgPad45' => '',
		'lightBlueTable' => '',
		'lightMarine' => '',
		'lightRow' => '',
		'light' => '',
		'lightBlueRow' => '',
		'lightBlue' => '',
		'lightHeader' => '',
		'TableBlue' => '',
		'TableBlue-BorderLTB' => '',
		'TableBlue-BorderTB' => '',
		'TableBlue-BorderRTB' => '',
		'eBulletinMainHeading' => '',
		'quote' => '',
		'AR' => '',
		'top' => '',
		'side' => '',
		'right' => '',
		'bottom' => '',
		'footnote' => '',
		'box' => '',
		'conduct' => '',
		'int' => '',
		'files' => '',
		'BoldBoldOrange' => '',
		'BoldOrange' => '',
		'BoldBlue' => '',
		'Bold' => '',
		'Orange' => '',
		'YellowBackground' => '',
		'TableGoldTd' => '',
		'TableGoldTd-BorderR' => '',
		'TableGoldTd-BorderL' => '',
		'bleuPale' => '',
		'bleuDark' => '',
		'white' => '',
		'265' => '',
		'129' => '',
		'2' => '',
		'34' => '',
		'outsideBorders' => '',
		'outsideBordersOnly' => '',
		'frameHeader' => '',
		'greyMedium' => '',
		'greyLight' => '',
		'greyLighter' => '',
		'darkBlueCell' => '',
		'frame' => '',
		'frameSubHeader' => '',
		'frameBlock' => '',
		'frameNoTop' => '',
		'blackBorders' => '',
		'blackCell' => '',
		'borderSides' => '',
		'greyDark' => '',
		'lightgreyBG' => '',
		'menulink' => '',
		'menuleft' => '',
		'menuright' => '',
		'chrono' => '',
		'chronolisting' => '',
		'bottomLinks' => '',
		'cov' => '',
		'cover' => '',
		'fn' => '',
		'tocmenu' => '',
		'block110' => '',
		'block470' => '',
		'titleBlue' => '',
		'width600' => '',
		'block120' => '',
		'block180' => '',
		'toc' => '',
		'toc2' => '',
		'hearingreport' => '',
		'hearingreportstyle' => '',
		'reportheader' => '',
		'salut' => '',
		'file' => '',
		'cc' => '',
		'#footnote2' => '',
		'analysisTopic' => '',
		'pnum' => '',
		'excerpt' => '',
		'personnel' => '',
		'blockLine' => '',
		'disc' => '',
		'bullet' => '',
		'titlebar' => '',
		'description' => '',
		'black' => 'redacted',
		'BLACK' => 'redacted',
		'signoff' => '',
		'signoffDate' => '',
		'border' => '',
		'inside' => '',
		'noColor' => '',
		'immediate' => '',
		'disponible' => '',
		'width600' => '',
		'width125' => '',
		'width100' => '',
		'report' => '',
		'Header' => '',
		'header' => '',
		'doublelinespace' => '',
		'disclosure' => '',
		'topHeader' => '',
		'topic' => '',
		'paragraph_blue' => '',
		'tbl00' => '',
		'tbl01' => '',
		'tbl02' => '',
		'ind-h01' => '',
		'ind-h02' => '',
		'ind-mid' => '',
		'cn-toppage' => '',
		'circle' => '',
		'square' => '',
		'h7' => '',
		'bx-hz' => '',
		'tbl' => '',
		'darkgreyBG' => '',
		'blackBG' => 'background-dark',
		'borderBottomThick' => '',
		'borderBotàmThick' => '',
		'Small' => '',
		'WN' => '',
		'THalignLeft' => 'align-left',
		'OL-LowerCase' => 'list-lower-alpha',
		'OL-Arabic' => '',
		'borderBottomDouble' => '',
		'ar_th' => '',
		'ar_th2' => '',
		'ar_3' => '',
		'ar_4' => '',
		'padding-3px' => '',
		'dpr' => '',
		'rpp' => '',
		'topPage' => '',
		'lightgrey' => '',
		'foot1' => '',
		'foot2' => '',
		'uparrow' => '',
		'margin-left0' => '',
		'no-bord' => '',
		'bo-bord' => '',
		'word-imported-list-2' => '',
		'normal-2' => '',
		'basic-paragraph' => '',
		'colLayout' => '',
		'tbl-ct' => '',
		'tbl-rt' => '',
		'tbl-lt' => '',
		'tbl-lf' => '',
		'hr-fn' => '',
		'commonbar' => '',
		'tbl-ct&nbsp;mg-bt1' => '',
		'newsViewDate' => '',
		'newsViewLocation' => '',
		
		'new_class1' => '',
		'new_class2' => '',
		'new_class3' => '',
		'new_class4' => '',
		'new_class5' => '',
		
		'style20' => '',
		'style19' => '',
		'style18' => '',
		'style17' => '',
		'style16' => '',
		'style15' => '',
		'style14' => '',
		'style13' => '',
		'style12' => '',
		'style11' => '',
		'style10' => '',
		'style9' => '',
		'style8' => '',
		'style7' => '',
		'style6' => '',
		'style5' => '',
		'style4' => '',
		'style3' => '',
		'style2' => '',
		'style1' => '',
		
		'target_blank' => '',
		'noSpaces' => '',
		'noSpace' => '',
		
		'widthfull' => '',
		'widthFull' => '',
		'noticeCraBlue' => 'module span-8',
		'blackborderNEW' => 'module span-8',
		'Citation' => 'module span-8',
		'bigbox' => 'module span-8',
		'goldbox' => 'module span-8',
		'CED5E7' => 'module span-8',
		'ContentCell' => 'module span-8',
		'highlightBox' => 'module span-8',
		'finding' => 'module span-8',
		'marine' => 'module span-8',
		'borderSimple' => 'module span-8',
		'ol2' => 'bracketed',
		'ol3' => 'lower-alpha-bracketed',
		'double_Black' => 'module-attention span-8',
		'vettingNote' => 'module-attention span-8',
		'em' => 'italic',
		'underlinedheader' => 'bold',
		'dblSpList' => 'list-space',
		'txtboxa05' => 'module span-8',
		'c1' => 'align-center',
		'c2' => 'align-center',
		'c3' => 'align-center',
		'c4' => 'align-center',
		'bx01' => 'module span-8',
		'bx-pd' => 'module span-8',
		'nav' => 'list-spacing01',
		'alignTopmCenter' => 'align-top align-center',
		'align-topleftCenter' => 'align-top align-center',
		'alignCenterLeft' => 'align-left',
		'highlight' => 'module span-8',
		
		'nowrap' => 'wrap-none',
		'noWrap' => 'wrap-none',
		'noWrape' => 'wrap-none',
		'txt-nrm' => 'normalize',
		'lst-sp01' => '',

		'fontsize200' => 'font-xxlarge',
		'fontSize200' => 'font-xxlarge',
		'fontsize195' => 'font-xxlarge',
		'fontSize195' => 'font-xxlarge',
		'fontsize190' => 'font-xxlarge',
		'fontSize190' => 'font-xxlarge',
		'fontsize185' => 'font-xxlarge',
		'fontSize185' => 'font-xxlarge',
		'fontsize180' => 'font-xxlarge',
		'fontSize180' => 'font-xxlarge',
		'fontsize175' => 'font-xxlarge',
		'fontSize175' => 'font-xxlarge',
		'fontsize170' => 'font-xxlarge',
		'fontSize170' => 'font-xxlarge',
		'fontsize165' => 'font-xxlarge',
		'fontSize165' => 'font-xxlarge',
		'fontsize160' => 'font-xxlarge',
		'fontSize160' => 'font-xxlarge',
		'h1size' => 'font-xxlarge',
		'h1Size' => 'font-xxlarge',
		'fontsize155' => 'font-xxlarge',
		'fontSize155' => 'font-xxlarge',
		
		'fontsize150' => 'font-xlarge',
		'fontSize150' => 'font-xlarge',
		'h2size' => 'font-xlarge',
		'h2Size' => 'font-xlarge',
		'fontsize145' => 'font-xlarge',
		'fontSize145' => 'font-xlarge',
		'fontsize140' => 'font-xlarge',
		'fontSize140' => 'font-xlarge',
		'h3size' => 'font-xlarge',
		'h3Size' => 'font-xlarge',
		'big' => 'font-xlarge',
		'fontsize135' => 'font-xlarge',
		'fontSize135' => 'font-xlarge',
		'fontsize130' => 'font-xlarge',
		'fontSize130' => 'font-xlarge',
		'h4size' => 'font-xlarge',
		'h4Size' => 'font-xlarge',
		'fontsize125' => 'font-xlarge',
		'fontSize125' => 'font-xlarge',
		
		'fontsize120' => 'font-large',
		'fontSize120' => 'font-large',
		'h5size' => 'font-large',
		'h5Size' => 'font-large',
		'fontsize115' => 'font-large',
		'fontSize115' => 'font-large',
		'fontsize110' => 'font-large',
		'fontSize110' => 'font-large',
		'h6size' => 'font-large',
		'h6Size' => 'font-large',
		'headline' => 'font-large',
		'fontsize105' => 'font-large',
		'fontSize105' => 'font-large',
		
		'fontsize100' => 'font-medium',
		'fontSize100' => 'font-medium',
		
		'fontsize95' => 'font-small',
		'fontSize95' => 'font-small',
		'fontsize90' => 'font-small',
		'fontSize90' => 'font-small',
		'fontsize85' => 'font-small',
		'fontSize85' => 'font-small',
		'mediumfont' => 'font-small',
		'mediumFont' => 'font-small',
		'Reduce90' => 'font-small',
		
		'fontsize80' => 'font-xsmall',
		'fontSize80' => 'font-xsmall',
		'fontsize75' => 'font-xsmall',
		'fontSize75' => 'font-xsmall',
		'fontsize70' => 'font-xsmall',
		'fontSize70' => 'font-xsmall',
		'smallfont' => 'font-xsmall',
		'smallFont' => 'font-xsmall',
		'Reduce80' => 'font-xsmall',
		'Reduce70' => 'font-xsmall',
		'smaller' => 'font-xsmall',
		
		'fontsize65' => 'font-xxsmall',
		'fontSize65' => 'font-xxsmall',
		'fontsize60' => 'font-xxsmall',
		'fontSize60' => 'font-xxsmall',
		'fontsize55' => 'font-xxsmall',
		'fontSize55' => 'font-xxsmall',
		'fontsize50' => 'font-xxsmall',
		'fontSize50' => 'font-xxsmall',
		'Reduce65' => 'font-xxsmall',
		'Reduce60' => 'font-xxsmall',
		
		'font95' => 'font-small',
		'font90' => 'font-small',
		'font85' => 'font-small',
		'font80' => 'font-xsmall',
		'font75' => 'font-xsmall',
		'font70' => 'font-xsmall',
		'font65' => 'font-xxsmall',
		'font60' => 'font-xxsmall',
		'font55' => 'font-xxsmall',
		'font50' => 'font-xxsmall',
		
		'source' => 'font-small',
		
		// these four are in the internal template so they definately have to go 
		//'page' => '',
		//'core' => '',
		//'left' => '',
		//'center' => '',
		
		//.indent-none{margin-left:0!important}.indent-small{margin-left:2px!important}.indent-medium{margin-left:10px!important}.indent-large{margin-left:20px!important}.indent-xlarge{margin-left:50px!important}
		
		'indent' => 'indent-medium',
		'indent1' => 'indent-medium',
		'indent2' => 'indent-large',
		'indent3' => 'indent-xlarge',
		'indent4' => 'indent-xlarge',
		'indent5' => 'indent-xlarge',
		
		//.list-lower-alpha{list-style-type:lower-alpha!important}.list-lower-roman{list-style-type:lower-roman!important}.list-bullet-none{list-style-type:none!important}.list-upper-alpha{list-style-type:upper-alpha!important}.list-upper-roman{list-style-type:upper-roman!important}
		
		
		'loweralph' => 'list-lower-alpha',
		'lower-alpha' => 'list-lower-alpha',
		'lowerroman' => 'list-lower-roman',
		'lower-roman' => 'list-lower-roman',
		'upper-alpha' => 'list-upper-alpha',
		'upper-roman' => 'list-upper-roman',
		'nobulletnoindent' => 'list-bullet-none indent-none',
		'noBulletNoIndent' => 'list-bullet-none indent-none',
		'nobullet' => 'list-bullet-none',
		'noBullet' => 'list-bullet-none',
		'noBullet-all' => 'list-bullet-none',
		
		'floatLeft' => 'float-left',
		'floatRight' => 'float-right',
		
		'alignLeftBorderTop' => 'align-left',
		'alignCenterBorderTop' => 'align-center',
		'alignRightBorderTop' => 'align-right',
		
		'BorderTop' => 'border-top',
		'BorderBottom' => 'border-bottom',
		'BorderRight' => 'border-right',
		'BorderLeft' => 'border-left',
		'BorderTopBottom' => 'border-top border-bottom',
		'BorderAll' => 'border-all',
		
		'BorderTopThin' => 'border-top',
		'BorderBottomThin' => 'border-bottom',
		'BorderRightThin' => 'border-right',
		'BorderLeftThin' => 'border-left',
		'BorderTopBottomThin' => 'border-top border-bottom',
		'BorderAllThin' => 'border-all',
		
		'borderTopThin' => 'border-top',
		'borderBottomThin' => 'border-bottom',
		'borderRightThin' => 'border-right',
		'borderLeftThin' => 'border-left',
		'borderTopBottomThin' => 'border-top border-bottom',
		'borderAllThin' => 'border-all',
		
		'borderTop' => 'border-top',
		'borderBottom' => 'border-bottom',
		'borderRight' => 'border-right',
		'borderLeft' => 'border-left',
		'borderTopBottom' => 'border-top border-bottom',
		'borderAll' => 'border-all',
		
		'blackborder' => 'border-all',
		'blackBorder' => 'border-all',
		
		'align-bottomleft' => 'align-bottom align-left',
		'align-bottomcenter' => 'align-bottom align-center',
		'align-bottomright' => 'align-bottom align-right',
		'align-topleft' => 'align-top align-left',
		'align-topcenter' => 'align-top align-center',
		'align-topright' => 'align-top align-right',
		
		'alignBottomLeft' => 'align-bottom align-left',
		'alignBottomCenter' => 'align-bottom align-center',
		'alignBottomRight' => 'align-bottom align-right',
		'alignTopLeft' => 'align-top align-left',
		'alignTopCenter' => 'align-top align-center',
		'alignTopRight' => 'align-top align-right',
		'alignLeft' => 'align-left',
		'alignCenter' => 'align-center',
		'alignRight' => 'align-right',
		'alignBottom' => 'align-bottom',
		'alignTop' => 'align-top',
		
		'rightalign' => 'align-right',
		
		'image-left' => 'float-left margin-bottom-medium margin-right-medium',
		'image-right' => 'float-right margin-bottom-medium margin-left-medium',
		'floatLeftImage' => 'float-left margin-bottom-medium margin-right-medium',
		'floatRightImage' => 'float-right margin-bottom-medium margin-left-medium',
		
		'margin-left-1em' => 'margin-left-medium',
		'margin-right-1em' => 'margin-right-medium',
		'margin-bottom-1em' => 'margin-bottom-medium',
		'margin-top-1em' => 'margin-top-medium',
		
		);
		preg_match_all('/ class="([^"]*?)"/is', $this->code, $class_attribute_matches, PREG_OFFSET_CAPTURE);
		$counter = sizeof($class_attribute_matches[0]) - 1;
		while($counter > -1) {
			$initial_attribute_value = $attribute_value = $class_attribute_matches[1][$counter][0];
			//var_dump($initial_attribute_value, $attribute_value);exit(0);
			//print('here46589690709<br>');
			foreach($array_replaces as $search => $replace) {
				//print('here46589690710<br>');
				//$attribute_value = str_replace($search, $replace, $attribute_value);
				$attribute_value = ReTidy::str_replace_whole_word_for_styles($search, $replace, $attribute_value);
			}
			if($initial_attribute_value != $attribute_value) {
				//print('here30450506-6-67<br>');
				$this->code = substr($this->code, 0, $class_attribute_matches[1][$counter][1]) . $attribute_value . substr($this->code, $class_attribute_matches[1][$counter][1] + strlen($initial_attribute_value));
			}
			$counter--;
		}
		//var_dump(time());
		$this->code = preg_replace('/ border="[^"]*?"/is', '', $this->code);
		$this->code = preg_replace('/ cellpadding="[^"]*?"/is', '', $this->code);
		$this->code = preg_replace('/ cellspacing="[^"]*?"/is', '', $this->code);
		$this->code = preg_replace('/ summary="[^"]*?"/is', '', $this->code);
		$this->code = preg_replace('/ longdesc="[^"]*?"/is', '', $this->code);
		$this->code = preg_replace('/ width="100%"/is', '', $this->code);
		$this->code = preg_replace('/<div class="quotes">(.*?)<\/div>/is', '<blockquote>
<p>$1</p>
</blockquote>', $this->code);

		$this->code = preg_replace('/<p class="quoteindent">(.*?)<\/p>/is', '<blockquote>
<p>$1</p>
</blockquote>', $this->code);
		
		//print($this->code);exit(0);
		/*foreach($array_replaces as $search => $replace) {
			//$this->code = str_replace($search, $replace, $this->code, $count);
			$this->code = preg_replace('/ class="([^"]*?)' . $search . '([^"]*?)"/s', ' class="$1' . $replace . '$2"', $this->code, $count);
			$this->logMsgIf('XHTML_to_HTML5 class conversion [' . htmlentities($search) . '] to [' . htmlentities($replace) . ']', $count);
		}*/
		//$arrayClassNamesFromStyleInformation = ReTidy::getArrayClassNamesFromStyleInformation(file_get_contents($this->template));
		ReTidy::setArrayClassNamesFromStyleInformation(file_get_contents($this->template));
		//var_dump(time());
		$array_class_name_counts = array();
		preg_match_all('/ class="([^"]*?)"/is', $this->code, $class_attribute_matches);
		foreach($class_attribute_matches[0] as $index => $value) {
			//var_dump($class_attribute_matches[1][$index]);
			preg_match_all('/[^\s]+/is', $class_attribute_matches[1][$index], $class_name_matches);
			foreach($class_name_matches[0] as $index2 => $value2) {
				if(isset($array_class_name_counts[$value2])) {
					$array_class_name_counts[$value2]++;
				} else {
					$array_class_name_counts[$value2] = 1;
				}
			}
		}
		// definately a hack
		$this->arrayClassNamesFromStyleInformation['page'] = false;
		$this->arrayClassNamesFromStyleInformation['core'] = false;
		$this->arrayClassNamesFromStyleInformation['left'] = false;
		$this->arrayClassNamesFromStyleInformation['center'] = false;
		//var_dump($this->arrayClassNamesFromStyleInformation['width-50']);
		$array_class_names_instantiated = array();
		//var_dump($array_class_name_counts, $this->arrayClassNamesFromStyleInformation);
		/*foreach($array_class_name_counts as $index => $value) {
			//$array_class_names_instantiated[] = $index;
			if(isset($this->arrayClassNamesFromStyleInformation[$index])) {
				
			} else {
				//print($this->code);
				print('Nope nope nope. An instantiated class: ' . $index . ' does not exist in the referenced stylesheets.');exit(0);
			}
		}*/
		//var_dump(time());
		//$merged_instantiated_and_referred_to_class_names_array = array_merge($arrayClassNamesFromStyleInformation, $array_class_names_instantiated);
		//sort($merged_instantiated_and_referred_to_class_names_array);
		
		ReTidy::WET3_footnotes();

		//var_dump(time());
		// necessary clean-up
		//ReTidy::extra_style_attributes();
		ReTidy::extra_class_attributes();
		//var_dump(time());
		return true;
	}
	
	function WET3_footnotes() {
		// footnotes
		if($this->language === 'french') {
			$this->code = preg_replace(
			'/<dt>Footnote ([0-9]+)<\/dt>\s*<dd id="fnb\1">\s*(.*?)\s*<p class="footnote-return"><a href="#fnb\1-ref"><span class="wb-invisible">Return to footnote <\/span>\1<span class="wb-invisible"> referrer<\/span><\/a><\/p>\s*<\/dd>/is', 
			'<dt>Note de bas de page $1</dt>
<dd id="fnb$1">
	$2
	<p class="footnote-return"><a href="#fnb$1-ref"><span class="wb-invisible">Retour à la référence de la note de bas de page </span>$1</a></p>
</dd>', 
			$this->code);
			$this->code = preg_replace(
			'/<(li|p)><a href="([^"#]*?)#[^"#0-9]*?([0-9]+)" id="[^"#0-9]*?([0-9]+)" title="([^"]*?)">\[?([0-9]+)\]?<\/a>\s*(' . $this->nonBreakingSpaceRegex . ')?\s*(.*?)<\/\1>/is', 
			'<dt>Note de bas de page $3</dt>
<dd id="fnb$3">
<p>$8</p>
<p class="footnote-return"><a href="#fnb$3-ref"><span class="wb-invisible">Retour à la référence de la note de bas de page </span>$3</a></p>
</dd>', 
			$this->code);
			$this->code = preg_replace(
			'/<sup id="fnb([0-9]+)-ref"><a class="footnote-link" href="#fnb\1"><span class="wb-invisible">Footnote <\/span>\1<\/a><\/sup>/is', 
			'<sup id="fnb$1-ref"><a class="footnote-link" href="#fnb$1"><span class="wb-invisible">Note de bas de page </span>$1</a></sup>', 
			$this->code);
			$this->code = preg_replace(
			'/<sup><a href="([^"#]*?)#[^"#0-9]*?([0-9]+)" id="[^"#0-9]*?([0-9]+)" title="([^"]*?)">\[?([0-9]+)\]?<\/a><\/sup>/is', 
			'<sup id="fnb$2-ref"><a class="footnote-link" href="$1#fnb$2"><span class="wb-invisible">Note de bas de page </span>$2</a></sup>', 
			$this->code);
			$this->code = ReTidy::preg_replace_first('/<dt>(.*?)<\/dt>\s*<dd id="fnb/is', '<div class="wet-boew-footnotes" role="note">
<section><h2 id="fnb" class="wb-invisible">Notes de bas de page</h2>
<dl>
<dt>$1</dt>
<dd id="fnb', $this->code);
		} else {
			$this->code = preg_replace(
			'/<dt>Note de bas de page ([0-9]+)<\/dt>\s*<dd id="fnb$1">\s*(.*?)\s*<p class="footnote-return"><a href="#fnb$1-ref"><span class="wb-invisible">Retour à la référence de la note de bas de page <\/span>$1<\/a><\/p>\s*<\/dd>/is', 
			'<dt>Footnote $1</dt>
<dd id="fnb$1">
	$2
	<p class="footnote-return"><a href="#fnb$1-ref"><span class="wb-invisible">Return to footnote </span>$1<span class="wb-invisible"> referrer</span></a></p>
</dd>', 
			$this->code);
			$this->code = preg_replace(
			'/<(li|p)><a href="([^"#]*?)#[^"#0-9]*?([0-9]+)" id="[^"#0-9]*?([0-9]+)" title="([^"]*?)">\[?([0-9]+)\]?<\/a>\s*(' . $this->nonBreakingSpaceRegex . ')?\s*(.*?)<\/\1>/is', 
			'<dt>Footnote $3</dt>
<dd id="fnb$3">
<p>$8</p>
<p class="footnote-return"><a href="#fnb$3-ref"><span class="wb-invisible">Return to footnote </span>$3<span class="wb-invisible"> referrer</span></a></p>
</dd>', 
			$this->code);
			$this->code = preg_replace(
			'/<sup id="fnb([0-9]+)-ref"><a class="footnote-link" href="#fnb\1"><span class="wb-invisible">Note de bas de page <\/span>\1<\/a><\/sup>/is', 
			'<sup id="fnb$1-ref"><a class="footnote-link" href="#fnb$1"><span class="wb-invisible">Footnote </span>$1</a></sup>', 
			$this->code);
			$this->code = preg_replace(
			'/<sup><a href="([^"#]*?)#[^"#0-9]*?([0-9]+)" id="[^"#0-9]*?([0-9]+)" title="([^"]*?)">\[?([0-9]+)\]?<\/a><\/sup>/is', 
			'<sup id="fnb$2-ref"><a class="footnote-link" href="#fnb$2"><span class="wb-invisible">Footnote </span>$2</a></sup>', 
			$this->code);
			$this->code = ReTidy::preg_replace_first('/<dt>(.*?)<\/dt>\s*<dd id="fnb/is', '<div class="wet-boew-footnotes" role="note">
<section><h2 id="fnb" class="wb-invisible">Footnotes</h2>
<dl>
<dt>$1</dt>
<dd id="fnb', $this->code);
		}
		preg_match_all('/<p class="footnote-return">(.*?)<\/dd>/is', $this->code, $possible_end_footnote_section_matches);
		$end_footnotes_section_code = $possible_end_footnote_section_matches[0][sizeof($possible_end_footnote_section_matches[0]) - 1];
		$this->code = str_replace($end_footnotes_section_code, $end_footnotes_section_code . '
</dl></section>
</div>', $this->code);
		
		$this->code = preg_replace('/<[uo]l[^<>]*?>\s*<div class="wet-boew-footnotes" role="note">/is', '<div class="wet-boew-footnotes" role="note">', $this->code);
		$this->code = preg_replace('/<p class="footnote-return">(.*?)<\/p>\s*<\/dd>\s*<\/dl><\/section>\s*<\/div>\s*<\/[uo]l>/is', '<p class="footnote-return">$1</p>
</dd>
</dl></section>
</div>', $this->code);
		$counter1 = -1;
		while($counter1 !== 0) {
			$this->code = preg_replace('/<p class="footnote-return">(.*?)<\/p>\s*<\/dd>\s*<\/dl>\s*<\/section>\s*<\/div>\s*<\/dl>\s*<\/section>\s*<\/div>/is', '<p class="footnote-return">$1</p>
</dd>
</dl></section>
</div>', $this->code, -1, $counter1);
		}
		$counter2 = -1;
		while($counter2 !== 0) {
			$this->code = preg_replace('/<div class="wet-boew-footnotes" role="note">\s*<section>\s*<h2 id="fnb" class="wb-invisible">Notes de bas de page<\/h2>\s*<dl>\s*<div class="wet-boew-footnotes" role="note">\s*<section>\s*<h2 id="fnb" class="wb-invisible">Notes de bas de page<\/h2>\s*<dl>/is', '<div class="wet-boew-footnotes" role="note">
<section><h2 id="fnb" class="wb-invisible">Notes de bas de page</h2>
<dl>', $this->code, -1, $counter2);
		}
		$counter3 = -1;
		while($counter3 !== 0) {
			$this->code = preg_replace('/<div class="wet-boew-footnotes" role="note">\s*<section>\s*<h2 id="fnb" class="wb-invisible">Footnotes<\/h2>\s*<dl>\s*<div class="wet-boew-footnotes" role="note">\s*<section>\s*<h2 id="fnb" class="wb-invisible">Footnotes<\/h2>\s*<dl>/is', '<div class="wet-boew-footnotes" role="note">
<section><h2 id="fnb" class="wb-invisible">Footnotes</h2>
<dl>', $this->code, -1, $counter3);
		}
		$this->code = preg_replace('/<hr \/>\s*<div class="wet-boew-footnotes" role="note">/is', '<div class="wet-boew-footnotes" role="note">', $this->code);
	}
	
	function extra_style_attributes() {
		$cleanup_count = -1;
		while($cleanup_count !== 0) {
			$this->code = preg_replace('/(<[^<>]*? style=")([^"]*?)("[^<>]*?) style="([^"]*?)"/is', '$1$2;$4$3', $this->code, -1, $cleanup_count);
		}
		$this->code = str_replace(' style=""', '', $this->code);
	}
	
	function extra_class_attributes() {
		$cleanup_count = -1;
		while($cleanup_count !== 0) {
			$this->code = preg_replace('/(<[^<>]*? class=")([^"]*?)("[^<>]*?) class="([^"]*?)"/is', '$1$2 $4$3', $this->code, -1, $cleanup_count);
		}
		$this->code = str_replace(' class=""', '', $this->code);
	}
	
	function CED_function_2() {
		$this->code = preg_replace('/<p>((For further information,)|(For more details,)|(For more information,))(.*?)<\/p>\s*<ul>\s*<li><a href="[^"]*?">(.*?)<\/a>\s*<\/li>\s*<\/ul>/is', '', $this->code, -1, $count1);
		$this->logMsgIf("english further informations cleaned", $count1);
		$this->code = preg_replace('/<p>((Pour plus de détails,)|(Pour plus de précisions,)|(Pour plus de précision,))(.*?)<\/p>\s*<ul>\s*<li><a href="[^"]*?">(.*?)<\/a>\s*<\/li>\s*<\/ul>/is', '', $this->code, -1, $count2);
		$this->logMsgIf("french further informations cleaned", $count2);
		$this->code = preg_replace('/<p>Last revised:(.*?)<br \/>\s*Date published:(.*?)<\/p>/is', '', $this->code, -1, $count4);
		$this->logMsgIf("english last reviseds removed", $count4);
		$this->code = preg_replace('/<p>Dernière révision&nbsp;:(.*?)<br \/>\s*Date de publication&nbsp;:(.*?)<\/p>/is', '', $this->code, -1, $count5);
		$this->logMsgIf("french last reviseds removed", $count5);
		$this->code = preg_replace('/<hr[^<>]*?>/is', '', $this->code, -1, $count3);
		$this->logMsgIf("&lt;hr&gt;s removed", $count3);
		
		
		// mini quality assurance
		$array21 = array(
		'For further information',
		'For more details',
		'For more information',
		'Pour plus de détails',
		'Pour plus de précisions',
		'Pour plus de précision',
		'<hr',
		'Last revised',
		'Date published',
		'Dernière révision',
		'Date de publication',
		);
		foreach($array21 as $index => $value) {
			if(strpos($this->code, $value) !== false) {
				ReTidy::warning('Found ' . $value);
			}
		}
	}
	
	function CED_summary_tables() {
		preg_match('/<table[^<>]*?>\s*<caption[^<>]*?>(Summary|En résumé)<\/caption>(.*?)<\/table>/is', $this->code, $summary_table_matches);
		foreach($summary_table_matches as $index => $value) {
			var_dump($summary_table_matches[0]);exit(0);
		}
	}
	
	function CED() {
		$array_replaces = array(
		// search => replace
		//' style="border-collapse: collapse; border-spacing: 0;"' => ' class="table"',
		' style="white-space: nowrap;"' => ' class="noWrap"',
		' style="background-color: #7f7f7f"' => ' class="lightgreyBG"',
		'<span style="text-decoration:underline;">' => '<span style="stripme" newtag="strong">',
		'#tphp' => '#cn-tphp',
		//'<a id="cont">' => '',
		//'</a></h1>' => '</h1>', // messes up institutional links....................
		);
		foreach($array_replaces as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $count);
			$this->logMsgIf("CED[" . htmlentities($search) . "]", $count);
		}
		
		$array_rxp = array(
		// search => replace
		' style="mso\-[^"]*?"' => '',
		' cellspacing="?[^"]*?"?' => '',
		' cellpadding="?0"?' => '',
		' cellpadding="?[^"]*?"?' => ' class="altTable"',
		);
		foreach($array_rxp as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, $count);
			$this->logMsgIf("CED[" . htmlentities($search) . "]", $count);
		}
		
		// necessary clean-up
		ReTidy::extra_class_attributes();
		return true;
	}
	
	function HTML5_headerify_pre($pre) {
		$ancestryArray = OM::getAncestryArray($pre, strlen($pre));
		$header_string = substr($pre, $ancestryArray[sizeof($ancestryArray) - 1][2] + strlen($ancestryArray[sizeof($ancestryArray) - 1][1]));
		if(strlen(ReTidy::trim_nbsp($header_string)) > 0) {
			$headerified_pre = substr($pre, 0, $ancestryArray[sizeof($ancestryArray) - 1][2] + strlen($ancestryArray[sizeof($ancestryArray) - 1][1])) . '
<header>' . $header_string . '</header>
';
		} else {
			$headerified_pre = substr($pre, 0, $ancestryArray[sizeof($ancestryArray) - 1][2] + strlen($ancestryArray[sizeof($ancestryArray) - 1][1])) . '
';
		}
		return $headerified_pre;
	}
	
	function HTML5_footerify_post($post) {
		$reverseAncestryArray = OM::getReverseAncestryArray($post, 0);
		$footer_string = substr($post, 0, $reverseAncestryArray[0][2]);
		if(strlen(ReTidy::trim_nbsp($footer_string)) > 0) {
		$footerified_post = '
<footer>' . $footer_string . '
</footer>' . substr($post, $reverseAncestryArray[0][2]);
		} else {
			$footerified_post = substr($post, $reverseAncestryArray[0][2]);
		}
		return $footerified_post;
	}
	
	function get_pre($string, $offset = false) {
		//print('string in pre: ');var_dump($string);
		if($offset === false) {
			$offset = strlen($string);
		}
		$pre_code = substr($string, 0, $offset);
		$ancestryArray = OM::getAncestryArray($pre_code, strlen($pre_code));
		if(sizeof($ancestryArray) > 0) {
			//print('here834954950<br>');
			$pre = substr($pre_code, 0, $ancestryArray[sizeof($ancestryArray) - 1][2] + strlen($ancestryArray[sizeof($ancestryArray) - 1][1]));
			return $pre;
		} else {
			//print('here834954951<br>');
			// get the code up to the first tag
			preg_match('/(.*?)<\w/is', $string, $pre_first_tag_matches);
			$pre_first_tag = $pre_first_tag_matches[1];
			return $pre_first_tag;
			//return "";
		}
	}
	
	function get_post($string, $offset = 0) {
		$post_code = substr($string, $offset);
		$reverseAncestryArray = OM::getReverseAncestryArray($post_code, 0);
		//var_dump($reverseAncestryArray);exit(0);
		if(sizeof($reverseAncestryArray) > 0) {
			$post = substr($post_code, $reverseAncestryArray[0][2]);
			return $post;
		} else {
		//	// get the code after the last tag
		//	preg_match('/(.*?)>\w/is', strrev($string), $post_last_tag_matches);
		//	$post_last_tag = strrev($post_last_tag_matches[1]);
		//	return $post_last_tag;
			return "";
		}
	}
	
	//protected function build_page_from_structure_arrays($content_only = false) {
	protected function build_page_from_structure_arrays() {
		//print("this->TOCStructureArray build: ");var_dump($this->TOCStructureArray);
		//print("this->pageStructureArray build: ");var_dump($this->pageStructureArray);exit(0);
		//print("425845904590");exit(0);
		//if($content_only) {
		//if(true) {
			$contentArray = ReTidy::getContentArray($this->code);
			$initial_string = $contentArray[0];
			$strpos = strpos($this->code, $initial_string);
			$pre_initial_string = substr($this->code, 0, $strpos);
			$post_initial_string = substr($this->code, $strpos + strlen($initial_string));
			//print('$pre_initial_string: ' . $pre_initial_string);
			//print('$initial_string: ' . $initial_string);
			//print('$post_initial_string: ' . $post_initial_string);
		//} else {
		//	$initial_string = ReTidy::getBodyCode($this->code);
		//}
		//print("425845904591");exit(0);
		//print('$initial_string 2: ' . $initial_string);
		if($this->config['TOC_sub'] === 'CED') {
			$initial_string = str_replace($this->CED_top_page_string, '', $initial_string);
		}
		//print("425845904592");exit(0);
		//print('$initial_string 2.5: ' . $initial_string);
		$initial_string = ReTidy::strip_space_nbsp(ReTidy::tagless($initial_string));
		//print('$initial_string 3: ' . $initial_string);
		$structured_string = "";
		if(sizeof($this->pageStructureArray) === 0 || $this->pageStructureArray === false) {
			return false;
		}
		//print("425845904593");exit(0);
		foreach($this->pageStructureArray as $index => $value) {
			$structured_string_part = $value[1];
			if($this->config['TOC_sub'] === 'CED') {
				$structured_string_part = str_replace($this->CED_top_page_string, '', $structured_string_part);
			}
			if($value[0] === "TOC") {
				if($this->created_TOC) {
					// adding nothing will keep the string the same length as the initial
				} elseif($this->generated_TOC) {
					// we need to remove the table of contents from the initial_string to keep the strings the same length
					$initial_string = str_replace(ReTidy::strip_space_nbsp(ReTidy::tagless($this->pre_generation_TOC_string)), '', $initial_string);
				} else {
					foreach($this->TOCStructureArray as $TOC_index => $TOC_value) {
						$structured_string .= ReTidy::strip_space_nbsp(ReTidy::tagless($TOC_value[1]));
					}
				}
			} else {
				$structured_string .= ReTidy::strip_space_nbsp(ReTidy::tagless($structured_string_part));
			}
		}
		//print("425845904594");exit(0);
		$initial_length = strlen($initial_string);
		//print('$initial_string 4: ' . $initial_string);
		$structured_length = strlen($structured_string);
		/*if($initial_length != $structured_length) {
			print("initial length does not equal structured length (this check exists so that we do not lose content by using the structure function).");
			print("initial___ length: ");var_dump($initial_length);
			print("structured length: ");var_dump($structured_length);
			print("<br>\r\n<br>\r\n<br>\r\n");
			print("initial___ string: " . $initial_string);
			print("<br>\r\n<br>\r\n<br>\r\n");
			print("structured string: " . $structured_string);
			exit(0);
		}*/
		//print("425845904595");exit(0);
		// notice that the preceding check does not prevent any errors occurant from the following code...
		//if($content_only) {
		//if(true) {
			$this->code = $pre_initial_string;
		/*} else {
			$initial_code = $this->code;
			preg_match('/<body[^<>]*?>/is', $this->code, $open_body_matches, PREG_OFFSET_CAPTURE);
			$position_of_end_of_open_body = $open_body_matches[0][1] + strlen($open_body_matches[0][0]);
			$this->code = substr($this->code, 0, $position_of_end_of_open_body);
		}*/
		//print('$this->TOCStructureArray354635634: ');var_dump($this->TOCStructureArray);
		//print('$this->pageStructureArray354635634: ');var_dump($this->pageStructureArray);
		if($this->config['HTML5'] === 'HTML5' || $this->config['HTML5'] === true) {
			$section_tags_applied = 0;
			foreach($this->pageStructureArray as $index => $value) {
				$level = $value[0];
				//print('structure piece: ');var_dump($value[1]);
				if($level === "TOC") {
					//if($this->config['trust_headings'] !== true) {
						if(sizeof($this->TOCStructureArray) > 0) {
							$toc_string = "";
							foreach($this->TOCStructureArray as $TOC_index => $TOC_value) {
								$toc_string .= $TOC_value[1] . '
';
							}
							$section_tags_applied++;
							$this->code .= '<section>
' . $toc_string . '</section>
';
						}
					//} else {
					//	$section_tags_applied++;
					//	$this->code .= '<section>
//' . $value[1] . '</section>
//';
					//}
				} else {
					if($this->pageStructureArray[$index + 1][0] === "post") { // last one
						//print('her39589560969-067<br>');
						//print('$this->pageStructureArray[$index + 1]: ');var_dump($this->pageStructureArray[$index + 1]);
						//print('$level: ');var_dump($level);
						$section_tags_applied++;
						$this->code .= '<section>
' . $value[1] . '</section>
';
						//print("46<br>");exit(0);
						while($level > 2) {
							//print('her39589560969-068<br>');
							$this->code .= '</section>
';
							$level--;
						}
						//print($this->code);exit(0);
					} elseif(preg_match('/[^\s]/is', $value[1]) === 1) { // if there is something other than space
						//print('something other than space<br>');
						if($level === "pre") { // then do some fancy thing that applies the <header> tag that does not break the nesting of tags
							$tagless = ReTidy::tagless($value[1]);
							if(preg_match('/[^\s]/is', $tagless) === 1) { // if there is something other than space
								$this->code .= ReTidy::HTML5_headerify_pre($value[1]);
							} else {
								$this->code .= $value[1] . '
';
							}
						} elseif($level === "post") {
							$tagless = ReTidy::tagless($value[1]);
							if(preg_match('/[^\s]/is', $tagless) === 1) { // if there is something other than space
								$this->code .= ReTidy::HTML5_footerify_post($value[1]);
							} else {
								$this->code .= $value[1];
							}
						} else {
							if($level == 1) {
								//print('The HTML5 h1<br>');
								// do not put a <section> tag on the <h1>
								$this->code .= $value[1];
							} else {
								//print('HTML5 non-h1<br>');
								$next_level = $this->pageStructureArray[$index + 1][0];
								if($next_level === "TOC") {
									$section_tags_applied++;
									$this->code .= '<section>
' . $value[1];
									while($level > 1) {
										$this->code .= '</section>
';
										$level--;
									}
								} elseif(strpos($level, "tab") === 0 || strpos($level, "fig") === 0) {
									// if it is a table or figure; since a table or figure is already in a section, only apply a </section> tag if the next section is numeric
									$this->code .= $value[1];
									if(is_numeric($next_level) && $previous_numeric_level >= $next_level) {
										//print("45");exit(0);
										while($previous_numeric_level > $next_level) {
											//print("previous_numeric_level: ");var_dump($previous_numeric_level);
											//print("next_level: ");var_dump($next_level);print("<br>\r\n");
											$this->code .= '</section>
';
											$previous_numeric_level--;
										}
										$this->code .= '</section>
';
									}
								} else {
									$section_tags_applied++;
									$this->code .= '<section>
' . $value[1];
									//var_dump(is_numeric("389045"));
									//var_dump(is_numeric("38afafa9045"));
									//var_dump(is_numeric("tab_4_21"));
									//var_dump(is_numeric("ajnka"));
									//exit(0);
									if(is_numeric($level)) {
										if(is_numeric($next_level)) {
											if($level > $next_level) {
												$this->code .= '</section>
';
												//print("47");exit(0);
												while($level > $next_level) {
													$this->code .= '</section>
';
													$next_level++;
												}
											} elseif($level < $next_level) {

											} else {
												$this->code .= '</section>
';
											}
										}
									} else {
										// do we need this else? apparently yes; for ? (levelless sections)
										$this->code .= '</section>
';
									}
								}
							}
						}
					}
				}
				$previous_level = $level;
				if(is_numeric($level)) {
					$previous_numeric_level = $level;
				}
			}
		} else {
			foreach($this->pageStructureArray as $index => $value) {
				//if(preg_match('/[^\s]/is', $value[1]) === 1) { // if there is something other than space
					//if($value[0] === "TOC" && $this->config['trust_headings'] !== true) {
					if($value[0] === "TOC") {
						$toc_string = "";
						foreach($this->TOCStructureArray as $TOC_index => $TOC_value) {
							$toc_string .= $TOC_value[1] . '
';
						}
						$this->code .= $toc_string;
					} else {
						$this->code .= $value[1];
					}
				//}
			}
		}
		//print('$this->code: ' . $this->code);exit(0);
		// more hacks since page $this->pageStructureArray is not as useful as tidyer_DOM
		$post_content_pre_end_body = substr($post_initial_string, 0, strpos($post_initial_string, '</body>'));
		//if($content_only) {
			//$this->code .= $post_initial_string;
			$this->code .= substr($post_initial_string, strlen($post_content_pre_end_body));
		//} else {
		//	$this->code .= substr($initial_code, strpos($initial_code, "</body>"));
		//}
		// definately a hack
		$count = -1;
		while($count != 0) {
			// still more hacks since page $this->pageStructureArray is not as useful as tidyer_DOM
			$this->code = preg_replace('/<\/div>\s*<\/div>\s*<\/div>\s*<\/section>\s*<\/body>/is', '</section>
</div>
</div>
</div>
</body>', $this->code, -1, $count2);
			$this->code = preg_replace('/<!-- InstanceEndEditable -->\s*<\/section>/is', '</section>
<!-- InstanceEndEditable -->', $this->code, -1, $count2);
			$this->code = preg_replace('/<!-- clf2-nsi2 theme ends \/ Fin du thème clf2-nsi2 -->\s*<\/section>/is', '</section>
<!-- clf2-nsi2 theme ends / Fin du thème clf2-nsi2 -->', $this->code, -1, $count1);
			$count = $count1 + $count2;
			//print('count: ' . $count . '<br>');
		}
		// for manual marking to work with the sweeper program
		$this->code = str_replace(' class="sweeper-not-indexical"', '', $this->code);
		$this->logMsgIf('&lt;section&gt; tags applied', $section_tags_applied);
		//print('$this->code: ' . $this->code);exit(0);
		return true;
	}

	protected function CED_TOC() {
		// table of contents
		preg_match_all('/(<[^<>]*>\s*((TABLE OF CONTENTS)|(Table des matières)|(Table des mati&egrave;res)|(TABLE DES MATIÈRES)|(TABLE DES MATI&Egrave;RES))\s*<[^<>]*>(.*?))((<img )|(<h2)|(<p><strong>\s*1\. INTRODUCTION)|(<table))/is', $this->code, $matches);
		//preg_match_all('/TABLE DES MATIÈRES/is', $this->code, $matches);		//GAH!!!
		//var_dump($matches);exit(0);
		$toc_string_temp = $matches[1][0];
		//var_dump($toc_string_temp);exit(0);
		preg_match_all('/.*<\/p>/is', $toc_string_temp, $matches);
		$initial_toc_string = $toc_string = $matches[0][0];
		//var_dump($initial_toc_string);exit(0);
		if($this->language === "english") {
			$toc_string = preg_replace('/<.*>\s*(TABLE OF CONTENTS)\s*<.*>/i', '<h2>Table of Contents</h2>', $toc_string);
		}
		if($this->language === "french") {
			$toc_string = preg_replace('/<.*>\s*(Table des matières)\s*<.*>/is', '<h2>Table des matières</h2>', $toc_string);
			$toc_string = preg_replace('/<.*>\s*(Table des mati&egrave;res)\s*<.*>/is', '<h2>Table des mati&egrave;res</h2>', $toc_string);			
		}
		
		$toc_string = preg_replace('/<p[^<>]*>([0-9]{1,}\.[0-9]{1,}\.[0-9]{1,})(\.)*\s{1,}(.*?)<\/p>/is', '<div class="row indent3">
<div class="numero-list">$1$2</div>
<div class="text-list menu"><a href="#">$3</a></div>
</div>', $toc_string);
		$toc_string = preg_replace('/<p[^<>]*>([0-9]{1,}\.[0-9]{1,})(\.)*\s{1,}(.*?)<\/p>/is', '<div class="row indent2">
<div class="numero-list">$1$2</div>
<div class="text-list menu"><a href="#">$3</a></div>
</div>', $toc_string);
		$toc_string = preg_replace('/<p[^<>]*>([0-9]{1,})(\.)*(0)*\s{1,}(.*?)<\/p>/is', '<div class="row indent1">
<div class="numero-list">$1$2$3</div>
<div class="text-list titre_section menu"><a href="#">$4</a></div>
</div>', $toc_string);
/*
		$toc_string = preg_replace('/<p[^<>]*>(Appendix|Table|Figure)\s{1,}([0-9]{1,}\.[0-9]{1,}\.[0-9]{1,})(\.)*\s{1,}(.*?)<\/p>/is', '<div class="row indent3">
<div class="numero-list">$1$ 2$3</div>
<div class="text-list menu"><a href="#">$4</a></div>
</div>', $toc_string);
		$toc_string = preg_replace('/<p[^<>]*>(Appendix|Table|Figure)\s{1,}([0-9]{1,}\.[0-9]{1,})(\.)*\s{1,}(.*?)<\/p>/is', '<div class="row indent2">
<div class="numero-list">$1 $2$3</div>
<div class="text-list menu"><a href="#">$4</a></div>
</div>', $toc_string);
		$toc_string = preg_replace('/<p[^<>]*>(Appendix|Table|Figure)\s{1,}([0-9]{1,})(\.)*(0)*\s{1,}(.*?)<\/p>/is', '<div class="row indent1">
<div class="numero-list">$1 $2$3$4</div>
<div class="text-list titre_section menu"><a href="#">$5</a></div>
</div>', $toc_string);*/
		$toc_string = preg_replace('/<p[^<>]*>(Appendix|Table|Figure)\s{1,}([0-9\.\-]*)\s*(.*?)<\/p>/is', '<div class="row indent1">
<div class="numero-list">$1 $2</div>
<div class="text-list titre_section menu"><a href="#">$3</a></div>
</div>', $toc_string);

		$toc_string = preg_replace('/<p[^<>]*>([^:]*:)\s{1,}(.*?)<\/p>/is', '<div class="row indent1">
<div class="numero-list">$1</div>
<div class="text-list titre_section menu"><a href="#">$2</a></div>
</div>', $toc_string);
		$toc_string = preg_replace('/<p[^<>]*>(.*?)<\/p>/is', '<div class="text-list titre_section menu"><a href="#">$1</a></div>', $toc_string);
		
		// now create links
		preg_match_all('/<div class="[^"]*"><a href="#">(.*?)<\/a><\/div>/is', $toc_string, $matches);
		//$page_counter = $sub_section_counter = $sub_sub_section_counter = 0;
		$page_counter = 0;		
		if(false){
		foreach($matches[0] as $index => $match) {
			preg_match_all('/<div class="([^"]*)">\s*<div class="numero-list">(.*?)<\/div>\s*' . str_replace('/', '\/', $match) . '/is', $toc_string, $matches2);
			var_dump($matches2[1][0]);print("<br>\r\n");
			if($matches2[1][0] === "row indent1") {
				$page_counter++;
				preg_match_all('/([0-9]{1,})(\.)*(0)*/is', $matches2[2][0], $number_matches);
				$first_number = $number_matches[1][0];
				$toc_string = str_replace($match, '<div class="text-list titre_section menu"><a href="page' . $page_counter . '.html#chp' . $first_number . '">' . $matches2[4][0] . '</a></div>', $toc_string);
				continue;
			}
			if($matches2[1][0] === "row indent2") {
				preg_match_all('/([0-9]{1,})\.([0-9]{1,})(\.)*/is', $matches2[2][0], $number_matches);
				$first_number = $number_matches[1][0];
				$second_number = $number_matches[2][0];
				$toc_string = str_replace($match, '<div class="text-list menu"><a href="page' . $page_counter . '.html#chp' . $first_number . '_' . $second_number . '">' . $matches2[4][0] . '</a></div>', $toc_string);				
				continue;				
			}
			if($matches2[1][0] === "row indent3") {
				preg_match_all('/([0-9]{1,})\.([0-9]{1,})\.([0-9]{1,})(\.)/is', $matches2[2][0], $number_matches);
				$first_number = $number_matches[1][0];
				$second_number = $number_matches[2][0];
				$third_number = $number_matches[3][0];
				$toc_string = str_replace($match, '<div class="text-list menu"><a href="page' . $page_counter . '.html#chp' . $first_number . '_' . $second_number . '_' . $third_number . '">' . $matches2[4][0] . '</a></div>', $toc_string);				
				continue;				
			}
			print("<h1>got to here</h1>");
			$page_counter++;
			$toc_string = str_replace($match, '<div class="text-list titre_section menu"><a href="page' . $page_counter . '.html#">' . $matches[1][$index] . '</a></div>', $toc_string);
		}
		}
		
		//$toc_string = preg_replace('/<p[^<>]*>/is', '<div>', $toc_string);
		//$toc_string = str_replace('</p>', '</div>', $toc_string);		
		//var_dump($toc_string);
		//exit(0);
		$this->code = str_replace($initial_toc_string, $toc_string, $this->code);
	}

	protected function CEDRep () {
		if(!is_array($this->config['CEDRep'])) return false;
		foreach($this->config['CEDRep'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("CEDRep[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("CEDRep", $ct);
		return true;
	}
	
	protected function INAC1149Rep () {
		if(!is_array($this->config['INAC1149Rep'])) return false;
		foreach($this->config['INAC1149Rep'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("INAC1149Rep[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INAC1149Rep", $ct);
		return true;
	}

	protected function INAC1157Rep () {
		if(!is_array($this->config['INAC1157Rep'])) return false;
		foreach($this->config['INAC1157Rep'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("INAC1157Rep[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INAC1157Rep", $ct);
		return true;
	}		
	
	protected function INACRxp () {
		if(!is_array($this->config['INACRxp'])) return false;
		$c = $ct = 0;
		foreach($this->config['INACRxp'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("INACRxp[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INACRxp", $ct);
		return true;
	}

	protected function CEDPre () {
		if(!is_array($this->config['CEDPre'])) return false;
		
		// first remove existing acronym tags
		$ct_ar = 0;
		if (strpos($this->code, "<acronym") != false) {
			$this->code = preg_replace('/<acronym title="[^"]*">([^<]*)<\/acronym>/is', '$1', $this->code, -1, $ct_ar);
		}
		$this->logMsg("acronyms removed $ct_ar ");
		
		$c = $ct = 0;
		preg_match_all("/(<[A-Z][A-Za-z]*)/", $this->code, $matches);		
		foreach($matches[1] as $index => $match) {
			$this->code = str_replace($match, strtolower($match), $this->code);
		}

		preg_match_all("/(<\/[A-Z][A-Za-z]*)/", $this->code, $matches);		
		foreach($matches[1] as $index => $match) {
			$this->code = str_replace($match, strtolower($match), $this->code);
		}

		
		foreach($this->config['CEDPre'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/s", $replace, $this->code, -1, $c);
			$this->logMsgIf("CEDPre[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("CEDPre", $ct);
		return true;
	}	
	
	protected function CEDRxp () {
		if(!is_array($this->config['CEDRxp'])) return false;
		$c = $ct = 0;
		foreach($this->config['CEDRxp'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("CEDRxp[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("CEDRxp", $ct);
		return true;
	}	
	
	protected function INAC1149Rxp () {
		if(!is_array($this->config['INAC1149Rxp'])) {
			return false;
		}
		$c = $ct = 0;
		foreach($this->config['INAC1149Rxp'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("INAC1149Rxp[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INAC1149Rxp", $ct);
		return true;
	}
	
	protected function removeCommentsInStyleTags () {
		$this->code = preg_replace('/<style>([^<>]*)<!\-\-([^<>]*)<\/style>/', '<style>$1$2<\/style>', $this->code);
		$this->code = preg_replace('/<style>([^<>]*)\-\->([^<>]*)<\/style>/', '<style>$1$2<\/style>', $this->code);		
		return true;
	}		

	protected function INAC1157Rxp () {
		if(!is_array($this->config['INAC1157Rxp'])) {
			return false;
		}
		$c = $ct = 0;
		foreach($this->config['INAC1157Rxp'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("INAC1157Rxp[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INAC1157Rxp", $ct);
		return true;
	}		
	
	protected function INACRep2 () {
		if(!is_array($this->config['INACRep2'])) return false;
		$c = $ct = 0;
		foreach($this->config['INACRep2'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("INACRep2[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INACRep2", $ct);
		return true;
	}
	
	protected function INAC1149Rep2 () {
		if(!is_array($this->config['INAC1149Rep2'])) return false;
		$c = $ct = 0;
		foreach($this->config['INAC1149Rep2'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("INAC1149Rep2[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INAC1149Rep2", $ct);
		return true;
	}
	
	protected function INAC1157Rep2 () {
		if(!is_array($this->config['INAC1157Rep2'])) return false;
		$c = $ct = 0;
		foreach($this->config['INAC1157Rep2'] as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("INAC1157Rep2[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INAC1157Rep2", $ct);
		return true;
	}		

	protected function INACRxp2 () {
		if(!is_array($this->config['INACRxp2'])) return false;
		$c = $ct = 0;
		foreach($this->config['INACRxp2'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("INACRxp2[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INACRxp2", $ct);
		return true;
	}	

	protected function INAC1149Rxp2 () {
		if(!is_array($this->config['INAC1149Rxp2'])) return false;
		$c = $ct = 0;
		foreach($this->config['INAC1149Rxp2'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("INAC1149Rxp2[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INAC1149Rxp2", $ct);
		return true;
	}			

	protected function INAC1157Rxp2 () {
		if(!is_array($this->config['INAC1157Rxp2'])) return false;
		$c = $ct = 0;
		foreach($this->config['INAC1157Rxp2'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("INAC1157Rxp2[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("INAC1157Rxp2", $ct);
		return true;
	}	
	
	protected function ol_start_to_javascript () {
		$ol_restart_counter = $ct = 0;
		$done_one = false;
		preg_match_all('/<ol([^<>]*) start="([^"]*)"([^<>]*)>/is', $this->code, $ol_start_matches);
		foreach($ol_start_matches[0] as $index => $ol_start_match) {
			$ol_restart_counter++;
			$replaced_ol_with_start = str_replace(' start="' . $ol_start_matches[2][$index] . '"', ' id="restart' . $ol_restart_counter . '"', $ol_start_match);
			$this->code = str_replaceFirst($ol_start_match, $replaced_ol_with_start, $this->code);
			if(!$done_one) {
				$done_one = true;
				$this->code = str_replace('</head>', '<script type="text/javascript">
function renumberOrderedLists() {
document.getElementById("restart' . $ol_restart_counter . '").setAttribute("start","' . $ol_start_matches[2][$index] . '")
}
window.onload = renumberOrderedLists;
</script>
</head>', $this->code);
			} else {
				$this->code = preg_replace('/}\s*window\.onload = renumberOrderedLists;/', 'document.getElementById("restart' . $ol_restart_counter . '").setAttribute("start","' . $ol_start_matches[2][$index] . '")
}
window.onload = renumberOrderedLists;', $this->code);
			}
			$ct++;			
		}
		$this->logMsgIf("ol_start_to_javascript", $ct);		
		return true;		
	}

	protected function fix_duplicated_attributes () {		
		$c = $d = $ct = 0;
		$this->code = preg_replace(
		'/<([^<>]*) class="([^"]*)"([^<>]*) class="([^"]*)"([^<>]*)>/s', 
		'<$1 class="$2 $4"$3$5>',
		$this->code, 
		-1, $c);
		// this next does not deal with missing semi-colons
		$this->code = preg_replace(
		'/<([^<>]*) style="([^"]*)"([^<>]*) style="([^"]*)"([^<>]*)>/s', 
		'<$1 style="$2 $4"$3$5>',
		$this->code, 
		-1, $d);
		$ct = $c + $d;
		$this->logMsgIf("fix_duplicated_attributes", $ct);
	}

	protected function DOM_fix_duplicated_attributes () {
		// tidy might try to keep the last attribute so this and post_DOM_stripme should be run before tidy
		$query = '//*[@class]';
		$NodesWithClass = $this->xpath->query($query);
		if(!$NodesWithClass || !$NodesWithClass->length) {
			print("Did not find &lt;* class=\"\"&gt; (DOM_fix_duplicated_attributes)<br>\r\n");		
			return false;	
		}
		foreach($NodesWithClass as $NodeWithClass) {
			$found_first_one = false;
			foreach($NodeWithClass->attributes as $attribute) {
				if($found_first_one === false && $attribute->nodeName === "class") {
					$first_class = $attribute;
					$found_first_one === true;
				}
				if($found_first_one === true && $attribute->nodeName === "class") {
					$first_class->nodeValue .= " " . $attribute->nodeValue;
					$attribute->nodeValue = "XXX9o9stripme9o9XXX";
				}
			}
		}
		$query = '//*[@style]';
		$NodesWithStyle = $this->xpath->query($query);
		if(!$NodesWithStyle || !$NodesWithStyle->length) {
			print("Did not find &lt;* style=\"\"&gt; (DOM_fix_duplicated_attributes)<br>\r\n");		
			return false;	
		}
		foreach($NodesWithStyle as $NodeWithStyle) {
			$found_first_one = false;
			foreach($NodeWithStyle->attributes as $attribute) {
				if($found_first_one === false && $attribute->nodeName === "style") {
					$first_style = $attribute;
					$found_first_one === true;
				}
				if($found_first_one === true && $attribute->nodeName === "style") {
					if(substr(trim($first_style->nodeValue), strlen(trim($first_style->nodeValue))-1) !== ";") {
						$first_style->nodeValue .= "; " . $attribute->nodeValue;
					} else {
						$first_style->nodeValue .= " " . $attribute->nodeValue;
					}
					$attribute->nodeValue = "XXX9o9stripme9o9XXX";
				}
			}
		}		
	}
	
	protected function rec_DOM_getStyleCode($node, $styleCode) {
		if($node->nodeName === "link") { 
			// then this may link to an external stylesheet
			// only call the link a stylesheet if type="text/css" is found even though pages that are presumably invalid (by not marking 
			// their stylesheet references using <link> tags with this attribute) may therefore be missing style information
			$this_refers_to_a_stylesheet = false;
			foreach($node->attributes as $attribute) {
				if($attribute->nodeName === "type" && $attribute->nodeValue === "text/css") {
					$this_refers_to_a_stylesheet = true;
					break;
				}
			}
			if($this_refers_to_a_stylesheet) {
				foreach($node->attributes as $attribute) {
					if($attribute->nodeName === "href") {
						// avoid references to the root of the drive so that sweeper is self-contained and has simpler code
						if(strpos($attribute->nodeValue, '/') === 0) { // root
							$locationOfFile = substr($attribute->nodeValue, 1); // attempt to bypass looking in the root
						} else {
							$locationOfFile = $attribute->nodeValue;
						}
						$contents = file_get_contents($locationOfFile);
						$styleCode .= "\r\n" . $contents;
						break;
					}
				}
			}
		//	foreach($node->attributes as $attribute) {
		//		if($attribute->nodeName === "href") {
		//			//$locationOfFile = substr($attribute->nodeValue, 1);
		//			// this would mess up internet references (by cheating and trying to ignore the initial foreward slash signalling to look
		//			// in the root
		//			if(preg_match('/\w{3,4}:\/\//is', $attribute->nodeValue)) { // http:// or ftp://
		//				print("external style code file: " . $attribute->nodeValue . "<br>\r\n");
		//				$locationOfFile = $attribute->nodeValue;
		//			} else {
		//				if(strpos($attribute->nodeValue, '/') === 0) { // root
		//					$locationOfFile = substr($attribute->nodeValue, 1); // attempt to bypass looking in the root
		//				} else {
		//					$locationOfFile = $attribute->nodeValue;
		//				}
		//			}
		//			//print("locationOfFile: ");var_dump($locationOfFile);
		//			$contents = file_get_contents($locationOfFile);
		//			$styleCode .= "\r\n" . $contents;
		//		}
		//	}
		}
		if($node->nodeName === "style") { 
			// then this could have style information and references to stylesheets
			// using the @import command.
			if($node->hasChildNodes()) {
				foreach($node->childNodes as $child) {
					if($child->nodeType === 3) {
						$styleCode .= "\r\n" . $child->nodeValue;
					}
					if($child->nodeType === 4) {
						$styleCode .= "\r\n" . $child->nodeValue;
					}
					if($child->nodeType === 8) {
						$styleCode .= "\r\n" . $child->nodeValue;
					}
				}
			}
		}
		if($node->nodeType === 5) {
			return $styleCode;		
		}
		if($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				$styleCode = ReTidy::rec_DOM_getStyleCode($item, $styleCode);
			}
		}
		return $styleCode;
	}
	
	protected function getStylesFromCode($code) {
		// separate selectors from style information
		preg_match_all('/([^\{\}]*)\s*\{\s*((@media[^\{]*\{)*[^\{\}]*\s*\}*)\}/', $code, $matches);
		// remove comments and extra spaces (including line breaks)
		$cleanedSelectors = array();
		$cleanedStyles = array();	
		foreach($matches[1] as $index => $match) {
			$match2 = $matches[2][$index];

			$match = ReTidy::cleanSelector($match);
			$match2 = ReTidy::cleanStyleInformation($match2);			

			if(strlen($match2) > 0) {
				$cleanedSelectors[] = $match;
				$cleanedStyles[] = $match2;		
			}
		}	
		$ArrayOfStyleInformation = array($cleanedSelectors, $cleanedStyles);
		return $ArrayOfStyleInformation;
	}
	
	protected function cleanStyles() {
		preg_match_all('/ style="([^"]+)"/is', $this->code, $style_matches);
		$style_matches[0] = array_unique($style_matches[0]);
		foreach($style_matches[0] as $index => $value) {
			if($style_matches[1][$index] !== "XXX9o9stripme9o9XXX" && $style_matches[1][$index] !== "stripme") {
				$this->code = str_replace($value, ' style="' . ReTidy::cleanStyle($style_matches[1][$index]) . '"', $this->code);
			}
		}
	}
	
	protected function DOM_cleanStyles() {
		$style_attributes = $this->xpath->query('//@style');
		foreach($style_attributes as $style_attribute) {
			$style_attribute->nodeValue = ReTidy::cleanStyle($style_attribute->nodeValue);
		}
	}	
	
	protected function clean_attribute_value_according_to_attribute_name_for_tidyer($attribute_value, $attribute_name) {
		if($attribute_name === 'class') {
			$attribute_value = preg_replace('/\s+/is', ' ', $attribute_value);
			$attribute_value = trim($attribute_value);
		} elseif($attribute_name === 'style') {
			$attribute_value = ReTidy::cleanStyle_for_tidyer($attribute_value);
		}
		return $attribute_value;
	}
	
	protected function cleanStyle_for_tidyer($string) {
		$string = str_replace('"', '&quot;', $string);
		return ReTidy::cleanStyleInformation($string);
	}
	
	protected function cleanStyle($string) {
		return ReTidy::cleanStyleInformation($string);
	}
	
	protected function cleanStyleInformation($string) {
		// HTML character entities cause problems because of their ampersands.
		$string = str_replace('&nbsp;', ' ', $string);
		$string = str_replace('&quot;', "'", $string);
		$string = ReTidy::decode_for_DOM_character_entities($string);
		/* // 2011-11-28
		preg_match_all('/&[\w#x0-9]+;/is', $string, $character_entity_matches);
		foreach($character_entity_matches[0] as $character_entity_match) {
			//$decoded = html_entity_decode($character_entity_match);
			if(strpos($decoded, ";") === false) {
				$string = str_replace($character_entity_match, $decoded, $string);
			} else { // then we still have a problem
				print("did not properly decode HTML character entity in style attribute4892589435: <br>\r\n");var_dump($decoded);print("<br>\r\n");var_dump($string);print("<br>\r\n");exit(0);
			}
		}*/
		$string = preg_replace('/\/\*.*\*\//s', '', $string);
		// the above could already be taken care of
		$string = preg_replace('/\s*;\s*/s', '; ', $string);
		$string = preg_replace('/\s*:\s*/s', ': ', $string);
		// pseudo-elements...
		$string = preg_replace('/\s*:\s*(\w*)\s*\{([^\{\}]*)\}/s', ' :$1 {$2};', $string);
		// we would probably like to force a format on things like media rules here also
		$string = preg_replace('/\r\n/', ' ', $string);
		$string = preg_replace('/\s+/', ' ', $string);
		$string = trim($string);
		$string = ReTidy::delete_empty_styles($string);
		$string = ReTidy::ensureStyleInformationBeginsProperly($string);
		$string = ReTidy::ensureStyleInformationEndsProperly($string);
		return $string;
	}
	
	protected function cleanSelector($string) {
		$string = preg_replace('/\/\*.*\*\//s', '', $string);
		// the above could already be taken care of
		$string = preg_replace('/\r\n/', ' ', $string);
		$string = preg_replace('/\s+/', ' ', $string);
		$string = trim($string);
		return $string;
	}	
	
	protected function inlineMediaRules($styleCode) {
		// we would need a DOM-like function to process media rule sections since when these are considered, the style information
		// has a tree structure and is no longer a simple list of style information.
		$arrayReplaces = array();
		preg_match_all('/(@media[^\{]*){/is', $styleCode, $matches, PREG_OFFSET_CAPTURE);
		foreach($matches[0] as $index => $media_rule_offset_array) {
			$offset = $media_rule_offset_array[1];
			$substr = substr($styleCode, $offset);
			$opening_string = "{";
			$closing_string = "}";
			$objectString = OM::getMediaRule($substr, $opening_string, $closing_string, 0);
			$media_rule = $media_rule_offset_array[0];
			$objectStringContents = substr($objectString, strpos($objectString, $opening_string)+1, strlen($objectString)-1);
			preg_match_all('/([^\{]*)\{([^\{\}]*)\}/is', $objectStringContents, $matches2);
			$inlinedObjectString = "";
			foreach($matches2[0] as $index => $style) {
				$inlinedObjectString .= $matches2[1][$index] . "{" . $media_rule . $matches2[2][$index] . "}}";
			}
			$arrayReplaces[$objectString] = $inlinedObjectString;
		}
		foreach($arrayReplaces as $search => $replace) {
			$styleCode = str_replace($search, $replace, $styleCode);
		}
		return $styleCode;
	}
	
	protected function replaceMultipleSelectors($styleCode) {
		preg_match_all('/([^\{\},]*,\s*[^\{\}]*)\s*(\{\s*([^\{\}]*)\s*\})/is', $styleCode, $matches);
		foreach($matches[1] as $index => $selector_match) {
			$array_selectors = explode(',', $selector_match);
			$replace_string = "";
			foreach($array_selectors as $selector) {
				$replace_string .= $selector . $matches[2][$index] . "\r\n";
			}
			$styleCode = str_replace($matches[0][$index], $replace_string, $styleCode);
		}
		return $styleCode;
	}

	protected function selectorToXPathWithoutClassesInArray($selector, $node_class_attribute_array) {
		// how should we deal with CSS pseudo-elements? example:
		// a:link:link
		// a:visited
		// a:link:hover
		// a:active
		// a:visited:hover
		// They are put into the style attribute.
		$namespace = ReTidy::get_html_namespace();
		$selector = " " . $selector;
		$XPath = $selector;
		$replaceArray = array(
		' \.' => '//' . $namespace . '*.',
		' #' => '//' . $namespace . '*#',
		'\[([^\[\]]*)\]' => '[@$1]',
		'\s*>\s*' => '/' . $namespace,
		// first-child and company are theoretically put into the style attribute
		//'([\w\-]*):first-child' => '*[1]/self::$1',
		// these are pseudo-selectors and could be part of either the selector or the style information for our purposes.
		// it is probably easier to consider them as style information.
		//'([\w\-]*):first-child' => 'child::$1[1]',
		'([\w\-]{1,}|\*)(\.[\w\-]{1,})*:first-child' => '*[1]/self::$1$2',
		//'([\w\-]*):last-child' => 'child::$1[last()]',
		'([\w\-]{1,}|\*)(\.[\w\-]{1,})*:last-child' => '*[last()]/self::$1$2',
		//'([\w\-]*):lang\(([^\(\)]*)\)' => '$1[@xml:lang="$2" or starts-with(@xml:lang, concat("$2","-"))]',
		//'\s*\+\s*' => '/following-sibling::*[1]/self::',
		'([\w\-]{1,}|\*)\s*\+\s*([\w\-\*]*)' => '$1/following-sibling::*[1]/self::$2',
		//'([\w\-]*)\s*\+\s*([\w\-]*)' => '$1/following-sibling::$2[0]',
		//'([\w\-]*)[([\w\-]*)~=("|\')([^\3]*)\3]' => '$1[contains(concat(" ",@$2," "),concat(" ","$4"," "))]',
		//'([\w\-]*)[([\w\-]*)|=("|\')([^\3]*)\3]' => '$1[@$2="$3" or starts-with(@$2,concat("$3","-"))]',
		'#([\w\-]{1,})' => '[@id="$1"]',
		' ' => '//' . $namespace,
		//'\.([\w\-]*)' => '[@class="$1"]',
		// the above is insufficient; elements may be multiply-classed:

		);
		foreach($replaceArray as $search => $replace) {
			$XPath = preg_replace('/' . $search . '/is', $replace, $XPath);
		}
		foreach($node_class_attribute_array[1] as $class_name) {
			$XPath = preg_replace('/\.' . $class_name . '/is', '', $XPath);
		}
		/**/
		$XPath = preg_replace('/\.([\w\-]{1,})/is', '[contains(concat(" ",@class," ")," $1 ")]', $XPath);
		/**/
		// the following can simply be precatenated when doing the query.
		//'(.*)' => '//' . ReTidy::get_html_namespace() . '$1',
		//'\*\*' => '*',		
		return $XPath;
	}

	protected function selectorToXPathWithoutClasses($selector) {
		// how should we deal with CSS pseudo-elements? example:
		// a:link:link
		// a:visited
		// a:link:hover
		// a:active
		// a:visited:hover
		// They are put into the style attribute.
		$namespace = ReTidy::get_html_namespace();
		$selector = " " . $selector;
		$XPath = $selector;
		$replaceArray = array(
		' \.' => '//' . $namespace . '*.',
		' #' => '//' . $namespace . '*#',		
		'\[([^\[\]]*)\]' => '[@$1]',
		'\s*>\s*' => '/' . $namespace,
		// first-child and company are theoretically put into the style attribute
		//'([\w\-]*):first-child' => '*[1]/self::$1',
		// these are pseudo-selectors and could be part of either the selector or the style information for our purposes.
		// it is probably easier to consider them as style information.
		//'([\w\-]*):first-child' => 'child::$1[1]',
		'([\w\-]{1,}|\*)(\.[\w\-]{1,})*:first-child' => '*[1]/self::$1$2',
		//'([\w\-]*):last-child' => 'child::$1[last()]',
		'([\w\-]{1,}|\*)(\.[\w\-]{1,})*:last-child' => '*[last()]/self::$1$2',
		//'([\w\-]*):lang\(([^\(\)]*)\)' => '$1[@xml:lang="$2" or starts-with(@xml:lang, concat("$2","-"))]',
		//'\s*\+\s*' => '/following-sibling::*[1]/self::',
		'([\w\-]{1,}|\*)\s*\+\s*([\w\-\*]*)' => '$1/following-sibling::*[1]/self::$2',
		//'([\w\-]*)\s*\+\s*([\w\-]*)' => '$1/following-sibling::$2[0]',
		//'([\w\-]*)[([\w\-]*)~=("|\')([^\3]*)\3]' => '$1[contains(concat(" ",@$2," "),concat(" ","$4"," "))]',
		//'([\w\-]*)[([\w\-]*)|=("|\')([^\3]*)\3]' => '$1[@$2="$3" or starts-with(@$2,concat("$3","-"))]',
		'#([\w\-]{1,})' => '[@id="$1"]',
		' ' => '//' . $namespace,
		//'\.([\w\-]*)' => '[@class="$1"]',
		// the above is insufficient; elements may be multiply-classed:
		/**/
		'\.([\w\-]{1,})' => '',
		/**/
		// the following can simply be precatenated when doing the query.
		//'(.*)' => '//' . ReTidy::get_html_namespace() . '$1',
		//'\*\*' => '*',
		);
		foreach($replaceArray as $search => $replace) {
			$XPath = preg_replace('/' . $search . '/is', $replace, $XPath);
		}
		return $XPath;
	}
	
	protected function selectorToXPath($selector) {
		// how should we deal with CSS pseudo-elements? example:
		// a:link:link
		// a:visited
		// a:link:hover
		// a:active
		// a:visited:hover
		// They are put into the style attribute.
		$namespace = ReTidy::get_html_namespace();
		$selector = " " . $selector;
		$XPath = $selector;
		$replaceArray = array(
		' \.' => '//' . $namespace . '*.',
		' #' => '//' . $namespace . '*#',		
		'\[([^\[\]]*)\]' => '[@$1]',
		'\s*>\s*' => '/' . $namespace,
		// first-child and company are theoretically put into the style attribute
		//'([\w\-]*):first-child' => '*[1]/self::$1',
		// these are pseudo-selectors and could be part of either the selector or the style information for our purposes.
		// it is probably easier to consider them as style information.
		//'([\w\-]*):first-child' => 'child::$1[1]',
		'([\w\-]{1,}|\*)(\.[\w\-]{1,})*:first-child' => '*[1]/self::$1$2',
		//'([\w\-]*):last-child' => 'child::$1[last()]',
		'([\w\-]{1,}|\*)(\.[\w\-]{1,})*:last-child' => '*[last()]/self::$1$2',
		//'([\w\-]*):lang\(([^\(\)]*)\)' => '$1[@xml:lang="$2" or starts-with(@xml:lang, concat("$2","-"))]',
		//'\s*\+\s*' => '/following-sibling::*[1]/self::',
		'([\w\-]{1,}|\*)\s*\+\s*([\w\-\*]*)' => '$1/following-sibling::*[1]/self::$2',
		//'([\w\-]*)\s*\+\s*([\w\-]*)' => '$1/following-sibling::$2[0]',
		//'([\w\-]*)[([\w\-]*)~=("|\')([^\3]*)\3]' => '$1[contains(concat(" ",@$2," "),concat(" ","$4"," "))]',
		//'([\w\-]*)[([\w\-]*)|=("|\')([^\3]*)\3]' => '$1[@$2="$3" or starts-with(@$2,concat("$3","-"))]',
		'#([\w\-]{1,})' => '[@id="$1"]',
		' ' => '//' . $namespace,
		//'\.([\w\-]*)' => '[@class="$1"]',
		// the above is insufficient; elements may be multiply-classed:
		'\.([\w\-]{1,})' => '[contains(concat(" ",@class," ")," $1 ")]',
		// the following can simply be precatenated when doing the query.
		//'(.*)' => '//' . ReTidy::get_html_namespace() . '$1',
		//'\*\*' => '*',
		);
		foreach($replaceArray as $search => $replace) {
			$XPath = preg_replace('/' . $search . '/is', $replace, $XPath);
		}
		return $XPath;
	}
	
	protected function pseudoSelectorsToStyleInformation($arrayOfStyleInformation) {
		foreach($arrayOfStyleInformation[0] as $index => $selector) {
			if(preg_match('/([^:]*)(:.*)/', $selector, $matches)) {
				// pseudo-elements like last-child and first-child probably need to be treated specially; 
				// this condition is an effort to do that.
				if(strpos($matches[2], "-") !== false) {
					// in this case, we are leaving them in the selector that will be translated to XPath
				} else {
					$arrayOfStyleInformation[0][$index] = $matches[1];
					$arrayOfStyleInformation[1][$index] = $matches[2] . " { " . $arrayOfStyleInformation[1][$index] . " }";
				}
			}
		}
		return $arrayOfStyleInformation;
	}
	
	protected function ensureStyleInformationBeginsProperly($string) {
		if(strpos($string, ";") === 0) {
			preg_match('/[\s;]*/s', $string, $empty_style_matches);
			$string = substr($string, strlen($empty_style_matches[0]));
		}
		return $string;
	}
	
	protected function ensureStyleInformationEndsProperly($string) {
		$rev_string = strrev($string);
		preg_match('/[\s;]*/s', $rev_string, $empty_style_matches);
		$string = strrev(substr($rev_string, strlen($empty_style_matches[0]))) . ";";
		return $string;
	}
	
	function strposOffset($search, $string, $offset) {
		/*** explode the string ***/
		$arr = explode($search, $string);
		/*** check the search is not out of bounds ***/
		switch($offset) {
			case $offset == 0:
			return false;
			break;
		
			case $offset > max(array_keys($arr)):
			return false;
			break;

			default:
			return strlen(implode($search, array_slice($arr, 0, $offset)));
		}
	}
	
	function strpos_whole_word_for_styles($haystack, $needle, $offset = 0) {
		$haystack = " " . $haystack . " ";
		$needle = " " . $needle . " ";
		//print('strpos($haystack, $needle, $offset): ');var_dump(strpos($haystack, $needle, $offset));
        return strpos($haystack, $needle, $offset);
	}
	
	function strpos_whole_word($haystack, $needle, $offset = 0) {
		preg_match('/([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)(' . $needle . ')([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)/s', $haystack, $matches, PREG_OFFSET_CAPTURE, $offset);
		return $matches[2][1];
	}
	
	function contains_whole_word_for_styles($haystack, $needle, $offset = 0) {
        return ReTidy::strpos_whole_word_for_styles($haystack, $needle, $offset);
	}
	
	function contains_whole_word($haystack, $needle, $offset = 0) {
        return preg_match('/([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)(' . $needle . ')([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)/s', $haystack, $matches, PREG_OFFSET_CAPTURE, $offset);
	}

	function str_replace_whole_word_for_styles($search, $replace, $subject) {
		$subject = " " . $subject . " ";
		$search = " " . $search . " ";
		$replace = " " . $replace . " ";		
        $pos = strpos($subject, $search);
        if($pos !== false) {
			$subject = str_replace($search, $replace, $subject);
        }
        return trim($subject);
	}
	
	function str_replace_whole_word($search, $replace, $subject) {
		//$test_string = '<h3 id="SUMMARY_OF_MANDATE">SUMMARY OF MANDATE</h3>';
		//$test_string = preg_replace('/\bSUMMARY\b/s', 'Summary', $test_string);
		//var_dump($test_string);exit(0);
		$count = 1;
		while($count > 0) {
			//$subject = preg_replace('/([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)' . $search . '([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)/s', '$1' . $replace . '$2', $subject, -1, $count);
			$subject = preg_replace('/([^a-zA-ZœàáâãäåæçèéêëìíîïðñòóôõöøùúûüýŒÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝ])' . $search . '([^a-zA-ZœàáâãäåæçèéêëìíîïðñòóôõöøùúûüýŒÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝ])/s', '$1' . $replace . '$2', $subject, -1, $count);
		}
		return $subject;
	}

	function str_replace_first_whole_word_for_styles($search, $replace, $subject) {
		$subject = " " . $subject . " ";
		$search = " " . $search . " ";
		$replace = " " . $replace . " ";		
        $pos = strpos($subject, $search);
        if($pos !== false) {
			$subject = ReTidy::str_replace_first($search, $replace, $subject);
        }
        return trim($subject);
	}
	
	function str_replace_first_whole_word($search, $replace, $subject, $offset = 0) {
		if($offset != 0) { // then we do some substring action.
			$substr = substr($subject, $offset);
			$substr = preg_replace('/([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)' . $search . '([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)/s', '$1' . $replace . '$2', $substr, 1);
			return substr($subject, 0, $offset) . $substr;
		} else {
			return preg_replace('/([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)' . $search . '([^a-zœàáâãäåæçèéêëìíîïðñòóôõöøùúûüý]|&oelig;|&agrave;|&aacute;|&acirc;|&atilde;|&auml;|&aring;|&aelig;|&ccedil;|&egrave;|&eacute;|&ecirc;|&euml;|&igrave;|&iacute;|&icirc;|&iuml;|&eth;|&ntilde;|&ograve;|&oacute;|&ocirc;|&otilde;|&ouml;|&divide;|&oslash;|&ugrave;|&uacute;|&ucirc;|&uuml;|&yacute;)/s', '$1' . $replace . '$2', $subject, 1);
		}
	}

	function str_replace_first($search, $replace, $subject) {
        $retval = $subject;
        $pos = strpos($subject, $search);
        if($pos !== false) {
			$retval = substr_replace($subject, $replace, $pos, strlen($search));
        }
        return $retval;
	}

	function str_replace_last($search, $replace, $subject) {
        return strrev(ReTidy::str_replace_first(strrev($search), strrev($replace), strrev($subject)));
	}
	
	function preg_replace_first($search, $replace, $subject) {
		return preg_replace($search, $replace, $subject, 1);
	}
	
	function preg_replace_last($search, $replace, $subject) {
		//print("preg_replace_last subject: ");var_dump($subject);
		// we can't just reverse everything like in str_replace_last since the regular expressions operators have a predefined orientation (left-to-right)
		preg_match_all($search, $subject, $matches, PREG_OFFSET_CAPTURE);
		if(sizeof($matches[0]) === 0) {
			return $subject;
		}
		$last_offset = $matches[0][sizeof($matches[0]) - 1][1];
		$substr = substr($subject, $last_offset);
		$substr = preg_replace($search, $replace, $substr);
		//print("preg_replace_last replaced: ");var_dump(substr($subject, 0, $last_offset) . $substr);
		return substr($subject, 0, $last_offset) . $substr;
	}
	
	protected function addClassWithoutOverwrite($tag, $class) {
		$found_class_attribute = false;
		$query = '@class';
		$class_attributes = $this->xpath->query($query, $tag);
		foreach($class_attributes as $class_attribute) {
			$found_class_attribute = true;
			break;
		}
		if($found_class_attribute) {
			$class_attribute->nodeValue = $class_attribute->nodeValue . " " . $class;
		} else {
			$tag->setAttribute("class", $class);
		}
	}
	
	protected function addStyleWithoutOverwrite($tag, $style) {
		//print('style: ');var_dump($style);
		if(preg_match('/(&\w+;)/is', $style, $character_entities_in_style_matches)) {
			print('Found a character entity in this style code<br>');
			print('style: ');var_dump($style);
			print('character_entities_in_style_matches: ');var_dump($character_entities_in_style_matches);exit(0);
		}
		$hasAStyleAttribute = false;
		$query2 = '@style';
		$existing_style_attributes = $this->xpath->query($query2, $tag);
		foreach($existing_style_attributes as $existing_style_attribute) {
			$existing_style_attribute->nodeValue = $style . " " . $existing_style_attribute->nodeValue;
			$hasAStyleAttribute = true;
		}
		if($hasAStyleAttribute) {

		} else {
			$tag->setAttribute('style', $style);
		}	
	}
	
	protected function recursively_add_classes($tag77, $array_selector_parts, $stylesheet_style_information) {
		foreach($array_selector_parts[0] as $index => $selector_part){
			$temp_class = $array_selector_parts[2][$index];
			$query = ReTidy::selectorToXPathWithoutClasses(trim($selector_part));
			$tags = $this->xpath->query($query, $tag77);
			unset($array_selector_parts[0][$index]);
			unset($array_selector_parts[1][$index]);
			unset($array_selector_parts[2][$index]);
			foreach($tags as $tag) {
				$query = "@style";
				$style_attributes = $this->xpath->query($query, $tag);
				foreach($style_attributes as $style_attribute) {
					if($style_attribute->nodeValue === "XXX9o9stripme9o9XXX" || strlen($style_attribute->nodeValue) === 0) {
						continue;
					}
					$strpos = OM::strpos_non_nested($style_attribute->nodeValue, $stylesheet_style_information, "{", "}");					
					if($strpos !== false) {
						$temp_class2 = 'XXX9o9' . $temp_class . '9o9XXX';
						ReTidy::addClassWithoutOverwrite($tag, $temp_class2);
						$query = '@class';
						$class_attributes = $this->xpath->query($query, $tag);
						foreach($class_attributes as $class_attribute) {
							$this->array_classes[] = array($temp_class, $class_attribute);
						}
						// recurse adding temp classes.
						ReTidy::recursively_add_classes($tag, $array_selector_parts, $stylesheet_style_information);
					}
				}
			}
			break;
		}
	}

	protected function setArrayStyleInformation() {
		$query = '//' . ReTidy::get_html_namespace() . 'head';
		//print('get_html_namespace: ');var_dump(ReTidy::get_html_namespace());
		//print('$this->HTML5: ');var_dump($this->HTML5);
		//$query = '//h:head'; // temporary
		//$query = '//head'; // temporary
		//$query = '//html/head'; // temporary
		$heads = $this->xpath->query($query);
		if(!$heads || !$heads->length) {
			$query = '//head';
			$heads = $this->xpath->query($query);
		}
		//ReTidy::dom_init();
		//print('$this->xpath: ');var_dump($this->xpath);
		//print('$this->dom: ');var_dump($this->dom);
		//$ps = $this->xpath->query('//p');
		//print("555");var_dump($ps, $ps->length, $this->dom);print("555");
		//$heads2 = $this->xpath->query('//head');
		//print("555");var_dump($heads2, $heads2->length, $this->dom);print("555");
		if(!$heads || !$heads->length) {
			print('$query: ' . $query);
			//print('555' . $this->code);print("555");
			print("555");var_dump($heads, $heads->length, $this->dom);print("555");
			print("Did not find &lt;head&gt; (setArrayStyleInformation)<br>\r\n");		
			return false;	
		}
		$styleCode = "";
		// I guess we assume there is only one <head> tag...
		foreach($heads as $head){
			// we assume all style information is in the <head> of the document.
			$styleCode = ReTidy::rec_DOM_getStyleCode($head, $styleCode);
		}
		
		$styleCode = ReTidy::removeComments($styleCode);
		$styleCode = ReTidy::removeAts($styleCode);
		$styleCode = processImportCommands($styleCode);
		// perhaps the way to deal with multiple selectors on the same style information is to, in the pre-arrayed
		// code, replace such sections with individual selectors; each with its copy of the style information:
		// this may not be necessary since the comma in the selector could be replaced by a | for the XPath.
		// I guess it comes down to whether perl regular expressions or XPath is faster; I do not know (2009-03-17).
		// It does simplify the translation from selector to XPath to have only one tag.
		$styleCode = ReTidy::replaceMultipleSelectors($styleCode);
		
		// something tricky: how to turn @media style information into an inline style...
		// is this even possible?
		$styleCode = ReTidy::inlineMediaRules($styleCode);
		
		// when creating this array we must consider that style information can now have curly brackets in it, but until
		// we are sure that this is the correct way to apply inline media rules, then we'll not worry about it since we
		// can assume that the function that creates the array from any such style information will catch the first }
		// and not miss anything...
		$this->arrayOfStyleInformation = ReTidy::getStylesFromCode($styleCode);
		$this->arrayOfStyleInformation = ReTidy::pseudoSelectorsToStyleInformation($this->arrayOfStyleInformation);
	}

	protected function getArrayStyleInformation() {
		if(!$this->arrayOfStyleInformation) {
			ReTidy::setArrayStyleInformation();
		}
		return $this->arrayOfStyleInformation;
	}
	
	protected function resolve_relative_paths() {
		/*print('test...<br>');
		$string = 'print(\'hi there...<br>\');';
		print($string);
		exec($string);
		eval($string);
		exit(0);*/
	
		/*<link rel="shortcut icon" href="../build/theme-gcwu-fegc/images/favicon.ico" />
		<script src="../build/js/jquery.min.js"></script>
		<link rel="stylesheet" href="../build/grids/css/util-ie-min.css" />
		<noscript><link rel="stylesheet" href="../build/theme-gcwu-fegc/css/theme-ns-min.css" /></noscript>
		<?php include('..' . DS . 'includes' . DS . 'header-eng.txt'); ?>
		<script src="../build/theme-gcwu-fegc/js/theme-min.js"></script>*/
		
		$this->code = ReTidy::reverse_order_substr_preg_replace('<link([^<>]*?) href="([^"]*?)"([^<>]*?)>', 2, $this->code, '$changed_part = ReTidy::adjust_relative_path($part_to_change, $this->file);');
		$this->code = ReTidy::reverse_order_substr_preg_replace('<script([^<>]*?) src="([^"]*?)"([^<>]*?)>', 2, $this->code, '$changed_part = ReTidy::adjust_relative_path($part_to_change, $this->file);');
		//print('this one -&gt;<br>');
		/*$this->code = ReTidy::reverse_order_substr_preg_replace('<?php include\(\'([^\']*?)\'\); ?>', 1, $this->code, '$changed_part = ReTidy::adjust_relative_path($part_to_change, $this->file);');*/
		$this->code = ReTidy::reverse_order_substr_preg_replace('<\?php include\(\'([^\']*?)\'\); \?>', 1, $this->code, '$changed_part = ReTidy::adjust_relative_path($part_to_change, $this->file);');
		$this->code = ReTidy::reverse_order_substr_preg_replace('<\!\-\-\#include file="([^"]*?)" \-\->', 1, $this->code, '$changed_part = ReTidy::adjust_relative_path($part_to_change, $this->file);');
		
		/*<?php include('..' . DS . 'includes' . DS . 'header-eng.txt'); ?>*/
		/*
		preg_match_all('/<\?php include\(\'([^\']*?)\'\); \?>/is', $this->code, $matches, PREG_OFFSET_CAPTURE);
		//print($this->code);
		//var_dump($matches);
		//exit(0);
		$counter = sizeof($matches[0]) - 1;
		while($counter > -1) {
			$full_match = $matches[0][$counter][0];
			$part_to_change = $matches[1][$counter][0];
			$offset = $matches[0][$counter][1];
			var_dump($replacement_to_eval, eval($replacement_to_eval), $part_to_change, $this->file);
			eval($replacement_to_eval);
			$replacement = str_replace($part_to_change, $changed_part, $full_match); // perhaps not perfect
			var_dump($part_to_change, $replacement);
			$this->code = substr($this->code, 0, $offset) . $replacement . substr($this->code, $offset + strlen($full_match));
			$counter--;
		}*/
		//print('&lt;<br>');
	}
	
	protected function reverse_order_substr_preg_replace($pattern, $part_to_change_preg_order, $code, $replacement_to_eval) {
		// perhaps this function could be made more efficient by breaking the string we are working on into an array instead of doing a substr replace for every instance we want to replace.
		//var_dump('/' . str_replace("'", "\\'", $pattern) . '/is', str_replace("'", "\\'", $pattern), $pattern);
		preg_match_all('/' . $pattern . '/is', $code, $matches, PREG_OFFSET_CAPTURE);
		$counter = sizeof($matches[0]) - 1;
		while($counter > -1) {
			$full_match = $matches[0][$counter][0];
			$part_to_change = $matches[$part_to_change_preg_order][$counter][0];
			$offset = $matches[0][$counter][1];
			//var_dump($replacement_to_eval, eval($replacement_to_eval), $part_to_change, $this->file);
			eval($replacement_to_eval);
			$replacement = str_replace($part_to_change, $changed_part, $full_match); // perhaps not perfect
			//var_dump($part_to_change, $replacement);
			$code = substr($code, 0, $offset) . $replacement . substr($code, $offset + strlen($full_match));
			$counter--;
		}
		return $code;
	}
	
	protected function adjust_relative_path($path = false, $relative_path = false) {
		// this function could possibly be made more efficient
		if($path === false) {
			print('Path: ' . $path . ' or relative path: ' . $relative_path . ' for function resolve_relative_path was imporperly specifed.');
		}
		//$exploded_file_path = explode('/', $this->file);
		$exploded_path = explode('/', $path);
		$exploded_relative_path = explode('/', $relative_path);
		$path_counter = 0;
		while($exploded_path[$path_counter] === '..') {
			$path_counter++;
		}
		$part_to_keep = '';
		$path_counter2 = $path_counter;
		while($path_counter2 < sizeof($exploded_path)) {
			$part_to_keep .= '/' . $exploded_path[$path_counter2];
			$path_counter2++;
		}
		$relative_path_counter = sizeof($exploded_relative_path);
		while($path_counter > -1) {
			$relative_path_counter--;
			$path_counter--;
		}
		$part_to_keep2 = '';
		$relative_path_counter2 = 0;
		while($relative_path_counter > 0) {
			$part_to_keep2 .= '../';
			$relative_path_counter2++;
			$relative_path_counter--;
		}
		$resolved_path = substr($part_to_keep2, 0, strlen($part_to_keep2) - 1) . $part_to_keep;
		//print('$path, $relative_path, $resolved_path: ');var_dump($path, $relative_path, $resolved_path);
		return $resolved_path;
	}
	
	protected function resolve_relative_path($path = false, $relative_path = false) {
		// this function could possibly be made more efficient
		if($path === false) {
			print('Path: ' . $path . ' or relative path: ' . $relative_path . ' for function resolve_relative_path was imporperly specifed.');
		}
		//$exploded_file_path = explode('/', $this->file);
		$exploded_path = explode('/', $path);
		$exploded_relative_path = explode('/', $relative_path);
		$path_counter = 0;
		while($exploded_path[$path_counter] === '..') {
			$path_counter++;
		}
		$part_to_keep = '';
		$path_counter2 = $path_counter;
		while($path_counter2 < sizeof($exploded_path)) {
			$part_to_keep .= '/' . $exploded_path[$path_counter2];
			$path_counter2++;
		}
		$relative_path_counter = sizeof($exploded_relative_path);
		while($path_counter > -1) {
			$relative_path_counter--;
			$path_counter--;
		}
		$part_to_keep2 = '';
		$relative_path_counter2 = 0;
		while($relative_path_counter > 0) {
			$part_to_keep2 .= $exploded_relative_path[$relative_path_counter2] . '/';
			$relative_path_counter2++;
			$relative_path_counter--;
		}
		$resolved_path = substr($part_to_keep2, 0, strlen($part_to_keep2) - 1) . $part_to_keep;
		//print('$path, $relative_path, $resolved_path: ');var_dump($path, $relative_path, $resolved_path);
		return $resolved_path;
	}
	
	protected function getAllStyleInformation($code = false) {
		//var_dump($code);exit(0);
		if($code === false) {
			$code = $this->code;
		}
		preg_match_all('/<head[^<>]*?>(.*?)<\/head>/is', $code, $head_matches);
		if(sizeof($head_matches[0]) > 1) {
			ReTidy::warning('Hmm... that\'s not good; found more than one &lt;head&gt; in this document... (getAllStyleInformation)');
		}
		if(sizeof($head_matches[0]) === 0) {
			ReTidy::warning('Hmm... that\'s not good; found no &lt;head&gt;s in this document... (getAllStyleInformation)');
		}
		$styleCode = '';
		//if(strpos($head_matches[1][0], '<link href=') !== false || strpos($head_matches[1][0], '@import') !== false || strpos($head_matches[1][0], '<style') !== false) {
		if(strpos($head_matches[1][0], 'type="text/css"') !== false || strpos($head_matches[1][0], 'rel="stylesheet"') !== false || strpos($head_matches[1][0], '<style') !== false) {
			//$styleCode = $head_matches[1][0];
			preg_match_all('/(<link[^<>]*? rel="stylesheet"[^<>]*? href="([^"]*?)"[^<>]*?>)|(<style[^<>]*?>(.*?)<\/style>)|(<link[^<>]*? href="([^"]*?)"[^<>]*? rel="stylesheet"[^<>]*?>)|(<link[^<>]*? type="text\/css"[^<>]*? href="([^"]*?)"[^<>]*?>)|(<link[^<>]*? href="([^"]*?)"[^<>]*? type="text\/css"[^<>]*?>)/is', $head_matches[1][0], $unexpanded_styleCode_matches);
			//print('$unexpanded_styleCode_matches: ');var_dump($unexpanded_styleCode_matches);exit(0);
			foreach($unexpanded_styleCode_matches[0] as $index => $value) {
				if(strlen($unexpanded_styleCode_matches[1][$index]) > 0) {
					$styleCode .= file_get_contents(ReTidy::resolve_relative_path($unexpanded_styleCode_matches[2][$index], $this->template));
				} elseif(strlen($unexpanded_styleCode_matches[5][$index]) > 0) {
					$styleCode .= file_get_contents(ReTidy::resolve_relative_path($unexpanded_styleCode_matches[6][$index], $this->template));
				} elseif(strlen($unexpanded_styleCode_matches[7][$index]) > 0) {
					$styleCode .= file_get_contents(ReTidy::resolve_relative_path($unexpanded_styleCode_matches[8][$index], $this->template));
				} elseif(strlen($unexpanded_styleCode_matches[9][$index]) > 0) {
					$styleCode .= file_get_contents(ReTidy::resolve_relative_path($unexpanded_styleCode_matches[10][$index], $this->template));
				} else { // <style
					$styleCode .= $unexpanded_styleCode_matches[4][$index];
				}
			}
			$there_exists_style_code_to_expand = true;
			while($there_exists_style_code_to_expand) {
				$there_exists_style_code_to_expand = false;
				//@import url(/Templates/css/base2.css);
				preg_match_all('/@import[^\(]*?\(([^\(\)]*?)\)/is', $styleCode, $import_matches);
				foreach($import_matches[0] as $index => $value) {
					$styleCode = str_replace($value, file_get_contents($import_matches[1][$index]), $styleCode, $count);
					if($count > 0) {
						$there_exists_style_code_to_expand = true;
					}
				}
			}
		}
		return $styleCode;
	}
	
	protected function setArrayClassNamesFromStyleInformation($code = false) {
		//var_dump($code);exit(0);
		if($code === false) {
			$code = $this->code;
		}
		$use_saved = false;
		if($use_saved !== true) {
			$styleCode = ReTidy::getAllStyleInformation($code);
			
			$styleCode = ReTidy::removeComments($styleCode);
		//	$styleCode = ReTidy::removeAts($styleCode);
		//	$styleCode = processImportCommands($styleCode);

			//print($styleCode);
			//var_dump(strpos($styleCode, 'width-50'));
			$array_class_name_counts = array();
			$offset = 0;
			while($offset < strlen($styleCode)) {
				if($styleCode[$offset] === '.') {
					preg_match('/[\w\-]*/is', substr($styleCode, $offset + 1), $class_name_matches);
					$potential_class_name = $class_name_matches[0];
					$offset += strlen($potential_class_name);
				} elseif($styleCode[$offset] === '{') {
					//var_dump($potential_class_name);
					if(strlen($potential_class_name) > 0) {
						if(isset($array_class_name_counts[$potential_class_name])) {
							$array_class_name_counts[$potential_class_name]++;
						} else {
							$array_class_name_counts[$potential_class_name] = 1;
						}
					}
				} elseif($styleCode[$offset] === '}') {
					$potential_class_name = '';
				}
				$offset++;
			}
			//$array_class_names = array();
			/*
			$class_names_string = '';
			foreach($array_class_name_counts as $index => $value) {
				//$array_class_names[] = $index;
				$class_names_string .= $index . '
';
			}
			file_put_contents('SavedClassNamesFromStyleInformation.txt', $class_names_string);
			*/
			//var_dump($array_class_name_counts['width-50']);
			$this->arrayClassNamesFromStyleInformation = $array_class_name_counts;
		} else {
			$temp_array = explode("\r\n", file_get_contents('SavedClassNamesFromStyleInformation.txt'));
			$this->arrayClassNamesFromStyleInformation = array();
			foreach($temp_array as $index => $value) {
				$this->arrayClassNamesFromStyleInformation[$value] = 1;
			}
		}
	}

	protected function getArrayClassNamesFromStyleInformation($code = false) {
		if($code === false) {
			$code = $this->code;
		}
		if(!isset($this->arrayClassNamesFromStyleInformation)) {
			ReTidy::setArrayClassNamesFromStyleInformation($code);
		}
		return $this->arrayClassNamesFromStyleInformation;
	}

	protected function create_css_exhausting_document () {
		$arrayOfStyleInformation = ReTidy::getArrayStyleInformation();
		$query = '//' . ReTidy::get_html_namespace() . 'body';
		$bodies = $this->xpath->query($query);
		foreach($bodies as $body) {}
		foreach($arrayOfStyleInformation[0] as $index => $selector) {
			if(ReTidy::contains_whole_word_for_styles($selector, "body") !== false || ReTidy::contains_whole_word_for_styles($selector, "html") !== false || strpos($selector, "+") !== false || strpos($selector, ":") !== false) {
			
			} else {
				var_dump($selector);print("<br>\r\n");
				$node = $body;
				preg_match_all('/([^> ]{1,})/is', $selector, $matches);
				foreach($matches[1] as $match) {
					$class_name = false;
					$id = false;					
					if(($strpos = strpos($match, ".")) !== false) {
						$class_name = substr($match, $strpos+1);
						$tag_name = substr($match, 0, $strpos);
					} elseif (($strpos = strpos($match, "#")) !== false) {
						$id = substr($match, $strpos+1);
						$tag_name = substr($match, 0, $strpos);
					} else {
						$tag_name = $match;
					}
					if(strlen($tag_name) === 0) {
						$new_node = new DOMElement("div");
					} else {
						$new_node = new DOMElement($tag_name);					
					}
					$node->appendChild($new_node);
					if($class_name) {
						$new_node->setAttribute("class", $class_name);
					}
					if($id) {
						$new_node->setAttribute("id", $id);
					}
					$node = $new_node;
				}
				/*$class_name = false;
				$id = false;					
				if(($strpos = strpos($selector, ".")) !== false) {
					$class_name = substr($selector, $strpos+1);
					$tag_name = substr($selector, 0, $strpos);
				} elseif(($strpos = strpos($selector, "#")) !== false) {
					$id = substr($selector, $strpos+1);
					$tag_name = substr($selector, 0, $strpos);						
				} else {
					$tag_name = $selector;
				}
				if(strlen($tag_name) === 0) {
					$new_node = new DOMElement("div");
				} else {
					$new_node = new DOMElement($tag_name);					
				}
				$node->appendChild($new_node);
				if($class_name) {
					$new_node->setAttribute("class", $class_name);
				}
				if($id) {
					$new_node->setAttribute("id", $id);
				}*/
				$node->appendChild(new DOMText("text"));
			}
		}
	}

	protected function array_unique_multi($array) {
		$new_array = array();
		foreach($array as $d) {
			$new_array[md5(serialize($d))] = $d;
		}
		sort($new_array);
		return $new_array;
	}
	
	protected function extra_styles() {
		ReTidy::cleanStyles();
		ReTidy::extraneous_styles();
	}
	
	protected function extraneous_styles() {
		if(strpos($this->code, 'style="') !== false) {
			$array_replaces = array();
			preg_match_all('/ style="([^"]+)"/is', $this->code, $style_matches);
			$style_matches[0] = array_unique($style_matches[0]);
			foreach($style_matches[0] as $index => $value) {
				$array_styles = OM::explode_non_nested(";", $style_matches[1][$index], "{", "}");
				$array_styles2 = array();
				foreach($array_styles as $style) {
					$style = trim($style);
					$pos_at = strpos($style, "@");
					$pos = strpos($style, ":");
					if($pos_at === 0) { // media rule
						ReTidy::warning('Possibly problematic since we may be deleting @media {  } statements. 43040122');
						$property = trim(substr($style, 0, strpos($style, "{")));
						$styling = OM::getOString($style, "{", "}", strpos($style, "{"));;
						$array_styles2[] = array($property, $styling);
					} elseif($pos === 0) { // pseudo-selector
						$property = trim(substr($style, 0, strpos($style, "{")));
						$styling = OM::getOString($style, "{", "}", strpos($style, "{"));;
						$array_styles2[] = array($property, $styling);
					} elseif($pos) {
						$property = trim(substr($style, 0, $pos));
						$styling = trim(substr($style, $pos+1));
						$array_styles2[] = array($property, $styling);
					} else {
						ReTidy::warning('unusual situation in Retidy::extraneous_styles, we might have to deal with this unexpected lack of : since array_styles and array_styles2 must have the same indices. 3efhd75tyehe735');
						print($style . '<br></span>');
						// print($this->code . "<br>");
						//  commented out RB Dec 10, 2009 exit(0);
					}
				}
				foreach($array_styles2 as $index3 => $value3) {
					$property = $value3[0];
					$styling = $value3[1];
					foreach($array_styles2 as $index2 => $value2) {
						if($index2 === $index3) {
							break;
						}
						$property2 = $value2[0];
						$styling2 = $value2[1];
						if(strlen($property2) > 0 && $property2 === $property) { // the string length restriction is because of pseudo-selectors
							// delete it
							unset($array_styles[$index2]);
						}
					}
				}
				if(!isset($array_replaces[$value])) {
					// notice that the styles include a space in front of them.
					$array_replaces[$value] = ' style="' . implode(';', $array_styles) . ';"';
				}
			}
			foreach($array_replaces as $search => $replace) {
				$this->code = str_replace($search, $replace, $this->code);
			}
		}
	}

	protected function redundant_classes() {
		if(strpos($this->code, 'class="') !== false) {
			$array_replaces = array();
			preg_match_all('/ class="([^"]+)"/is', $this->code, $class_matches);
			foreach($class_matches[0] as $index => $value) {
				$array_class_names = explode(" ", trim($class_matches[1][$index]));
				foreach($array_class_names as $index3 => $class_name3) {
					foreach($array_class_names as $index2 => $class_name2) {
						if($index3 === $index2) {
							break;
						}
						if($class_name3 === $class_name2) {
							// delete it
							unset($array_class_names[$index2]);
						}
					}
				}
				if(!isset($array_replaces[$value])) {
					$array_replaces[$value] = ' class="' . implode(' ', $array_class_names) . '"';
				}
			}
			foreach($array_replaces as $search => $replace) {
				$this->code = str_replace($search, $replace, $this->code);
			}
		}
	}
	
	function are_clones($a1, $a2){
		if(serialize($a1) === serialize($a2)) {
			return true;
		} else {
			return false;
		}
	}
	
	protected function DOM_redundant_classes() {
		//$ps = $this->xpath->query('//p');
		//print('ps10: ');var_dump($ps, $ps->length, $this->dom);
		$arrayOfStyleInformation = ReTidy::getArrayStyleInformation();
		$query = '//@class';
		$class_attributes = $this->xpath->query($query);
		foreach($class_attributes as $class_attribute) {
			$class_attribute->nodeValue = trim($class_attribute->nodeValue);
			if($class_attribute->nodeValue === "XXX9o9stripme9o9XXX" || strlen($class_attribute->nodeValue) === 0) {
				continue;
			}
			$array_class_names = explode(" ", $class_attribute->nodeValue);
			// for the simple case where only a single class is duplicated an arbitrary number of times
			$first_class_name = "";
			foreach($array_class_names as $class_name) {
				if(strlen($first_class_name) === 0) {
					$first_class_name = $class_name;
				} else {
					if($class_name === $first_class_name) {
						$simple_redundancy = true;
					} else {
						$simple_redundancy = false;					
					}
				}
			}
			if($simple_redundancy) {
				$class_attribute->nodeValue = $first_class_name;
				continue;
			}
			// for the simple case where a single class is duplicated an arbitrary number of times
			$array_class_names = explode(" ", $class_attribute->nodeValue);
			$class_attribute->nodeValue .= " ";
			foreach($array_class_names as $class_name) {
				$class_attribute->nodeValue	= preg_replace('/(' . $class_name . ' ){2,}/s', $class_name . ' ', $class_attribute->nodeValue);
			}
			$class_attribute->nodeValue = trim($class_attribute->nodeValue);
			if(strlen($class_attribute->nodeValue) === 0) {
				$class_attribute->nodeValue === "XXX9o9stripme9o9XXX";
			}
		}
	}
	
	protected function getArrayStyleInformationForClass($class_name) {
		$arrayStyleInformationForClass = array();
		foreach($this->arrayOfStyleInformation[0] as $index => $selector) {
			if(strpos($selector . " ", "." . $class_name . " ") !== false) {
				$arrayStyleInformationForClass[] = $this->arrayOfStyleInformation[1][$index];
			}
		}
		return $arrayStyleInformationForClass;
	}

	protected function exhaustive_DOM_styles_to_classes_full () {
		//$ps = $this->xpath->query('//p');
		//print('ps1: ');var_dump($ps, $ps->length, $this->dom);
		ReTidy::cleanStyles();
		//$ps = $this->xpath->query('//p');
		//print('ps2: ');var_dump($ps, $ps->length, $this->dom);
		$initial_code = true;
		$code = false;
		$loop_counter = 0;
		while($initial_code != $code) {
			if($loop_counter === 10) {
				ReTidy::warning('looped 10 times in exhaustive_DOM_styles_to_classes_full wihtout completing; this could be bad...');
			}
			$initial_code = $this->code;
			//$ps = $this->xpath->query('//p');
			//print('ps3: ');var_dump($ps, $ps->length, $this->dom);
			ReTidy::dom_init();
			//$ps = $this->xpath->query('//p');
			//print('ps4: ');var_dump($ps, $ps->length, $this->dom);
			ReTidy::DOM_styles_to_classes_full();
			//$ps = $this->xpath->query('//p');
			//print('ps5: ');var_dump($ps, $ps->length, $this->dom);
			ReTidy::dom_save();
			$code = $this->code;
			$loop_counter++;
		}
		//$ps = $this->xpath->query('//p');
		//print('ps6: ');var_dump($ps, $ps->length, $this->dom);
		ReTidy::post_dom(); // for example, to clean style="XXX9o9stripme9o9XXX"
		//$ps = $this->xpath->query('//p');
		//print('ps7: ');var_dump($ps, $ps->length, $this->dom);
		ReTidy::dom_init();
		ReTidy::DOM_make_new_classes();
		//print('$this->code after DOM_make_new_classes: ');var_dump($this->code);
		ReTidy::dom_save();
		//print('$this->code after dom_save: ');var_dump($this->code);
		//$ps = $this->xpath->query('//p');
		//print('ps8: ');var_dump($ps, $ps->length, $this->dom);
		ReTidy::post_dom(); // for example, to clean style="XXX9o9stripme9o9XXX"
		ReTidy::redundant_classes();		
		ReTidy::cleanStyles();
		//$ps = $this->xpath->query('//p');
		//print('ps9: ');var_dump($ps, $ps->length, $this->dom);
		//print('$this->code at the end of exhaustive_DOM_styles_to_classes_full: ');var_dump($this->code);
	}

	protected function DOM_make_new_classes() {
		$arrayOfStyleInformation = ReTidy::setArrayStyleInformation();
		$arrayOfStyleInformation = ReTidy::getArrayStyleInformation();
		$arrayOfStyleInformation[0] = array_reverse($arrayOfStyleInformation[0]);
		$arrayOfStyleInformation[1] = array_reverse($arrayOfStyleInformation[1]);
		//print('$arrayOfStyleInformation: ');var_dump($arrayOfStyleInformation);
		// here we may want to reverse the order of the classes in the class attribute (assuming that the latest class obtains,
		// which has not been verified (2009-05-04)). Nevermind; as was probably previously discovered, firefox uses the order of the classes
		// in the stylesheet (which does not rub me the right way but that may be what the specification specifies).
		
		$array_new_style_information = array();
		$query = '//@style';
		$style_attributes = $this->xpath->query($query);
		foreach($style_attributes as $style_attribute) {
			if($style_attribute->nodeValue != "XXX9o9stripme9o9XXX" && $style_attribute->nodeValue != "stripme") {
				$array_new_style_information[] = array($style_attribute, $style_attribute->nodeValue);			
			}
		}
		$new_style_code = "";
		$array_node_paths = array();
		$new_class_count = 0;
		foreach($arrayOfStyleInformation[0] as $index => $selector) {
			preg_match_all('/\.' . $this->config["new_class_name"] . '([0-9]+)/', $selector, $matches435);
			foreach($matches435[1] as $index435 => $class_count435){
				if($class_count435 > $new_class_count) {
					$new_class_count = $class_count435;
				}
			}
		}

		foreach($array_new_style_information as $index => $value) {
			$array_node_path = array();
			$style_attribute = $value[0];
			$style_attribute_node_value = $value[1];
			$node = $style_attribute->parentNode;
			$query = '@class';
			$class_attributes = $this->xpath->query($query, $node);
			foreach($class_attributes as $class_attribute) {
				$class_attribute39 = $class_attribute;
			}
			$array_node_path[] = array($node, $style_attribute, $class_attribute39);
			while($node = $node->parentNode) {
				$query = '@style';
				$style_attributes = $this->xpath->query($query, $node);
				foreach($style_attributes as $style_attribute) {
					$style_attribute39 = $style_attribute;
				}
				$query = '@class';
				$class_attributes = $this->xpath->query($query, $node);
				foreach($class_attributes as $class_attribute) {
					$class_attribute39 = $class_attribute;
				}
				$array_node_path[] = array($node, $style_attribute39, $class_attribute39);
			}
			$array_node_paths[] = $array_node_path;
		}
		foreach($array_node_paths as $array_node_path) {
			// first try finding if certain style information only occurs on certain tags
			$array_to_class = $array_to_class_with_name = array();
			$node = $array_node_path[0][0];
			$style_attribute = $array_node_path[0][1];
			$class_attribute = $array_node_path[0][2];
			$style_attribute_node_value = $style_attribute->nodeValue;
			$class_attribute_node_value = $class_attribute->nodeValue;
			if($style_attribute_node_value != "XXX9o9stripme9o9XXX") {
				$array_to_class_with_name[] = array($node, $style_attribute, $class_attribute);
				$array_to_class[] = array($node, $style_attribute, $class_attribute);
				foreach($array_node_paths as $array_node_path2) {
					$node2 = $array_node_path2[0][0];
					$style_attribute2 = $array_node_path2[0][1];
					$class_attribute2 = $array_node_path2[0][2];
					$style_attribute_node_value2 = $style_attribute2->nodeValue;
					$class_attribute_node_value2 = $class_attribute2->nodeValue;
					if($style_attribute_node_value2 != "XXX9o9stripme9o9XXX") {					
						if($node === $node2) {
							continue;
						}
						if($style_attribute_node_value === $style_attribute_node_value2) {
							if($node->nodeName === $node2->nodeName) {
								$array_to_class_with_name[] = array($node2, $style_attribute2, $class_attribute2);
							}
							$array_to_class[] = array($node2, $style_attribute2, $class_attribute2);
						}
					}					
				}
			}
			if(sizeof($array_to_class) > 0) {
				$new_class_count++;
				if(sizeof($array_to_class) === sizeof($array_to_class_with_name)) {
					//$new_style_code .= $node->nodeName . "." . $this->config["new_class_name"] . $new_class_count . " { " . $style_attribute->nodeValue . " } \r\n";
					$new_style_code .= $node->nodeName . '.' . $this->config["new_class_name"] . $new_class_count . ' { ' . $style_attribute->nodeValue . ' }
';
					foreach($array_to_class_with_name as $index20 => $value20) {
						$node2 = $value20[0];
						$style_attribute2 = $value20[1];
						$class_attribute2 = $value20[2];
						ReTidy::addClassWithoutOverwrite($node2, $this->config["new_class_name"] . $new_class_count);
						$style_attribute2->nodeValue = "XXX9o9stripme9o9XXX";					
					}
				} else {
					//$new_style_code .= "." . $this->config["new_class_name"] . $new_class_count . " { " . $style_attribute->nodeValue . " } \r\n";
					$new_style_code .= '.' . $this->config["new_class_name"] . $new_class_count . ' { ' . $style_attribute->nodeValue . ' }
';
					foreach($array_to_class as $index20 => $value20) {
						$node2 = $value20[0];
						$style_attribute2 = $value20[1];
						$class_attribute2 = $value20[2];
						ReTidy::addClassWithoutOverwrite($node2, $this->config["new_class_name"] . $new_class_count);
						$style_attribute2->nodeValue = "XXX9o9stripme9o9XXX";					
					}				
				}
				$style_attribute->nodeValue = "XXX9o9stripme9o9XXX";
			}
		}
		$query = '//' . ReTidy::get_html_namespace() . 'head';
		//print('$query, $new_style_code: ');var_dump($query, $new_style_code);
		//$query = '//h:head'; // temporary
		$heads = $this->xpath->query($query);
		$style_tag = false;
		//print('sizeof($heads): ');var_dump(sizeof($heads));
		//print('count($heads): ');var_dump(count($heads));
		//print('$heads->length: ');var_dump($heads->length);
		//print('$heads: ');var_dump($heads);
		//print('$this->code: ' . htmlentities($this->code));
		//print('here3858969708<br>');
		//if($heads->length > 0) {
			$style_tag = false;
			foreach($heads as $head) {
				//print('here3858969709<br>');
				$head_node = $head;
				//print('ReTidy::DOM_getNodeString($head):');var_dump(ReTidy::DOM_getNodeString($head));
				$query = './/' . ReTidy::get_html_namespace() . 'style';
				$style_tags = $this->xpath->query($query, $head);
				foreach($style_tags as $style_tag) {  }
			}
			//print('$head_node: ');var_dump($head_node);
			//print('ReTidy::DOM_getNodeString($style_tag):');var_dump(ReTidy::DOM_getNodeString($style_tag));
			//print('$new_style_code: ');var_dump($new_style_code);
			$existing_style_code = '';
			if($style_tag !== false) {
				$existing_style_code = ReTidy::tagless(ReTidy::DOM_getNodeString($style_tag));
			}
			if(strlen($new_style_code) > 0) {
				$new_style_code = substr($new_style_code, 0, strlen($new_style_code) - 2);
				//print('here3858969710<br>');
				if($this->config["new_classes"] === "embedded") {
					//print('here3858969711<br>');
					if($style_tag) {
						//print('here3858969712<br>');
						$style_tag->appendChild(new DOMText($new_style_code));
					} else {
						//print('here3858969713<br>');
						$style_node = new DOMElement("style", $new_style_code);
						if($head_node) {
							$head_node->appendChild($style_node);
						}
					}
					$this->saved_template = str_replace('</head>', '<style>' . $existing_style_code . $new_style_code . '</style></head>', $this->saved_template); // 2018-07-28 pretty crude but probably work while this code is only used by the clean_word (and related) profiles
				} elseif($this->config["new_classes"] === "new_stylesheet") {
					//print('here3858969714<br>');
					$filepath = 'css' . DS . $this->config["new_class_name"] . '.css';
					if(is_file($filepath)) {
						//print('here3858969715<br>');
						$contents = file_get_contents($filepath);
						$contents .= "/**/\r\n" . $new_style_code;
						file_put_contents($filepath, $contents);
					} else {
						//print('here3858969716<br>');
						file_put_contents($filepath, "/**/\r\n" . $new_style_code);
					}
					//print('here3858969717<br>');
					$link_node = new DOMElement("link");
					$head_node->appendChild($link_node);
					$link_node->setAttribute("href", $filepath);
					$link_node->setAttribute("rel", "stylesheet");
					$link_node->setAttribute("type", "text/css");
				} else {
					print("I do not know what to do with new classes 329039030<br>\r\n");exit(0);			
				}
			}
		//}
		//print('ReTidy::DOM_getNodeString($style_tag) after:');var_dump(ReTidy::DOM_getNodeString($style_tag));
		$this->made_new_classes = true;
	}
	
	protected function DOM_styles_to_classes_full () {
		ReTidy::setArrayStyleInformation();
		$arrayOfStyleInformation = ReTidy::getArrayStyleInformation();
		$arrayOfStyleInformation[0] = array_reverse($arrayOfStyleInformation[0]);
		$arrayOfStyleInformation[1] = array_reverse($arrayOfStyleInformation[1]);		
		// while a human would probably look at the style information in a style attribute then see if part of it matches a part of the stylesheet
		// then see if the selector applies to the tag with the style information, I am unsure whether it would be more efficient for the program to look
		// at the selector then all the tags that match the selector then see if among the tags that match it there is style information in the style
		// attribute that matches that of the stylesheet.
		foreach($arrayOfStyleInformation[0] as $index => $selector) {
			$stylesheet_style_information = $arrayOfStyleInformation[1][$index];
			$length_stylesheet_style_information = strlen($stylesheet_style_information);
			if(strpos($selector, ".") === false) {
				// then we need not worry about applying class attributes; merely about removing style information from style attributes
				$query = ReTidy::selectorToXPath($selector);
				$tags = $this->xpath->query($query);
				foreach($tags as $tag) {
					$query = "@style";
					$style_attributes = $this->xpath->query($query, $tag);
					foreach($style_attributes as $style_attribute) {
						if($style_attribute->nodeValue === "XXX9o9stripme9o9XXX" || strlen($style_attribute->nodeValue) === 0) {
							continue;
						}
						$strpos = strpos($style_attribute->nodeValue, $stylesheet_style_information);
						if($strpos !== false) {
							$style_attribute->nodeValue = ReTidy::str_replace_first($stylesheet_style_information, '', $style_attribute->nodeValue);
							$style_attribute->nodeValue = trim(preg_replace('/\s+/is', ' ', $style_attribute->nodeValue));
							if(strlen($style_attribute->nodeValue) === 0) {
								$style_attribute->nodeValue = "XXX9o9stripme9o9XXX";
							}
						}
					}
				}
			} else {
				// see below
			}
		}
		$array_possible_changes = $this->array_classes = array();
		foreach($arrayOfStyleInformation[0] as $index => $selector) {
			$stylesheet_style_information = $arrayOfStyleInformation[1][$index];
			$length_stylesheet_style_information = strlen($stylesheet_style_information);
			if(strpos($selector, ".") === false) {
				// see above
			} else {
				$this->node_style_information_array = $array_selectors = $this->array_classes = $array_class_names = array();
				preg_match_all('/([^\.]*)\.(\w*)/is', $selector, $array_selector_parts);
				$query2 = '/' . ReTidy::get_html_namespace() . '*';
				$root_nodes = $this->xpath->query($query2);
				foreach($root_nodes as $root_node){
					$tag77 = $root_node;
				}
				ReTidy::recursively_add_classes($tag77, $array_selector_parts, $stylesheet_style_information);
				if(sizeof($this->array_classes) > 0) {
					foreach($this->array_classes as $index => $value) {
						$class_name = $value[0];
						$class_node = $value[1];						
						$do_it = true;
						foreach($array_class_names as $class_name2) {
							if($class_name === $class_name2) {
								// then it is already in our class names array, so do not add it again.
								$do_it = false;
								break;
							}
						}
						if($do_it) {
							$array_class_names[] = $class_name;
						}
					}
					// find selectors that have this class in them
					foreach($array_class_names as $class_name2) {
						foreach($arrayOfStyleInformation[0] as $index56 => $selector56) {
							preg_match('/\.' . $class_name2 . ' /is', $selector56 . " ", $matches93);
							$selector56 = str_replace($class_name2, 'XXX9o9' . $class_name2 . '9o9XXX', $selector56);
							if(sizeof($matches93) > 0) {
								// add this selector to the selectors array
								$array_selectors[] = array($index56, $selector56);
							}
						}
					}
					$add_the_class = true;
					foreach($array_selectors as $index => $value) {
						$index56 = $value[0];
						$selector56 = $value[1];
						$stylesheet_style_information56 = $arrayOfStyleInformation[1][$index56];
						$query = ReTidy::selectorToXPath($selector56);
						$tags = $this->xpath->query($query);
						foreach($tags as $tag) {
							$query = "@style";
							$style_attributes = $this->xpath->query($query, $tag);
							foreach($style_attributes as $style_attribute) {
								if($style_attribute->nodeValue === "XXX9o9stripme9o9XXX" || strlen($style_attribute->nodeValue) === 0) {
									continue;
								}
								$strpos = OM::strpos_non_nested($style_attribute->nodeValue, $stylesheet_style_information56, "{", "}");
								if($strpos === false) {
									// break, give up, abort, explode, etc...
									$add_the_class = false;
									break 3;
								} else {
									// we put the array in an array since an array cannot have a duplicated index and since we are using the style information as
									// the index
									$this->node_style_information_array[] = array($stylesheet_style_information56, $style_attribute);
								}
							}
						}
					}
					if($add_the_class) {
						$array_possible_changes[] = array($this->array_classes, $this->node_style_information_array);
					} else {
						foreach($this->array_classes as $index => $value) {
							$class_name = $value[0];
							$class_attribute = $value[1];
							$class_attribute->nodeValue = trim(ReTidy::str_replace_first_whole_word_for_styles($class_name, '', $class_attribute->nodeValue));
						}
					}
				}
			}
		}
		foreach($array_possible_changes as $possible_change) {
			$add_the_class2 = true;
			$array_classes99 = $possible_change[0];
			if($add_the_class2) {
				$node_style_information_array99 = $possible_change[1];
				foreach($node_style_information_array99 as $index => $value) {
					$stylesheet_style_information99 = $value[0];
					$style_attribute = $value[1];
					if($style_attribute->nodeValue === "XXX9o9stripme9o9XXX") {
						$add_the_class2 = false;
						break;
					}
					$strpos = OM::strpos_non_nested($style_attribute->nodeValue, $stylesheet_style_information99, "{", "}");
					if($strpos === false) {
						// break, give up, abort, explode, etc...
						$add_the_class2 = false;
						break;
					}				
				}
			}
			if($add_the_class2) {
				if(sizeof($node_style_information_array99) === 0) {
					foreach($array_classes99 as $index => $value) {
						$class_name = $value[0];
						$class_attribute = $value[1];
						$class_name = 'XXX9o9' . $class_name . '9o9XXX';
						$class_attribute->nodeValue = trim(ReTidy::str_replace_first_whole_word_for_styles($class_name, '', $class_attribute->nodeValue));
					}
				} else {
					foreach($node_style_information_array99 as $index => $value) {
						$information_in_the_node = $value[0];
						$style_attribute_node = $value[1];
						$style_attribute_node->nodeValue = ReTidy::str_replace_first($information_in_the_node, '', $style_attribute_node->nodeValue);
						$style_attribute_node->nodeValue = trim(preg_replace('/\s+/is', ' ', $style_attribute_node->nodeValue));						
						if(strlen($style_attribute_node->nodeValue) === 0) {
							$style_attribute_node->nodeValue = "XXX9o9stripme9o9XXX";
						}
						foreach($array_classes99 as $index => $value) {
							$class_name = $value[0];
							$class_attribute = $value[1];
							$class_name4356 = 'XXX9o9' . $class_name . '9o9XXX';
							$class_attribute->nodeValue = trim(ReTidy::str_replace_first_whole_word_for_styles($class_name4356, $class_name, $class_attribute->nodeValue));
						}						
					}
				}
			} else {
				foreach($array_classes99 as $index => $value) {
					$class_name = $value[0];
					$class_attribute = $value[1];
					$class_name = 'XXX9o9' . $class_name . '9o9XXX';
					$class_attribute->nodeValue = trim(ReTidy::str_replace_first_whole_word_for_styles($class_name, '', $class_attribute->nodeValue));
				}
			}
		}
		return;
	}	

	protected function tally_classes_not_found () {
		$query = '//' . ReTidy::get_html_namespace() . 'head';	
		$heads = $this->xpath->query($query);
		if(!$heads || !$heads->length) {
			print("Did not find &lt;head&gt; (DOM_styles_to_classes_full)<br>\r\n");		
			return false;	
		}
		$styleCode = "";
		// I guess we assume there is only one <head> tag...
		foreach($heads as $head){
			// we assume all style information is in the <head> of the document.
			$styleCode = ReTidy::rec_DOM_getStyleCode($head, $styleCode);
		}
		
		$styleCode = ReTidy::removeComments($styleCode);
		$styleCode = processImportCommands($styleCode);
		// perhaps the way to deal with multiple selectors on the same style information is to, in the pre-arrayed
		// code, replace such sections with individual selectors; each with its copy of the style information:
		// this may not be necessary since the comma in the selector could be replaced by a | for the XPath.
		// I guess it comes down to whether perl regular expressions or XPath is faster; I do not know (2009-03-17).
		// It does simplify the translation from selector to XPath to have only one tag.
		$styleCode = ReTidy::replaceMultipleSelectors($styleCode);
		
		// something tricky: how to turn @media style information into an inline style...
		// is this even possible?
		$styleCode = ReTidy::inlineMediaRules($styleCode);
		
		// when creating this array we must consider that style information can now have curly brackets in it, but until
		// we are sure that this is the correct way to apply inline media rules, then we'll not worry about it since we
		// can assume that the function that creates the array from any such style information will catch the first }
		// and not miss anything...
		$arrayOfStyleInformation = ReTidy::getStylesFromCode($styleCode);
		$arrayOfStyleInformation = ReTidy::pseudoSelectorsToStyleInformation($arrayOfStyleInformation);
		preg_match_all('/class="([^"]*)"/is', $this->code, $matches);
		$array_classes_from_stylesheets = $array_classes_from_file = array();
		foreach($matches[1] as $match) {
			$array_classes_from_file = array_merge($array_classes_from_file, explode(" ", $match));
		}
		foreach($arrayOfStyleInformation[0] as $index => $selector) {
			preg_match_all('/\.(\w*)/is', $selector, $matches2);
			$array_classes_from_stylesheets = array_merge($array_classes_from_stylesheets, $matches2[1]);
		}
		foreach($array_classes_from_file as $class1) {
			$found_it = false;
			foreach($array_classes_from_stylesheets as $class2) {
				if($class1 === $class2) {
					$found_it = true;
					break;
				}
			}
			if(!$found_it) {
				// add this class name to the text file (if it is not already there)
				$contents = file_get_contents("classes.txt");
				if(strpos($contents, "." . $class1 . "\r\n") === false) {
					$contents .= "." . $class1 . "\r\n";
					file_put_contents("classes.txt", $contents);
				}
			}
		}
	}

	protected function DOM_stylesheets_to_styles_on_node($node) {
		ReTidy::cleanStyles();
		$arrayOfStyleInformation = ReTidy::getArrayStyleInformation();
		$arrayOfStyleInformation[0] = array_reverse($arrayOfStyleInformation[0]);
		$arrayOfStyleInformation[1] = array_reverse($arrayOfStyleInformation[1]);
		foreach($arrayOfStyleInformation[0] as $index => $selector) {
			$query = ReTidy::selectorToXPath($selector);
			$tags = $this->xpath->query($query);
			// for a multiply-classed element, the later classes cascade the earlier ones
			// so the order that the style information shall have must match the order of the classes.
			// so for a multiply-classed tag we must find the order of the relevant class and mark this
			// in the style information.
			// upon verification (2009-03-24), fortuitously (albeit lamely), the order of the classes seems unimportant.
			foreach($tags as $tag) {
				// add the style
				ReTidy::addStyleWithoutOverwrite($tag, $arrayOfStyleInformation[1][$index]);
			}
		}
		$query = '//@class';
		$class_attributes = $this->xpath->query($query);
		foreach($class_attributes as $class_attribute) {
			$class_attribute->nodeValue = "XXX9o9stripme9o9XXX";
		}
		return;
	}

	protected function DOM_stylesheets_to_styles() {
		//$ps = $this->xpath->query('//p');
		//print('ps11: ');var_dump($ps, $ps->length, $this->dom);
		//print('$this->code: ' . $this->code);
		ReTidy::cleanStyles();
		ReTidy::setArrayStyleInformation();
		$arrayOfStyleInformation = ReTidy::getArrayStyleInformation();
		//print('arrayOfStyleInformation: ');var_dump($arrayOfStyleInformation);
		$arrayOfStyleInformation[0] = array_reverse($arrayOfStyleInformation[0]);
		$arrayOfStyleInformation[1] = array_reverse($arrayOfStyleInformation[1]);
		foreach($arrayOfStyleInformation[0] as $index => $selector) {
			$query = ReTidy::selectorToXPath($selector);
			$tags = $this->xpath->query($query);
			// for a multiply classed element, the later classes cascade the earlier ones
			// so the order that the style information shall have must match the order of the classes.
			// so for a multiply-classed tag we must find the order of the relevant class and mark this
			// in the style information.
			// upon verification (2009-03-24), fortuitously (albeit lamely), the order of the classes seems unimportant.
			//print('$query, $tags: ');var_dump($query, $tags);
			foreach($tags as $tag) {
				// add the style
				ReTidy::addStyleWithoutOverwrite($tag, $arrayOfStyleInformation[1][$index]);
			}
		}
		// this action assumes that all nodes with class have had style information applied which assumes that correct references to style
		// information exist for all the nodes with class (which can be problematic, for example, in a de-templated page).
		$query = '//@class';
		$class_attributes = $this->xpath->query($query);
		foreach($class_attributes as $class_attribute) {
			$class_attribute->nodeValue = "XXX9o9stripme9o9XXX";
		}
		return;
	}
	
	protected function DOM_embedded_stylesheet_classes_to_styles () {
		$query = '//' . ReTidy::get_html_namespace() . 'head';	
		$heads = $this->xpath->query($query);
		if(!$heads || !$heads->length) {
			print("Did not find &lt;head&gt; (DOM_embedded_stylesheet_classes_to_styles)<br>\r\n");		
			return false;	
		}
		$styleCode = "";
		// I guess we assume there is only one <head> tag...
		foreach($heads as $head){
			// we assume all style information is in the <head> of the document.
			$styleCode = rec_DOM_getEmbeddedStylesheetCode($head, $styleCode);
		}
		$styleCode = ReTidy::removeComments($styleCode);
		$styleCode = removeImportCommands($styleCode);
		// perhaps the way to deal with multiple selectors on the same style information is to, in the pre-arrayed
		// code, replace such sections with individual selectors; each with its copy of the style information:
		$styleCode = replaceMultipleSelectors($styleCode);
		$arrayOfStyleInformation = array();
		$arrayOfStyleInformation = getStylesFromCode($styleCode);
		$query = '//*[@class]';
		$NodesWithClass = $this->xpath->query($query);
		if(!$NodesWithClass || !$NodesWithClass->length) {
			print("Did not find &lt;* class=\"\"&gt; (DOM_classes_to_styles)<br>\r\n");		
			return false;	
		}
		foreach($NodesWithClass as $NodeWithClass) {
			$foundAStyleAttribute = false;
			$style = "";			
			// notice that a style attribute always cascades a class attribute.
			// this is important when considering where to put tranlated class styling in the style attribute
			foreach($NodeWithClass->attributes as $attribute) {
				if($attribute->nodeName === "class") {
					$class_attribute = $attribute;
					// we must consider a multiply classed element. the way to go is probably to create an array
					// of the classes.
					if(strpos(trim($class_attribute->nodeValue), " ") !== false) {
						$classes = explode(" ", $class_attribute->nodeValue);
					} else {
						$classes = array($class_attribute->nodeValue);
					}
				}
			}
			$changed_at_least_one_class_to_a_style = false;
			foreach($classes as $class) {
				$changed_this_class_to_a_style = false;
				$selector_statement = "." . $class;
				foreach($arrayOfStyleInformation[0] as $index => $selector) {	
					if($selector === $selector_statement) {
						// we may have to deal with missing semi-colons here.
						$style .= " " . $arrayOfStyleInformation[1][$index];
						// this must apply all style information that different selectors that select this element
						// have. so far, if selectors are an exact match, I guess it will work. Otherwise, different
						// selector statements that select the same node are not accounted for here (nor are tag-specific
						// selectors (yet - 2008-10-29)).
						$changed_at_least_one_class_to_a_style = true;
						$changed_this_class_to_a_style = true;						
					}
					
					// the above was simple but not good enough.
					elseif(strpos($selector, $selector_statement) !== false) {
						$parent_tag_of_class = $class_attribute->parentNode;
						// first check for an exact tag-class match
						if($selector === $parent_tag_of_class->nodeName . $selector_statement) {
							$style .= " " . $arrayOfStyleInformation[1][$index];
							$changed_at_least_one_class_to_a_style = true;
							$changed_this_class_to_a_style = true;
						} elseif(strpos($selector, " ") === false) {
							// then the class we are trying to convert is a substring of another class
							// so do nothing with this. 
						} else {
							// then we must figure out which tags to style, based on the hierarchy of the CSS selector that 
							// contains this class name.
							$arrayOfHierarchy = explode(" ", $selector);
						}
					}
				}
				if($changed_this_class_to_a_style) {
					$class_attribute->nodeValue = str_replace($class, '', $class_attribute->nodeValue);
				}
			}
			$class_attribute->nodeValue = trim($class_attribute->nodeValue);
			if($changed_at_least_one_class_to_a_style) {
				if(strlen($class_attribute->nodeValue) === 0) {
					$class_attribute->nodeValue = "XXX9o9stripme9o9XXX";
					// even though tidy would probably do this.
				}
			}			
			$style = trim($style);
			foreach($NodeWithClass->attributes as $attribute) {
				if($attribute->nodeName === "style") {
					$foundAStyleAttribute = true;
					// prepend the translated class styling to the style node value
					if($style !== "") {					
						$attribute->nodeValue = $style . " " . $attribute->nodeValue;
					} else {
						print("We probably do not expect this to happen (classes to styles)<br>\r\n");
					}
				}
			}
			if($foundAStyleAttribute === false) {
				// create a style attribute with the translated class.
				$NodeWithClass->setAttribute('style', $style);
			}	
		}
	}		
	
	protected function dekern() {
		/*if(!is_array($this->config['dekern'])) {
			$this->logWarningMsg('Dekerning array was not set; dekerning was skipped.');
			return false;
		}*/
		// we must consider amending this due to the fact that spaces are often inserted after the kerned characters
		// so that maybe we should refer to a dictionary.

		$dekernArray = array(
		'&#306;' => 'IJ',
		'&#307;' => 'ij',
		'&#455;' => 'LJ',
		'&#456;' => 'Lj',
		'&#457;' => 'lj',
		'&#458;' => 'NJ',
		'&#459;' => 'Nj',
		'&#460;' => 'nj',
		'&#497;' => 'DJ',
		'&#498;' => 'Dz',
		'&#499;' => 'dz',
		'&#678;' => 'ts',
		
		'Ĳ' => 'IJ',
		'ĳ' => 'ij',
		'Ǉ' => 'LJ',
		'ǈ' => 'Lj',
		'ǉ' => 'lj',
		'Ǌ' => 'NJ',
		'ǋ' => 'Nj',
		'ǌ' => 'nj',
		'Ǳ' => 'DJ',
		'ǲ' => 'Dz',
		'ǳ' => 'dz',
		'ʦ' => 'ts',

		//'&#63167;' => '---&#63167;---',
		//'&#63168;' => '---&#63168;---',

		'&#64256;' => 'ff',
		'&#64257;' => 'fi',
		'&#64258;' => 'fl',
		'&#64259;' => 'ffi',
		'&#64260;' => 'ffl',
		
		'ﬀ' => 'ff',
		'ﬁ' => 'fi',
		'ﬂ' => 'fl',
		'ﬃ' => 'ffi',
		'ﬄ' => 'ffl',
		);
		$c = $ct = 0;
		foreach($dekernArray as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("dekern[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		$this->logMsgIf("dekern", $ct);
		return true;
	}
	
	protected function citation() {
		$arrayOStrings = OM::getAllOStrings($this->code, '<em', '</em>');
		$array_citation_indicators = array('Act', 'Code', 'Loi', 'Directive', 'Report', 'Policy', 'Charter', 'Rapport', 'Politique', 'Charte', 'Audit', 'Vérification', 'Ruling', 'Règlement', 'R&egrave;glement', 'Regulations', 'Convention', 'Lignes Directrices', 'Normes', 'Budget');
		$array_replaces = array();
		foreach($array_citation_indicators as $index2 => $citation_indicator) {
			foreach($arrayOStrings as $index => $value) {
				$OString = $value[0];
				//$offset = $value[1];
				if(strpos($OString, $citation_indicator) !== false) {
					$array_replaces[$OString] = '<cite' . substr($OString, 3, strlen($OString) - 6) . 'cite>';
				}
			}
		}
		$c = $ct = 0;
		foreach($array_replaces as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$ct += $c;
		}
		$this->logMsgIf("citation", $ct);
	}

	protected function ShiftHeadingsDown() {
		$ShiftHeadingsDownArray = array(
		'<h5' => '<h6',
		'</h5>' => '</h6>',
		'<h4' => '<h5',
		'</h4>' => '</h5>',
		'<h3' => '<h4',
		'</h3>' => '</h4>',
		'<h2' => '<h3',
		'</h2>' => '</h3>',
		'<h1' => '<h2',
		'</h1>' => '</h2>',
		);
		foreach($ShiftHeadingsDownArray as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("ShiftHeadingsDown[" . htmlentities($search) . "]", $c);
			//$ct += $c;
		}
		//$this->logMsgIf("ShiftHeadingsDown", $ct);
		return true;
	}
	
	protected function ShiftHeadingsUp() {
		$ShiftHeadingsUpArray = array(
		'<h2' => '<h1',
		'</h2>' => '</h1>',
		'<h3' => '<h2',
		'</h3>' => '</h2>',
		'<h4' => '<h3',
		'</h4>' => '</h3>',
		'<h5' => '<h4',
		'</h5>' => '</h4>',
		'<h6' => '<h5',
		'</h6>' => '</h5>',
		);
		foreach($ShiftHeadingsUpArray as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$this->logMsgIf("ShiftHeadingsUp[" . htmlentities($search) . "]", $c);
			//$ct += $c;
		}
		//$this->logMsgIf("ShiftHeadingsUp", $ct);
		return true;
	}
	
	protected function WCAG() {
		//print('hi; WCAG.');exit(0);
		$this->code = preg_replace('/<dd([^<>]*?)>
<p>(.*?)<abbr title="section">s.<\/abbr>(.*?)<\/p>
<p(.*?)<\/p>
<\/dd>/is', '<dd$1>
<p>$2<abbr title="section">s</abbr>$3</p>
<p$4</p>
</dd>', $this->code, -1, $section_changes);
		$this->code = preg_replace('/<dd([^<>]*?)>
<p>(.*?)<abbr title="article">art.<\/abbr>(.*?)<\/p>
<p(.*?)<\/p>
<\/dd>/is', '<dd$1>
<p>$2<abbr title="article">art</abbr>$3</p>
<p$4</p>
</dd>', $this->code, -1, $article_changes);
		$this->logMsgIf('section changes', $section_changes);
		$this->logMsgIf('article changes', $article_changes);
		$changes = 0;
		/*if($this->language === 'french') {
			
		} else {
			//$this->code = str_replace('<span title="Espace pour écriture">', '<span title="Space for writing>', $this->code, $count);
			$this->code = preg_replace('/<span title="Espace pour écriture">/is', '<span title="Space for writing>', $this->code, -1, $count);
			$changes += $count;
		}*/
		// difficult footnotes and signature blocks
		/*if($this->language === 'french') {
			//$this->code = preg_replace('/<sup([^<>]*?)>([^<>a-z]*?)</sup>/is', '', $this->code);
			//$difficult_footnoote_changes = 0;
			//preg_match_all('/<sup([^<>]*?)>([^<>a-z]*?)<\/sup>/is', $this->code, $matches);
			//foreach($matches[0] as $index => $value) {
			//	$anchor_text_equivalent = ReTidy::anchor_text_equivalents($matches[2][$index]);
			//	$this->code = str_replace($value, '<!-- difficult footnote --><sup id="fnb' . $anchor_text_equivalent . '-ref"' . $matches[1][$index] . '><a class="footnote-link" href="#fnb' . $anchor_text_equivalent . '"><span class="wb-invisible">Note de bas de page </span>' . $matches[2][$index] . '</a></sup>', $this->code);
			//	$difficult_footnoote_changes++;
			//}
			//$this->logMsgIf('WCAG difficult_footnoote_changes', $difficult_footnoote_changes);
			//$changes += $difficult_footnoote_changes;
			$this->code = preg_replace('/(_{2,})/is', '<span title="Espace pour écriture">$1</span>', $this->code, -1, $underscore_changes);
			$this->logMsgIf('WCAG underscore_changes', $underscore_changes);
			$changes += $underscore_changes;
		} else {
			//$difficult_footnoote_changes = 0;
			//preg_match_all('/<sup([^<>]*?)>([^<>a-z]*?)<\/sup>/is', $this->code, $matches);
			//foreach($matches[0] as $index => $value) {
			//	$anchor_text_equivalent = ReTidy::anchor_text_equivalents($matches[2][$index]);
			//	$this->code = str_replace($value, '<!-- difficult footnote --><sup id="fnb' . $anchor_text_equivalent . '-ref"' . $matches[1][$index] . '><a class="footnote-link" href="#fnb' . $anchor_text_equivalent . '"><span class="wb-invisible">Footnote </span>' . $matches[2][$index] . '</a></sup>', $this->code);
			//	$difficult_footnoote_changes++;
			//}
			//$this->logMsgIf('WCAG difficult_footnoote_changes', $difficult_footnoote_changes);
			//$changes += $difficult_footnoote_changes;
			$this->code = preg_replace('/(_{2,})/is', '<span title="Space for writing">$1</span>', $this->code, -1, $underscore_changes);
			$this->logMsgIf('WCAG underscore_changes', $underscore_changes);
			$changes += $underscore_changes;
		}
		// tables (summary/title/caption) and html entities in h1
		ReTidy::generate_tidyer_DOM();
		$table_accessibility_changes = 0;
		foreach($this->tidyer_DOM as $index => $value) {
			$type = $value[0];
			if($type === 1) { // tag
				$tag_array = $value[1];
				$tag_name = $tag_array[0];
				$tag_type = $tag_array[2];
				if($tag_name === 'h1' && $tag_type === 0) { // opening h1 tag
					$h1_changes = 0;
					$counter = $index + 1;
					while($counter < sizeof($this->tidyer_DOM)) {
						$type2 = $this->tidyer_DOM[$counter][0];
						if($type2 === 0) { // text
							$initial_text = $this->tidyer_DOM[$counter][1];
							$text_with_entities_encoded = htmlentities(html_entity_decode($this->tidyer_DOM[$counter][1]));
							$this->tidyer_DOM[$counter][1] = $text_with_entities_encoded;
							if($initial_text !== $text_with_entities_encoded) {
								$h1_changes++;
							}
							$counter++;
							continue;
						}
						$tag_array2 = $this->tidyer_DOM[$counter][1];
						$tag_name2 = $tag_array2[0];
						$tag_type2 = $tag_array2[2];							
						if($tag_name2 === 'h1' && $tag_type2 === 1) { // closing h1 tag
							break;
						}
						$counter++;
					}
					$this->logMsgIf('WCAG h1_changes', $h1_changes);
					$changes += $h1_changes;
				}
				if($tag_name === 'table' && $tag_type === 0) { // opening table tag
					//var_dump($value);exit(0);
					$found_title = false;
					$found_summary = false;
					$attributes_array = $tag_array[1];
					foreach($attributes_array as $index2 => $value2) {
						$attribute_name = $value2[0];
						//$attribute_value = $value2[1];
						if($attribute_name === 'title') {
							$found_title = true;
							break;
						}
						if($attribute_name === 'summary') {
							$found_summary = true;
							break;
						}
					}
					if(!$found_title && !$found_summary) {
						//print('here4890568-058605<br>');
						$found_caption = false;
						$counter = $index + 1;
						while($counter < sizeof($this->tidyer_DOM)) {
							$tag_array2 = $this->tidyer_DOM[$counter][1];
							$tag_name2 = $tag_array2[0];
							$tag_type2 = $tag_array2[2];
							if($tag_name2 === 'caption' && $tag_type2 === 0) { // opening caption tag
								$found_caption = true;
								break;
							}							
							if($tag_name2 === 'table' && $tag_type2 === 1) { // closing table tag
								break;
							}
							$counter++;
						}
						if(!$found_caption) { // then add a title attribute
							//print('here4890568-058606<br>');
							$counter = $index - 1;
							while($counter > -1) {
								$tag_array3 = $this->tidyer_DOM[$counter][1];
								//print('$tag_array3: ');var_dump($tag_array3);
								$tag_type3 = $tag_array3[2];
								$tag_is_block3 = $tag_array3[3];
								if($tag_is_block3 && $tag_type3 === 0) { // opening block
									$previous_opening_block_index = $counter;
									break;
								}							
								$counter--;
							}
							$title_text = preg_replace('/\s+/is', ' ', ReTidy::get_text_in_tidyer_DOM_tag($previous_opening_block_index));
							if(isset($this->tidyer_DOM[$index][1][1])) {
								//print('here394850564974747<br>');
								$this->tidyer_DOM[$index][1][1][] = array('title', $title_text);
							} else {
								//print('here394850564974748<br>');
								$this->tidyer_DOM[$index][1][1] = array('title', $title_text);
							}
							//print('table attributes array');var_dump($this->tidyer_DOM[$index][1][1]);exit(0);
							$table_accessibility_changes++;
						}
					}
				}
			}
		}
		$this->logMsgIf('WCAG table_accessibility_changes', $table_accessibility_changes);
		$changes += $table_accessibility_changes;
		if($changes > 0) {
			ReTidy::generate_code_from_tidyer_DOM();
			//$this->logMsgIf('WCAG', $changes);
		}*/
	}
	
	protected function get_text_in_tidyer_DOM_tag($tidyer_DOM_index) {
		$tag_array = $this->tidyer_DOM[$tidyer_DOM_index][1];
		$tag_type = $tag_array[2];
		if($tag_type !== 0) {
			print('function get_text_in_tidyer_DOM_tag expects to be given an opening tag but apparently was not.');exit(0);
		}
		$string = '';
		$tag_name = $tag_array[0];
		//print('$tag_name in get_text_in_tidyer_DOM_tag');var_dump($tag_name);
		$counter = $tidyer_DOM_index + 1;
		while($counter < sizeof($this->tidyer_DOM)) {
			$type2 = $this->tidyer_DOM[$counter][0];
			if($type2 === 0) { // text
				$string .= $this->tidyer_DOM[$counter][1];
			}
			if($type2 === 1) { // tag
				$tag_array2 = $this->tidyer_DOM[$counter][1];
				$tag_name2 = $tag_array2[0];
				if($tag_name === $tag_name2) {
					break;
				}
			}
			$counter++;
		}
		return $string;
	}
	
	protected function init_anchor_text_equivalents() {
		if(!isset($this->array_anchor_text_equivalents)) {
			$this->array_anchor_text_equivalents = array(
			'†' => 'dag',
			'*' => 'ast',
			);
		}
		return true;
	}
	
	protected function anchor_text_equivalents($string) {
		ReTidy::init_anchor_text_equivalents();
		foreach($this->array_anchor_text_equivalents as $anchor => $text_equivalent) {
			$string = str_replace($anchor, $text_equivalent, $string);
		}
		return $string;
	}
	
	protected function footnotes() {
		$count1 = $count2 = 0;
		
		$arrayReplaces = array(
		/*
		//' ### footnotes1
		//' *** for styling on text with footnotes
		//' *** spaces in styled footnotes
	
		'<sup><a href="#footnote" title="Link to footnote "><strong><em> ' => ' <sup><a href="#footnote" title="Link to footnote "><strong><em>', 
		'  <sup><a href="#footnote" title="Link to footnote "><strong><em>' => ' <sup><a href="#footnote" title="Link to footnote "><strong><em>', 
		'<sup><a href="#footnote" name="note" title="Link to footnote "><strong><em> ' => ' <sup><a href="#footnote" name="note" title="Link to footnote "><strong><em>', 
		'  <sup><a href="#footnote" name="note" title="Link to footnote "><strong><em>' => ' <sup><a href="#footnote" name="note" title="Link to footnote "><strong><em>', 
		' </em></strong></a></sup>' => '</em></strong></a></sup> ', 
		'</em></strong></a></sup>  ' => '</em></strong></a></sup> ', 
		'<sup><a href="#footnote" title="Link to footnote "><strong> ' => ' <sup><a href="#footnote" title="Link to footnote "><strong>', 
		'  <sup><a href="#footnote" title="Link to footnote "><strong>' => ' <sup><a href="#footnote" title="Link to footnote "><strong>', 
		'<sup><a href="#footnote" name="note" title="Link to footnote "><strong> ' => ' <sup><a href="#footnote" name="note" title="Link to footnote "><strong>', 
		'  <sup><a href="#footnote" name="note" title="Link to footnote "><strong>' => ' <sup><a href="#footnote" name="note" title="Link to footnote "><strong>', 
		' </strong></a></sup>' => '</strong></a></sup> ', 
		'</strong></a></sup>  ' => '</strong></a></sup> ',		
		
		'<sup><a href="#footnote" title="Link to footnote "><em> ' => ' <sup><a href="#footnote" title="Link to footnote "><em>', 
		'  <sup><a href="#footnote" title="Link to footnote "><em>' => ' <sup><a href="#footnote" title="Link to footnote "><em>', 
		'<sup><a href="#footnote" name="note" title="Link to footnote "><em> ' => ' <sup><a href="#footnote" name="note" title="Link to footnote "><em>', 
		'  <sup><a href="#footnote" name="note" title="Link to footnote "><em>' => ' <sup><a href="#footnote" name="note" title="Link to footnote "><em>', 
		' </em></a></sup>' => '</em></a></sup> ', 
		'</em></a></sup>  ' => '</em></a></sup> ', 
		
		//' *** spaces in non-styled footnotes
		//''<a href="#footnote" title="Link to footnote "> ' => '<a href="#footnote" title="Link to footnote ">', 
		'<sup><a href="#footnote" title="Link to footnote "> ' => ' <sup><a href="#footnote" title="Link to footnote ">', 
		'  <sup><a href="#footnote" title="Link to footnote ">' => ' <sup><a href="#footnote" title="Link to footnote ">', 
		//''<a href="#footnote" name="note" title="Link to footnote "> ' => '<a href="#footnote" name="note" title="Link to footnote ">', 
		'<sup><a href="#footnote" name="note" title="Link to footnote "> ' => ' <sup><a href="#footnote" name="note" title="Link to footnote ">', 
		'  <sup><a href="#footnote" name="note" title="Link to footnote ">' => ' <sup><a href="#footnote" name="note" title="Link to footnote ">', 
		//'' </a></sup>' => '</a></sup>', 
		' </a></sup>' => '</a></sup> ', 
		'</a></sup>  ' => '</a></sup> ',
		*/
		
		// as for the styling from these; DOM_combine_inline should take care of this.
		// as for the spaces... we may must write a function for them.
		
		'<a href="#footnote" name="note" title="Link to footnote " id="note"></a>' => '',
		'<sup><a href="#footnote" name="note" title="Link to footnote " id="note"></a></sup>' => '',
		'<a href="#footnote" title="Link to footnote " id="note"></a>' => '',
		'<sup><a href="#footnote" title="Link to footnote " id="note"></a></sup>' => '',
		
		//' ### for a page without footnotes
		'<hr></body>' => '</body>',
		'<hr/></body>' => '</body>',
		'<hr /></body>' => '</body>',
		
		);
		
		$arrayRxp = array(
		//'<a href="#_ftn([0-9]*)" name="_ftnref\1" title="">\[\1\]<\/a>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<a href="#_ftnref([0-9]*)" name="_ftn\1" title="">\[\1\]<\/a>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		//'<a href="#_ftn([0-9]*)" name="_ftnref\1" title=""><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<a href="#_ftnref([0-9]*)" name="_ftn\1" title="">\[\1\]<\/a>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		
		//'<a href="#_ftn([0-9]*)" name="_ftnref\1" title="" id="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<a href="#_ftnref([0-9]*)" name="_ftn\1" title="" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		//'<a href="#_ftn([0-9]*)" name="_ftnref\1" title="" id="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<a href="#_ftnref([0-9]*)" name="_ftn\1" title="" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',

		//'<a href="#_ftn([0-9]*)" name="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<a href="#_ftnref([0-9]*)" name="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		//'<a href="#_ftn([0-9]*)" name="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<a href="#_ftnref([0-9]*)" name="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		
		//'<a href="#_ftn([0-9]*)" name="_ftnref\1" id="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<a href="#_ftnref([0-9]*)" name="_ftn\1" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		//'<a href="#_ftn([0-9]*)" name="_ftnref\1" id="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<a href="#_ftnref([0-9]*)" name="_ftn\1" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',		
		
		//'<sup id="note([0-9]*)" title="Link to footnote \1"><a href="#footnote\1" name="note\1" id="note\1">\[\1\]<\/a><\/sup>' => '<sup><a href="#footnote$1" name="note$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		//'<sup id="footnote([0-9]*)" title="Link to note \1"><a href="#note\1" name="footnote\1" id="footnote\1">\[\1\]<\/a><\/sup>' => '<a href="#note$1" name="footnote$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		// (2011-06-27) the name attribute is deprecated
		
		/*
		'<a href="#_ftn([0-9]*)" name="_ftnref\1" title="">\[\1\]<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" name="_ftn\1" title="">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftn([0-9]*)" name="_ftnref\1" title=""><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" name="_ftn\1" title="">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		
		'<a href="#_ftn([0-9]*)" name="_ftnref\1" title="" id="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" name="_ftn\1" title="" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftn([0-9]*)" name="_ftnref\1" title="" id="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" name="_ftn\1" title="" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',

		'<a href="#_ftn([0-9]*)" name="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" name="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftn([0-9]*)" name="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" name="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		
		'<a href="#_ftn([0-9]*)" name="_ftnref\1" id="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" name="_ftn\1" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftn([0-9]*)" name="_ftnref\1" id="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" name="_ftn\1" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',		
		
		'<sup id="note([0-9]*)" title="Link to footnote \1"><a href="#footnote\1" name="note\1" id="note\1">\[\1\]<\/a><\/sup>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<sup id="footnote([0-9]*)" title="Link to note \1"><a href="#note\1" name="footnote\1" id="footnote\1">\[\1\]<\/a><\/sup>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		
		// ---
		// <a href="#_ftnref1" id="_ftn1"><sup>[1]</sup></a>
		
		'<a href="#_ftn([0-9]*)" id="_ftnref\1" title="">\[\1\]<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" title="">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftn([0-9]*)" id="_ftnref\1" title=""><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" title="">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" title=""><sup>\[\1\]<\/sup><\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		
		'<a href="#_ftn([0-9]*)" id="_ftnref\1" title="" id="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" title="" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftn([0-9]*)" id="_ftnref\1" title="" id="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" title="" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" title="" id="_ftn\1"><sup>\[\1\]<\/sup><\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',

		'<a href="#_ftn([0-9]*)" id="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftn([0-9]*)" id="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1"><sup>\[\1\]<\/sup><\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		
		'<a href="#_ftn([0-9]*)" id="_ftnref\1" id="_ftnref\1">\[\1\]<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftn([0-9]*)" id="_ftnref\1" id="_ftnref\1"><sup>\[\1\]<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" id="_ftn\1">\[\1\]<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		'<a href="#_ftnref([0-9]*)" id="_ftn\1" id="_ftn\1"><sup>\[\1\]<\/sup><\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		
		'<sup id="note([0-9]*)" title="Link to footnote \1"><a href="#footnote\1" id="note\1" id="note\1">\[\1\]<\/a><\/sup>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">[$1]</a></sup>',
		'<sup id="footnote([0-9]*)" title="Link to note \1"><a href="#note\1" id="footnote\1" id="footnote\1">\[\1\]<\/a><\/sup>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">[$1]</a>',
		*/
		
		// 2012-09-30; we trust word to number footnotes correctly and so don't check the text part, completely leaving phys_units to deal with any false footnotes
		
		'<a href="#_ftn([0-9]+)" name="_ftnref\1" title="">([^<>]*?)<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" name="_ftn\1" title="">([^<>]*?)<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		'<a href="#_ftn([0-9]+)" name="_ftnref\1" title=""><sup>([^<>]*?)<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		
		'<a href="#_ftn([0-9]+)" name="_ftnref\1" title="" id="_ftnref\1">([^<>]*?)<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" name="_ftn\1" title="" id="_ftn\1">([^<>]*?)<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		'<a href="#_ftn([0-9]+)" name="_ftnref\1" title="" id="_ftnref\1"><sup>([^<>]*?)<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',

		'<a href="#_ftn([0-9]+)" name="_ftnref\1">([^<>]*?)<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" name="_ftn\1">([^<>]*?)<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		'<a href="#_ftn([0-9]+)" name="_ftnref\1"><sup>([^<>]*?)<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		
		'<a href="#_ftn([0-9]+)" name="_ftnref\1" id="_ftnref\1">([^<>]*?)<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" name="_ftn\1" id="_ftn\1">([^<>]*?)<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		'<a href="#_ftn([0-9]+)" name="_ftnref\1" id="_ftnref\1"><sup>([^<>]*?)<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		
		'<sup id="note([0-9]+)" title="Link to footnote \1"><a href="#footnote\1" name="note\1" id="note\1">([^<>]*?)<\/a><\/sup>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<sup id="footnote([0-9]+)" title="Link to note \1"><a href="#note\1" name="footnote\1" id="footnote\1">([^<>]*?)<\/a><\/sup>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		
		// ---
		// <a href="#_ftnref1" id="_ftn1"><sup>[1]</sup></a>
		
		'<a href="#_ftn([0-9]+)" id="_ftnref\1" title="">([^<>]*?)<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" id="_ftn\1" title="">([^<>]*?)<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		'<a href="#_ftn([0-9]+)" id="_ftnref\1" title=""><sup>([^<>]*?)<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" id="_ftn\1" title=""><sup>([^<>]*?)<\/sup><\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		
		'<a href="#_ftn([0-9]+)" id="_ftnref\1" title="" id="_ftnref\1">([^<>]*?)<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" id="_ftn\1" title="" id="_ftn\1">([^<>]*?)<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		'<a href="#_ftn([0-9]+)" id="_ftnref\1" title="" id="_ftnref\1"><sup>([^<>]*?)<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" id="_ftn\1" title="" id="_ftn\1"><sup>([^<>]*?)<\/sup><\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',

		'<a href="#_ftn([0-9]+)" id="_ftnref\1">([^<>]*?)<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" id="_ftn\1">([^<>]*?)<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		'<a href="#_ftn([0-9]+)" id="_ftnref\1"><sup>([^<>]*?)<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" id="_ftn\1"><sup>([^<>]*?)<\/sup><\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		
		'<a href="#_ftn([0-9]+)" id="_ftnref\1" id="_ftnref\1">([^<>]*?)<\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" id="_ftn\1" id="_ftn\1">([^<>]*?)<\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		'<a href="#_ftn([0-9]+)" id="_ftnref\1" id="_ftnref\1"><sup>([^<>]*?)<\/sup><\/a>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<a href="#_ftnref([0-9]+)" id="_ftn\1" id="_ftn\1"><sup>([^<>]*?)<\/sup><\/a>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',
		
		'<sup id="note([0-9]+)" title="Link to footnote \1"><a href="#footnote\1" id="note\1" id="note\1">([^<>]*?)<\/a><\/sup>' => '<sup><a href="#footnote$1" id="note$1" title="Link to footnote $1">$2</a></sup>',
		'<sup id="footnote([0-9]+)" title="Link to note \1"><a href="#note\1" id="footnote\1" id="footnote\1">([^<>]*?)<\/a><\/sup>' => '<a href="#note$1" id="footnote$1" title="Link to note $1">$2</a>',

		);
		
		// (2012-05-02) "footnote" is not general enough to match sweeper's general usage; that, and it's nice to have configurability
		// defaults
		if(!isset($this->config['french_footnote_reference_anchor_text'])) { $this->config['french_footnote_reference_anchor_text'] = 'Lien à la note '; }
		if(!isset($this->config['french_footnote_anchor_text'])) { $this->config['french_footnote_anchor_text'] = 'Lien &agrave; la r&eacute;f&eacute;rence de la note '; }
		if(!isset($this->config['english_footnote_reference_anchor_text'])) { $this->config['english_footnote_reference_anchor_text'] = 'Link to note '; }
		if(!isset($this->config['english_footnote_anchor_text'])) { $this->config['english_footnote_anchor_text'] = 'Link to note reference '; }
		if(!isset($this->config['footnote_anchor_name'])) { $this->config['footnote_anchor_name'] = 'note'; }
		if(!isset($this->config['footnote_reference_anchor_name'])) { $this->config['footnote_reference_anchor_name'] = 'noteref'; }
		
		if(!isset($this->config['french_endnote_reference_anchor_text'])) { $this->config['french_endnote_reference_anchor_text'] = 'Lien à la note de bas '; }
		if(!isset($this->config['french_endnote_anchor_text'])) { $this->config['french_endnote_anchor_text'] = 'Lien &agrave; la r&eacute;f&eacute;rence de la note de bas '; }
		if(!isset($this->config['english_endnote_reference_anchor_text'])) { $this->config['english_endnote_reference_anchor_text'] = 'Link to endnote '; }
		if(!isset($this->config['english_endnote_anchor_text'])) { $this->config['english_endnote_anchor_text'] = 'Link to endnote reference '; }
		if(!isset($this->config['endnote_anchor_name'])) { $this->config['endnote_anchor_name'] = 'nnote'; }
		if(!isset($this->config['endnote_reference_anchor_name'])) { $this->config['endnote_reference_anchor_name'] = 'nnoteref'; }
		
		foreach($arrayReplaces as $search => $replace) {
			if($this->language === "french") {
				//$replace = str_replace('Link to footnote', 'Lien à la note de bas de page', $replace);
				//$replace = str_replace('Link to note', 'Lien à la note', $replace);
				$replace = str_replace('Link to footnote ', $this->config['french_footnote_reference_anchor_text'], $replace);
				$replace = str_replace('Link to note ', $this->config['french_footnote_anchor_text'], $replace);
			} else {
				$replace = str_replace('Link to footnote ', $this->config['english_footnote_reference_anchor_text'], $replace);
				$replace = str_replace('Link to note ', $this->config['english_footnote_anchor_text'], $replace);
			}
			$replace = str_replace('footnote', $this->config['footnote_anchor_name'], $replace);
			$replace = str_replace('note', $this->config['footnote_reference_anchor_name'], $replace);
			$this->code = str_replace($search, $replace, $this->code, $ct1);
			$count1 += $ct1;
		}
		$array_note_name_types = array(
		'_ftn' => 'footnote',
		'_edn' => 'endnote',
		);
		// consider relevant stuff at the beginning of clean_word that was around line 6975 (2012-09-30);
		// unfortunately we can't make the above array connected to the regular expression without some fancy
		// string to inverse instance regular expression function
		foreach($array_note_name_types as $note_name => $note_type) {
			foreach($arrayRxp as $search => $replace) {
				if($note_name === '_ftn') {
					
				} else {
					$search = str_replace('_ftn', $note_name, $search);
				}
				if($this->language === "french") {
					//$replace = str_replace('Link to footnote', 'Lien à la note de bas de page', $replace);
					//$replace = str_replace('Link to note', 'Lien à la note', $replace);
					//$replace = str_replace('Link to footnote ', $this->config['french_' . $note_type . '_reference_anchor_text'], $replace);
					//$replace = str_replace('Link to note ', $this->config['french_' . $note_type . '_anchor_text'], $replace);
					// references
					$replace = str_replace(' href="#footnote$1" id="note$1" title="Link to footnote ', ' href="#' . $this->config[$note_type . '_anchor_name'] . '$1" id="' . $this->config[$note_type . '_reference_anchor_name'] . '$1" title="' . $this->config['french_' . $note_type . '_reference_anchor_text'], $replace);
					// notes
					$replace = str_replace(' href="#note$1" id="footnote$1" title="Link to note ', ' href="#' . $this->config[$note_type . '_reference_anchor_name'] . '$1" id="' . $this->config[$note_type . '_anchor_name'] . '$1" title="' . $this->config['french_' . $note_type . '_anchor_text'], $replace);
				} else {
					//$replace = str_replace('Link to footnote ', $this->config['english_' . $note_type . '_reference_anchor_text'], $replace);
					//$replace = str_replace('Link to note ', $this->config['english_' . $note_type . '_anchor_text'], $replace);
					// references
					$replace = str_replace(' href="#footnote$1" id="note$1" title="Link to footnote ', ' href="#' . $this->config[$note_type . '_anchor_name'] . '$1" id="' . $this->config[$note_type . '_reference_anchor_name'] . '$1" title="' . $this->config['english_' . $note_type . '_reference_anchor_text'], $replace);
					// notes
					$replace = str_replace(' href="#note$1" id="footnote$1" title="Link to note ', ' href="#' . $this->config[$note_type . '_reference_anchor_name'] . '$1" id="' . $this->config[$note_type . '_anchor_name'] . '$1" title="' . $this->config['english_' . $note_type . '_anchor_text'], $replace);
				}
				//$replace = str_replace('id="' . $note_type, 'id="' . $this->config[$note_type . '_anchor_name'], $replace);
				//$replace = str_replace('note', $this->config[$note_type . '_reference_anchor_name'], $replace);
				//var_dump($search, $replace);
				$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $ct2);
				$count2 += $ct2;
			}
			//var_dump($arrayRxp);
		}
		$this->logMsgIf('footnotes', $count1 + $count2);
	}
	
	protected function headings() {
		// here I guess we would like to ensure that headings have the right heading level (h1, h2, h3, ...)
		// and that they receive anchors so that they may be linked to from the table of contents.
		//ReTidy::force_headings();
		ReTidy::heading_anchors();
	}
	
	protected function heading_anchors() {
		// no longer (2011-08-24) used. it is conceivable that because of bad scripts or other inscrutable reasons we would not like all
		// headings to have an anchor, so we can take the option that the structure() function now offers us for achieving the same end.
		$count = 0;
		$arrayRxp = array(
		//'(<h1>)(<em>)*([0-9]{1,2})' => '$1$2<a name="$3"></a>$3',
		//'(<h2>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5"></a>$3$4$5',
		//'(<h3>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5_$7"></a>$3$4$5$6$7',
		//'(<h4>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5_$7_$9"></a>$3$4$5$6$7$8$9',
		//'(<h2>)(<em>)*([0-9]{1,2})' => '$1$2<a name="$3"></a>$3',
		//'(<h3>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5"></a>$3$4$5',
		//'(<h4>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5_$7"></a>$3$4$5$6$7',
		//'(<h5>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5_$7_$9"></a>$3$4$5$6$7$8$9',
		//'(<h3>)(<em>)*([0-9]{1,2})' => '$1$2<a name="$3"></a>$3',
		//'(<h4>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5"></a>$3$4$5',
		//'(<h5>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5_$7"></a>$3$4$5$6$7',
		//'(<h6>)(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1$2<a name="$3_$5_$7_$9"></a>$3$4$5$6$7$8$9',
		// (2011-06-27) the name attribute is deprecated
		// hmm, this is further complicated by the fact that preexistent id attributes on headings can act as anchors...
		'(<h1)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})' => '$1 id="$5"$2>$4$5',
		'(<h2)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7"$2>$4$5$6$7',
		'(<h3)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7_$9"$2>$4$5$6$7$8$9',
		'(<h4)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7_$9_$11"$2>$4$5$6$7$8$9$10$11',
		'(<h2)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})' => '$1 id="$5"$2>$4$5',
		'(<h3)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7"$2>$4$5$6$7',
		'(<h4)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7_$9"$2>$4$5$6$7$8$9',
		'(<h5)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7_$9_$11"$2>$4$5$6$7$8$9$10$11',
		'(<h3)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})' => '$1 id="$5"$2>$4$5',
		'(<h4)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7"$2>$4$5$6$7',
		'(<h5)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7_$9"$2>$4$5$6$7$8$9',
		'(<h6)( ([^i]|i[^d])[^=]*="[^"]*?")*>(<em>)*([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})(\.)([0-9]{1,2})' => '$1 id="$5_$7_$9_$11"$2>$4$5$6$7$8$9$10$11',
		);
		foreach($arrayRxp as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $ct);
			$count += $ct;
		}
		$this->logMsgIf('heading_anchors', $count);
	}
	
	function taglessBracketless($var) {
		$string = ReTidy::tagless($var);
		$roundOStrings = OM::getAllOStrings($string, "(", ")");
		foreach($roundOStrings as $round) {
			$string = str_replace($round, '', $string);
		}
		$squareOStrings = OM::getAllOStrings($string, "[", "]");
		foreach($squareOStrings as $square) {
			$string = str_replace($square, '', $string);
		}
		$curlyOStrings = OM::getAllOStrings($string, "{", "}");
		foreach($curlyOStrings as $curly) {
			$string = str_replace($curly, '', $string);
		}
		return $string;
	}
	
	function contentless($var) {
		if(is_array($var)) {
			print("003jijnjo");var_dump($var);exit(0);
		} elseif(is_string($var)) {
			$string = $var;
		} elseif(ReTidy::isNode($var)) {
			$string = ReTidy::DOM_getNodeString($var);
		} else {
			var_dump($var);
			print("contentless is not designed to handle this variable type.");exit(0);
		}
		preg_match_all('/<[^<>]+?>/is', $string, $tag_matches);
		$tags_only_string = '';
		foreach($tag_matches[0] as $index => $value) {
			$tags_only_string .= $value;
		}
		return $tags_only_string;
	}
	
	function tagless($var) {
		if(is_array($var)) {
			//print('is array<br>');
			print("003jijnjn");var_dump($var);exit(0);
		} elseif(is_string($var)) {
			//print('is string<br>');
			$string = $var;
		} elseif(ReTidy::isNode($var)) {
			//print('is node<br>');
			$string = ReTidy::DOM_getNodeString($var);
		} else {
			var_dump($var);
			print("tagless is not designed to handle this variable type.");
			//print($this->code);
			var_dump(debug_backtrace());
			exit(0);
		}
		//print('strlen 1: ' . strlen($string) . '<br>');
		$string = ReTidy::remove_ASP($string);
		//print('strlen 2: ' . strlen($string) . '<br>');
		$string = ReTidy::remove_PHP($string);
		//print('strlen 3: ' . strlen($string) . '<br>');
		$string = preg_replace('/<[^<>]*>/is', '', $string);
		//print('strlen 4: ' . strlen($string) . '<br>');
		$string = ReTidy::removePartialTags($string);
		if(is_array($string)) {
			print("003jijnj5");var_dump($string);exit(0);
		}
		//print('strlen 5: ' . strlen($string) . '<br>');
		return $string;
	}
	
	protected function remove_PHP($string) {
		$string = preg_replace('/<\?php.*?\?>/is', '', $string);
		return $string;
	}
	
	protected function remove_ASP($string) {
		$string = preg_replace('/<%.*?%>/is', '', $string);
		return $string;
	}	
	
	protected function DOM_false_footnotes() {
		$count1 = 0;
		
		$arrayFalseFootnotes = array(
		'os',
		'o',
		'&reg;',
		'&#8482;',
		'&copy;',
		'TM',
		'MC',
		'MD',
		'st',
		'nd',
		'rd',
		'th',
		'er',
		'me',
		'e',
		'bre',
		'i&egrave;me',
		'i&egrave;re',
		'&egrave;re',
		'®',
		'™',
		'©',
		'ième',
		'ière',
		'ère',
		);
		
		$arrayEmptyAttributes = array(
		'name' => 'note',
		'id' => 'note',
		'href' => '#footnote',
		'title' => 'Link to footnote ',
		);
		// we could use these to verify that the <a> that is conflationary with the <sup> is indeed for a blank footnote
		// but it should be a rare occurence where we would like to keep the anchor that contains a flase footnote.
		// we could also check that the <sup> and <a> are conflationary ignoring whitespace but simply finding only 
		// the false footnote as the text is probably enough.
		
		$query1 = '//' . ReTidy::get_html_namespace() . 'a';
		$query2 = '//' . ReTidy::get_html_namespace() . 'sup';
		$as = $this->xpath->query($query1);
		$sups = $this->xpath->query($query2);
		foreach($as as $a) {
			$query3 = ReTidy::get_html_namespace() . 'sup';
			$sup_in_as = $this->xpath->query($query3, $a);
			foreach($sup_in_as as $sup_in_a) {
				foreach($arrayFalseFootnotes as $falseFootnote) {
					if(trim(ReTidy::tagless($sup_in_a)) === $falseFootnote) {
						$a->setAttribute("stripme", "y");
						ReTidy::DOM_strip_node($a);
					}
				}
			}
		}
		foreach($sups as $sup) {
			$query4 = ReTidy::get_html_namespace() . 'a';
			$a_in_sups = $this->xpath->query($query4, $sup);
			foreach($a_in_sups as $a_in_sup) {
				foreach($arrayFalseFootnotes as $falseFootnote) {
					if(trim(ReTidy::tagless($a_in_sup)) === $falseFootnote) {
						$a_in_sup->setAttribute("stripme", "y");
						ReTidy::DOM_strip_node($a_in_sup);
					}
				}
			}
		}
	}
	
	protected function DOM_finish_footnotes() {
		// now that false footnotes have been eliminated, finish the real footnotes
		//<a href="#note" name="footnote" title="Link to note " id="footnote">
		//<a name="note" id="note" href="#footnote" title="Link to footnote ">
		// (2011-06-27) the name attribute is deprecated
		//<a href="#note" title="Link to note " id="footnote">
		//<a id="note" href="#footnote" title="Link to footnote ">
		$query1 = '//' . ReTidy::get_html_namespace() . 'a[@href="#note"][@name="footnote"] | //' . ReTidy::get_html_namespace() . 'a[@href="#note"][@title="Link to note "] | //' . ReTidy::get_html_namespace() . 'a[@href="#note"][@id="footnote"]';
		$query2 = '//' . ReTidy::get_html_namespace() . 'a[@href="#footnote"][@name="note"] | //' . ReTidy::get_html_namespace() . 'a[@href="#footnote"][@title="Link to footnote "] | //' . ReTidy::get_html_namespace() . 'a[@href="#footnote"][@id="note"]';
		
		$footnotes = $this->xpath->query($query1);
		$notes = $this->xpath->query($query2);
		foreach($footnotes as $footnote) {
			$tagless = ReTidy::tagless($footnote);
			foreach($footnote->attributes as $attribute) {
				$attribute->nodeValue .= $tagless;
			}
		}
		foreach($notes as $note) {
			$tagless = ReTidy::tagless($note);
			foreach($note->attributes as $attribute) {
				$attribute->nodeValue .= $tagless;
			}
		}		
	}
	
	function array_delete($ary, $key_to_be_deleted, $renumber = false) {
        $new = array();
        if(is_array($key_to_be_deleted)) {
            foreach($key_to_be_deleted as $del => $del2) {
                ReTidy::array_delete($ary, $del, $renumber);
            }
        }
		$did_one = false;
		if($renumber) {
			foreach($ary as $key => $value) {
				if($key != $key_to_be_deleted) {
					$new[] = $value;
				} else {
					$did_one = true;
				}
			}
		} else {
			foreach($ary as $key => $value) {
				if($key != $key_to_be_deleted) {
					$new[$key] = $value;
				} else {
					$did_one = true;
				}
			}
		}
		if($did_one) {
			$ary = $new;
		}
		return $ary;
    }
	
	function array_delete_by_value($ary, $value_to_be_deleted, $renumber = false) {
        $new = array();
        if(is_array($value_to_be_deleted)) {
            foreach($value_to_be_deleted as $del => $del2) {
                ReTidy::array_delete_by_value($ary, $del2, $renumber);
            }
        }
		$did_one = false;
		if($renumber) {
			foreach($ary as $key => $value) {
				if($value != $value_to_be_deleted) {
					$new[] = $value;
				} else {
					$did_one = true;
				}
			}
		} else {
			foreach($ary as $key => $value) {
				if($value != $value_to_be_deleted) {
					$new[$key] = $value;
				} else {
					$did_one = true;
				}
			}
		}
		if($did_one) {
			$ary = $new;
		}
		return $ary;
    }
	
	protected function hasText($node) {
		if(!$node->nodeType) {
			print("This is not a node3904390: ");var_dump($node);print("<br>\r\n");
			return false;
		}
		if($node->nodeType === 3) {
			return true;
		}
		// we also consider entity references to be text
		if($node->nodeType === 5) {
			return true;
		}		
		if($node->hasChildNodes()) {
			foreach($node->childNodes as $child) {
				if(ReTidy::hasText($child)) {
					return true;
				}
			}
		} else {
			return false;
		}
	}
	
	protected function hasTextIgnoringEntities($node) {
		if(!$node->nodeType) {
			print("This is not a node3904391: ");var_dump($node);print("<br>\r\n");
			return false;
		}
		// textContent...
		$tagless = trim(ReTidy::tagless($node));
		if($tagless === "&nbsp;" || strlen($tagless) === 0) {
			return false;
		} else {
			return true;
		}
	}
	
	protected function shiftFootnotesDown() {
		// currently (2014-06-27) is copied from a messy function (shiftFootnotesUp) that probably doesn't do french properly
		preg_match_all('/<a href="([^"]*?)#note([^"]*?)([0-9]+)" id="note([^"]*?)\3" title="([^"]*?)\3">((<[^<>]+>)*?)\3/is', $this->code, $noteParts, PREG_OFFSET_CAPTURE);
		if(sizeof($noteParts[0]) === 0) {
			preg_match_all('/<sup id="fnb([0-9]+)-ref"><a class="footnote-link" href="#fnb\1"><span class="wb-invisible">[^<>]*?<\/span>\1<\/a><\/sup>/is', $this->code, $noteParts, PREG_OFFSET_CAPTURE);
			$size = sizeof($noteParts[0]);
			$count = 0;
			while($size > 0) {
				$index = $size - 1;	
				$num = $noteParts[1][$index][0];
				$numMinusOne = $num - 1;
				$initial_note = $noteParts[0][$index][0];
				$modified_note = str_replace($num, $numMinusOne, $initial_note);
				$offset = $noteParts[0][$index][1];
				$this->code = substr($this->code, 0, $offset) . $modified_note . substr($this->code, $offset + strlen($initial_note));
				$count += 1;
				$size--;
			}
			preg_match_all('/<dt>[^<>]*?([0-9]+)<\/dt>\s*<dd id="fnb\1">\s*<p>.*?<\/p>\s*<p class="footnote-return"><a href="#fnb\1-ref"><span class="wb-invisible">[^<>]*?<\/span>\1<span class="wb-invisible">[^<>]*?<\/span><\/a><\/p>\s*<\/dd>/is', $this->code, $noteParts2, PREG_OFFSET_CAPTURE);
			$size2 = sizeof($noteParts2[0]);
			$count2 = 0;
			while($size2 > 0) {
				$index = $size2 - 1;	
				$num = $noteParts2[1][$index][0];
				$numMinusOne = $num - 1;
				$initial_note = $noteParts2[0][$index][0];
				$modified_note = str_replace($num, $numMinusOne, $initial_note);
				$offset = $noteParts2[0][$index][1];
				$this->code = substr($this->code, 0, $offset) . $modified_note . substr($this->code, $offset + strlen($initial_note));
				$count2 += 1;
				$size2--;
			}
		} else {
			$size = sizeof($noteParts[0]);
			$count = 0;
			while($size > 0) {
				$index = $size - 1;	
				$num = $noteParts[3][$index][0];
				$numMinusOne = $num - 1;
				$initial_note = $noteParts[0][$index][0];
				$modified_note = str_replace($num, $numMinusOne, $initial_note);
				$offset = $noteParts[0][$index][1];
				$this->code = substr($this->code, 0, $offset) . $modified_note . substr($this->code, $offset + strlen($initial_note));
				$count += 1;
				$size--;
			}
		}
		$this->logMsgIf("shiftFootnotesDown (referrer)", $count);
		$this->logMsgIf("shiftFootnotesDown (note)", $count2);
		return true;
	}
	
	protected function shiftFootnotesUp () {
		// currently (2014-06-27) is a messy function that probably doesn't do french properly
		/*
		// required improvements; accounting for <em> and <strong> on footnotes... maybe DOM function?
		// see combine_inline (2009-04-22)
		//preg_match_all('/<sup><a href="#footnote([0-9]{1,3})" name="note\1" title="Link to footnote \1">\1<\/a><\/sup>/', $this->code, $englishNoteParts);
		//preg_match_all('/<a href="#note([0-9]{1,3})" name="footnote\1" title="Link to note \1">\1<\/a>/', $this->code, $englishFootnoteParts);
		//preg_match_all('/<sup><a href="#footnote([0-9]{1,3})" name="note\1" title="Lien &agrave; la r&eacute;f&eacute;rence \1">\1<\/a><\/sup>/', $this->code, $frenchNoteParts);
		//preg_match_all('/<a href="#note([0-9]{1,3})" name="footnote\1" title="Lien à la note \1">\1<\/a>/', $this->code, $frenchFootnoteParts);
		// (2011-06-27) the name attribute is deprecated
		preg_match_all('/<sup><a href="#footnote([0-9]{1,3})" id="note\1" title="Link to footnote \1">\1<\/a><\/sup>/', $this->code, $englishNoteParts);
		preg_match_all('/<a href="#note([0-9]{1,3})" id="footnote\1" title="Link to note \1">\1<\/a>/', $this->code, $englishFootnoteParts);
		preg_match_all('/<sup><a href="#footnote([0-9]{1,3})" id="note\1" title="Lien &agrave; la r&eacute;f&eacute;rence \1">\1<\/a><\/sup>/', $this->code, $frenchNoteParts);
		preg_match_all('/<a href="#note([0-9]{1,3})" id="footnote\1" title="Lien à la note \1">\1<\/a>/', $this->code, $frenchFootnoteParts);
		*/
		
		preg_match_all('/<a href="([^"]*?)#note([^"]*?)([0-9]+)" id="note([^"]*?)\3" title="([^"]*?)\3">((<[^<>]+>)*?)\3/is', $this->code, $noteParts, PREG_OFFSET_CAPTURE);
		if(sizeof($noteParts[0]) === 0) {
			preg_match_all('/<sup id="fnb([0-9]+)-ref"><a class="footnote-link" href="#fnb\1"><span class="wb-invisible">[^<>]*?<\/span>\1<\/a><\/sup>/is', $this->code, $noteParts, PREG_OFFSET_CAPTURE);
			$size = sizeof($noteParts[0]);
			$count = 0;
			while($size > 0) {
				$index = $size - 1;	
				$num = $noteParts[1][$index][0];
				$numPlusOne = $num + 1;
				$initial_note = $noteParts[0][$index][0];
				$modified_note = str_replace($num, $numPlusOne, $initial_note);
				$offset = $noteParts[0][$index][1];
				$this->code = substr($this->code, 0, $offset) . $modified_note . substr($this->code, $offset + strlen($initial_note));
				$count += 1;
				$size--;
			}
			preg_match_all('/<dt>[^<>]*?([0-9]+)<\/dt>\s*<dd id="fnb\1">\s*<p>.*?<\/p>\s*<p class="footnote-return"><a href="#fnb\1-ref"><span class="wb-invisible">[^<>]*?<\/span>\1<span class="wb-invisible">[^<>]*?<\/span><\/a><\/p>\s*<\/dd>/is', $this->code, $noteParts2, PREG_OFFSET_CAPTURE);
			$size2 = sizeof($noteParts2[0]);
			$count2 = 0;
			while($size2 > 0) {
				$index = $size2 - 1;	
				$num = $noteParts2[1][$index][0];
				$numPlusOne = $num + 1;
				$initial_note = $noteParts2[0][$index][0];
				$modified_note = str_replace($num, $numPlusOne, $initial_note);
				$offset = $noteParts2[0][$index][1];
				$this->code = substr($this->code, 0, $offset) . $modified_note . substr($this->code, $offset + strlen($initial_note));
				$count2 += 1;
				$size2--;
			}
		} else {
			$size = sizeof($noteParts[0]);
			//var_dump($size);
			$count = 0;
			
			/*
			$count1 = $count2 = $count3 = $count4 = 0;
			$size1 = sizeof($englishNoteParts[0]);
			$size2 = sizeof($englishFootnoteParts[0]);
			$size3 = sizeof($frenchNoteParts[0]);
			$size4 = sizeof($frenchFootnoteParts[0]);
			*/
			
			while($size > 0) {
				$index = $size - 1;	
				$num = $noteParts[3][$index][0];
				$numPlusOne = $num + 1;
				$initial_note = $noteParts[0][$index][0];
				$modified_note = str_replace($num, $numPlusOne, $initial_note);
				$offset = $noteParts[0][$index][1];
				$this->code = substr($this->code, 0, $offset) . $modified_note . substr($this->code, $offset + strlen($initial_note));
				$count += 1;
				$size--;
			}
		}
		
		/*
		while($size1 > 0) {
			$index = $size1-1;	
			$num = $englishNoteParts[1][$index];
			$numPlusOne = $num+1;
			//$search = '<sup><a href="#footnote' . $num . '" name="note' . $num . '" title="Link to footnote ' . $num . '">' . $num . '</a></sup>';
			//$replace = '<sup><a href="#footnote' . $numPlusOne . '" name="note' . $numPlusOne . '" title="Link to footnote ' . $numPlusOne . '">' . $numPlusOne . '</a></sup>';
			// (2011-06-27) the name attribute is deprecated
			$search = '<sup><a href="#footnote' . $num . '" id="note' . $num . '" title="Link to footnote ' . $num . '">' . $num . '</a></sup>';
			$replace = '<sup><a href="#footnote' . $numPlusOne . '" id="note' . $numPlusOne . '" title="Link to footnote ' . $numPlusOne . '">' . $numPlusOne . '</a></sup>';
			$this->code = str_replace(
			$search, 
			$replace, 
			$this->code, 
			$tempcount1);
			$count1 += $tempcount1;
			$size1--;
		}
		while($size2 > 0) {
			$index = $size2-1;
			$num = $englishFootnoteParts[1][$index];
			$numPlusOne = $num+1;
			//$search = '<a href="#note' . $num . '" name="footnote' . $num . '" title="Link to note ' . $num . '">' . $num . '</a>';
			//$replace = '<a href="#note' . $numPlusOne . '" name="footnote' . $numPlusOne . '" title="Link to note ' . $numPlusOne . '">' . $numPlusOne . '</a>';
			// (2011-06-27) the name attribute is deprecated
			$search = '<a href="#note' . $num . '" id="footnote' . $num . '" title="Link to note ' . $num . '">' . $num . '</a>';
			$replace = '<a href="#note' . $numPlusOne . '" id="footnote' . $numPlusOne . '" title="Link to note ' . $numPlusOne . '">' . $numPlusOne . '</a>';
			$this->code = str_replace(
			$search, 
			$replace, 
			$this->code, 
			$tempcount2);
			$count2 += $tempcount2;		
			$size2--;	
		}
		while($size3 > 0) {
			$index = $size3-1;	
			$num = $frenchNoteParts[1][$index];
			$numPlusOne = $num+1;
			$this->code = str_replace(
			//'<sup><a href="#footnote' . $num . '" name="note' . $num . '" title="Lien &agrave; la r&eacute;f&eacute;rence ' . $num . '">' . $num . '</a></sup>', 
			//'<sup><a href="#footnote' . $numPlusOne . '" name="note' . $numPlusOne . '" title="Lien &agrave; la r&eacute;f&eacute;rence ' . $numPlusOne . '">' . $numPlusOne . '</a></sup>', 
			// (2011-06-27) the name attribute is deprecated
			'<sup><a href="#footnote' . $num . '" id="note' . $num . '" title="Lien &agrave; la r&eacute;f&eacute;rence ' . $num . '">' . $num . '</a></sup>', 
			'<sup><a href="#footnote' . $numPlusOne . '" id="note' . $numPlusOne . '" title="Lien &agrave; la r&eacute;f&eacute;rence ' . $numPlusOne . '">' . $numPlusOne . '</a></sup>', 
			$this->code, 
			$tempcount3);
			$count3 += $tempcount3;	
			$size3--;		
		}
		while($size4 > 0) {
			$index = $size4-1;		
			$num = $frenchFootnoteParts[1][$index];
			$numPlusOne = $num+1;
			$this->code = str_replace(
			//'<a href="#note' . $num . '" name="footnote' . $num . '" title="Lien à la note ' . $num . '">' . $num . '</a>', 
			//'<a href="#note' . $numPlusOne . '" name="footnote' . $numPlusOne . '" title="Lien à la note ' . $numPlusOne . '">' . $numPlusOne . '</a>', 
			// (2011-06-27) the name attribute is deprecated
			'<a href="#note' . $num . '" id="footnote' . $num . '" title="Lien à la note ' . $num . '">' . $num . '</a>', 
			'<a href="#note' . $numPlusOne . '" id="footnote' . $numPlusOne . '" title="Lien à la note ' . $numPlusOne . '">' . $numPlusOne . '</a>', 
			$this->code, 
			$tempcount4);
			$count4 += $tempcount4;
			$size4--;
		}
		
		$ct = $count1 + $count2 + $count3 + $count4;*/
		$this->logMsgIf("shiftFootnotesUp (referrer)", $count);
		$this->logMsgIf("shiftFootnotesUp (note)", $count2);
		return true;
	}
	
	protected function parkscanadaRxp ()
	{
		if(!is_array($this->config['parkscanadaRxp']))
			return false;

		$c = $ct = 0;
		foreach($this->config['parkscanadaRxp'] as $search => $replace) {
			$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
			$this->logMsgIf("parkscanadaRxp[" . htmlentities($search) . "]", $c);
			$ct += $c;
		}
		
		preg_match("/<p align=\"center\"><strong>(Table des mati&egrave;res|Table of Contents)<\/strong><\/p>(.+?)<h1>/is", $this->code, $matches);
		$TableOfContentsInit = $TableOfContents = $matches[2];
		preg_match("/(.*)<\/h4>/is", $TableOfContents, $matches);
		$ContentsPartInit = $ContentsPart = $matches[1];
		
		preg_match("/<h4 align=\"center\">(Liste des tableaux|List of Tables)<\/h4>(.*)/is", $TableOfContents, $matches);
		$TableListInit = $TableList = $matches[2];
		
		$ContentsPart = "<ul>" . $ContentsPart . "</ul>";
		$ContentsPart = str_replace("<p>", "<li>", $ContentsPart);
		$ContentsPart = str_replace("</p>", "</li>", $ContentsPart);

		preg_match("/<li>R&eacute;sum&eacute;<\/li>(.*)<li>Annexes<\/li>/is", $ContentsPart, $matches);
		$NumberedPartOfContentsInit = $NumberedPartOfContents = $matches[1];
		
		
		$NumberedPartOfContents = preg_replace("/(<li>[0-9]{1,2}\. [^<]*)<\/li>(.+?)<li>([0-9]{1,2}\.)/is", "$1<ul>$2</ul></li><li>$3", $NumberedPartOfContents);
		$NumberedPartOfContents = preg_replace("/(<li>[0-9]{1,2}\. [^<]*)<\/li>(.+?)<li>([0-9]{1,2}\.)/is", "$1<ul>$2</ul></li><li>$3", $NumberedPartOfContents);
		$NumberedPartOfContents = preg_replace("/(<li>[0-9]{1,2}\. [^<]*)<\/li>(.+?)<li>([0-9]{1,2}\.)/is", "$1<ul>$2</ul></li><li>$3", $NumberedPartOfContents);
		$NumberedPartOfContents = preg_replace("/(<li>[0-9]{1,2}\. [^<]*)<\/li>(.+?)<li>([0-9]{1,2}\.)/is", "$1<ul>$2</ul></li><li>$3", $NumberedPartOfContents);						

		// would need to use the document object model to apply links to lists of a certain nesting
		
		$TableList = preg_replace("/<p>((Table|Tableau) ([0-9]{1,3}))/", "<a href=\"#$3\">$1", $TableList);
		$TableList = str_replace("</p>", "</a><br>", $TableList);
		$TableList = "<p>" . $TableList . "</p>";
				
		$ContentsPart = str_replace($NumberedPartOfContentsInit, $NumberedPartOfContents, $ContentsPart);
		$TableOfContents = str_replace($ContentsPartInit, $ContentsPart, $TableOfContents);
		$TableOfContents = str_replace($TableListInit, $TableList, $TableOfContents);
		$this->code = str_replace($TableOfContentsInit, $TableOfContents, $this->code);
		
		$this->logMsgIf("parkscanadaRxp", $ct);
		return true;
	}
	
	protected function addAcronymIfNew($acronym, $definition) {
		// we would like to check that the definition is clean here; no extra spaces, no tags or parts thatof
		// (so that our acronyms array does not become polluted with many entries representing the same acronym)
		$IsADuplicate = false;
		foreach($this->acronymsArray as $index => $value) {
			$acronym16 = $this->acronymsArray[$index][0];
			$Existingdefinition16 = $this->acronymsArray[$index][1];			
			if(html_entity_decode($acronym16) === html_entity_decode($acronym)) {
				if($this->config["simple_acronym_detection"]) {
					// This is a useful and inaccurate approximation; we are saying that if we have an accepted definition, then do not look for others.
					$IsADuplicate = true;
				} else {
					$pattern = ReTidy::getDefinitionPattern($acronym);
					preg_match('/' . $pattern . '/is', $definition, $matches17);
					if(sizeof($matches17) > 0 && strlen($definition) > 0) {
						if(is_array($Existingdefinition16)) {
							foreach($Existingdefinition16 as $definition18) {
								if ($definition18 === $definition || ReTidy::areSimilarDefinitions($definition18, $definition)) {
									$IsADuplicate = true;
									break 2;
								}				
							}
						} else {
							if ($Existingdefinition16 === $definition || ReTidy::areSimilarDefinitions($Existingdefinition16, $definition)) {
								$IsADuplicate = true;
								break;
							}			
						}
					} else {
						$IsADuplicate = true;
					}
				}
			}
		}
		if(!$IsADuplicate) {
			foreach($this->newAcronymsArray as $index => $value) {
				$acronym16 = $this->newAcronymsArray[$index][0];
				$Existingdefinition16 = $this->newAcronymsArray[$index][1];
				if(html_entity_decode($acronym16) === html_entity_decode($acronym)) {
					if(is_array($Existingdefinition16)) {
						foreach($Existingdefinition16 as $definition18) {
							if ($definition18 === $definition) {
								$IsADuplicate = true;
								break 2;
							}				
						}
					} else {
						if ($Existingdefinition16 === $definition) {
							$IsADuplicate = true;
							break;
						}			
					}
				}
			}
		}
		if(!$IsADuplicate) {
			$acronymExists = false;
			foreach($this->newAcronymsArray as $index => $value) {
				$acronym17 = $this->newAcronymsArray[$index][0];
				$definition17 = $this->newAcronymsArray[$index][1];				
				if($acronym17 === $acronym) {
					$acronymExists = true;
					if(is_array($definition17)) {
						$this->newAcronymsArray[$index][1][] = $definition;
					} else {
						$this->newAcronymsArray[$index][1] = array($this->newAcronymsArray[$index][1], $definition);
					}
					break;
				}
			}
			if(!$acronymExists) {
				$this->newAcronymsArray[] = array($acronym, $definition);
			}
		}
	}
	
	protected function addAcronym($acronym, $definition) {
		// this function is here for debugging
		$acronymExists = false;
		foreach($this->newAcronymsArray as $index => $value) {
			$acronym17 = $this->newAcronymsArray[$index][0];
			$definition17 = $this->newAcronymsArray[$index][1];				
			if($acronym17 === $acronym) {
				$acronymExists = true;
				if(is_array($definition17)) {
					$this->newAcronymsArray[$index][1][] = $definition;
				} else {
					$this->newAcronymsArray[$index][1] = array($this->newAcronymsArray[$index][1], $definition);
				}
				break;
			}
		}
		if(!$acronymExists) {
			$this->newAcronymsArray[] = array($acronym, $definition);
		}
	}

	protected function areSimilarDefinitions($Existingdefinition16, $definition) {
		$definition = html_entity_decode($definition);
		$definition = strtolower($definition);
		$Existingdefinition16 = html_entity_decode($Existingdefinition16);
		$Existingdefinition16 = strtolower($Existingdefinition16);
		foreach($this->stopWords as $stopWord) {
			$definition = ReTidy::str_replace_whole_word_for_styles($stopWord, '', $definition);
			$Existingdefinition16 = ReTidy::str_replace_whole_word_for_styles($stopWord, '', $Existingdefinition16);
		}
		$definition = preg_replace('/\s{2,}/s', ' ', $definition);
		$Existingdefinition16 = preg_replace('/\s{2,}/s', ' ', $Existingdefinition16);
		if($Existingdefinition16 == substr($definition, 0, strlen($Existingdefinition16))) {
			return true;
		}
		if($definition == substr($Existingdefinition16, 0, strlen($definition))) {
			return true;
		}
		return false;	
	}

	protected function find_abbr() {
		ReTidy::abbr_init();

		// look for <abbr>s to get abbr and definition
		preg_match_all('/<abbr title="([^"]*)">([^<]*)<\/abbr>/is', $this->code, $abbr_matches);
		foreach($abbr_matches[0] as $index => $value) {
			$abbr = $abbr_matches[2][$index];
			$definition = $abbr_matches[1][$index];
			ReTidy::addAcronymIfNew($abbr, $definition);
			//ReTidy::addAcronym($abbr, $definition);
		}

		$acronym_pattern2 = $this->acronym_pattern;
		
		// find any uppercase words (then compare to arrayofNonAcronyms)
		// should be finding only uppercase words outside of comments, attributes, etc... so:
		$taglessEntitylessCode = html_entity_decode(ReTidy::tagless($this->code));
		$EntitylessCode = html_entity_decode($this->code);

		$this->new_abbreviation_possibilities = 0;
		// we look in both the tagged and untagged code because they each have advantages and disadvantages; the tagged code has content better 
		// separated and the untagged code may find more acronyms because the tags do not interfere with the acronym finding criteria.
		// I suppose it to be possible to only need to do one of these if the matching criteria were more stringent, however the definition of
		// an acronym is not stringent and so our criteria must remain somewhat inclusive whereafter a human must verify what the program has found.
		ReTidy::findAbbreviationsAndDefinitions($acronym_pattern2, $taglessEntitylessCode);
		ReTidy::findAbbreviationsAndDefinitions($acronym_pattern2, $EntitylessCode);
		$this->newAcronymsArray = ReTidy::cleanAcronymsArray($this->newAcronymsArray);

		ReTidy::saveAcronyms();
		return true;
	}
	
	protected function find_acronyms() {
		ReTidy::acronym_init();
		
		// look for <acronym>s to get acronym and definition
		preg_match_all('/<acronym title="([^"]*)">([^<]*)<\/acronym>/is', $this->code, $acronym_matches);
		foreach($acronym_matches[0] as $index => $value) {
			$acronym = $acronym_matches[2][$index];
			$definition = $acronym_matches[1][$index];
			ReTidy::addAcronymIfNew($acronym, $definition);
			//ReTidy::addAcronym($acronym, $definition);
		}
		
		// compare to a file with words that are assumed not to be acronyms
		// note that with an exceptions file with 1/3 x 10^6 entries this may take a very long time.
		// was never really used (2009-05-15). we may have to break on something other than \r\n for either of these files
		/*
		if($this->language === "english") {
			$this->arrayofNonAcronyms = array_merge($this->arrayofNonAcronyms, explode("\r\n", file_get_contents('abbr' . DS . 'eng' . DS . 'words.txt')));
		}
		if($this->language === "french") {
			$this->arrayofNonAcronyms = array_merge($this->arrayofNonAcronyms, explode("\r\n", file_get_contents('abbr' . DS . 'fra' . DS . 'mots.txt')));		
		}
		*/

		$acronym_pattern2 = $this->acronym_pattern;
		
		/*
		// Find the acronyms section then the acronyms and corresponding definitions
		// Needs work to be useful but may not be necessary; if normal acronym detection is sufficient (2009-05-20)
		// The definitions found from an acronyms section are considered to be reliable. That is why we do this first when trying to find definitions.
		preg_match_all('/Acronym/is', $this->code, $matches9, PREG_OFFSET_CAPTURE);
		//var_dump($matches9);exit(0);
		if(sizeof($matches9[0]) > 0) {
			foreach($matches9[0] as $index => $value) {
				$offset = $value[1];
				$prior_string = substr($this->code, 0, $offset);
				$reversed_prior_string = strrev($prior_string);
				// We are here considering an acronym section formatted as a table. Other formattings a re possible; list, <div>s...
				$pos_close = strpos($reversed_prior_string, strrev("</table>"));
				$pos_open = strpos($reversed_prior_string, strrev("<table"));
				if($pos_open > $pos_close) {
					
				} else {
					//print("We are in a table.<br>\r\n");
					$pos_end_this_acronym_section = strpos($this->code, "</table>", $offset);
					preg_match_all("/<tr[^<>]*>(.*?)<\/tr>/is", substr($this->code, $offset, $pos_end_this_acronym_section), $matches29);
					foreach($matches29[1] as $row_code) {
						//print($row_code . "<br>\r\n");
						//preg_match_all("/<td/is", $row_code, $matches30);
						preg_match_all("/<td[^<>]*>(.*?)<\/td>/is", $row_code, $matches30);
						preg_match_all("/<th[^<>]*>(.*?)<\/th>/is", $row_code, $matches31);
						$matches32 = array_merge($matches30[0], $matches31[0]);
						if(sizeof($matches32) > 0) {
							$acronym30 = ReTidy::tagless($matches32[0]);
							$definition30 = ReTidy::tagless($matches32[1]);
							preg_match($acronym_pattern2, "~" . $acronym30 . "~", $matches51);							
							if(sizeof($matches51) > 0) {
								ReTidy::addAcronymIfNew($acronym30, $definition30);
								//ReTidy::addAcronym($acronym30, $definition30);
							}
						}
					}
				}
			}
		}*/
		
		// find any uppercase words (then compare to arrayofNonAcronyms)
		// should be finding only uppercase words outside of comments, attributes, etc... so:
		$taglessEntitylessCode = html_entity_decode(ReTidy::tagless($this->code));
		$EntitylessCode = html_entity_decode($this->code);		

		// we look in both the tagged and untagged code because they each have advantages and disadvantages; the tagged code has content better 
		// separated and the untagged code may find more acronyms because the tags do not interfere with the acronym finding criteria.
		// I suppose it to be possible to only need to do one of these if the matching criteria were more stringent, however the definition of
		// an acronym is not stringent and so our criteria must remain somewhat inclusive whereafter a human must verify what the program has found.
		ReTidy::findAcronymsAndDefinitions($acronym_pattern2, $taglessEntitylessCode);
		ReTidy::findAcronymsAndDefinitions($acronym_pattern2, $EntitylessCode);
		$this->newAcronymsArray = ReTidy::cleanAcronymsArray($this->newAcronymsArray);
		ReTidy::saveAcronyms();
		$new_acronyms_file_contents = file_get_contents($this->newAcronymsFile);
		$lines = explode('
', $new_acronyms_file_contents);
		if(strlen($new_acronyms_file_contents) > 0) {
			$this->logMsg(sizeof($lines) - 1 . ' abbreviation possibilities found.');
			print("Review " . $this->newAcronymsFile . " and copy proper abbreviations into " . $this->acronymsFile . ".<br>\r\n");
		} else {
			$this->logMsg('0 abbreviation possibilities found.');
		}
		return true;
	}
	
	function cleanAcronymsArray($acronymsArray) {
		sort($acronymsArray);
		$acronymsArray = array_filter($acronymsArray, "EliminateEmptyArrayEntries");
		$acronymsArray = array_filter($acronymsArray, "EliminateFalseArrays");
		$acronymsArray = ReTidy::EliminateDuplicateDefinitions($acronymsArray);		
		$acronymsArray = ReTidy::arrayUnique($acronymsArray);
		return $acronymsArray;
	}
	
	function EliminateDuplicateDefinitions($input_array) {
		$output_array = array();
		foreach($input_array as $index => $value) {
			$acronym = $value[0];
			$definition = $value[1];		
			if(is_array($definition)) {
				$definition = array_unique($definition);
			}
			$output_array[$index] = array($acronym, $definition);
		}
		return $output_array;
	}	
	
	function arrayUnique($myArray) {
		if(!is_array($myArray)) {
		   return $myArray;
		}
		foreach($myArray as &$myvalue) {
			$myvalue = serialize($myvalue);
		}
		$myArray = array_unique($myArray);
		foreach($myArray as &$myvalue) {
			$myvalue = unserialize($myvalue);
		}
		return $myArray;
	}
	
	function getAbbreviationDefinitionPattern($match) {
		$stop_word_string = implode('|', $this->stopWords);
		$pattern = "";
		// this should remove periods at the ends of abbreviated parts.
		$match = preg_replace('/[^a-zŒÇÄÉÆÖÜÑ ]/i', '', $match);
		$len_match = strlen($match);
		$words = explode(" ", $match);
		$count38 = 0;
		foreach($words as $word) {
			$count38++;
			$chars = str_split($word);
			foreach($chars as $character) {
				$pattern .= "(" . $character . "[^\s<>=\"]*?)";
			}
			if($len_match === $count38) {
				// no stop words
			} else {
				$pattern .= "(\s+((" . $stop_word_string . ")\s+){0,4})";
			}
		}
		return $pattern;
	}
	
	function getDefinitionPattern($match) {
		$stop_word_string = implode('|', $this->stopWords);
		$pattern = "";
		$match = preg_replace('/[^a-zŒÇÄÉÆÖÜÑ]/i', '', $match);
		$len_match = strlen($match);
		$chars = str_split($match);
		$count38 = 0;
		// this should work and could possibly help english even though it uses french characters... although the possible lack of treatment of raw characters may be a problem
		foreach($chars as $character) {
			if($character === "E") {
				$character = "[e" . html_entity_decode("&eacute;") . html_entity_decode("&egrave;") . html_entity_decode("&ecirc;") . "]";
			}
			$count38++;
			if($len_match === $count38) {
				$pattern .= "((([dl](['" . html_entity_decode("&rsquo;") . "]|&rsquo;|&#8217;)){0,1}" . $character . "[^\s<>=\"]+)|(" . $character . "))";
			} elseif($count38 === 1) {
				$pattern .= "((" . $character . "[^\s<>=\"]+\s+((" . $stop_word_string . ")\s+){0,4})|(" . $character . "[^\s<>=\"]+\s+([^\s<>=\"]+\s+){0,1}?)|(" . $character . "[^\s<>=\"]+)|(" . $character . "))";
			} else {
				$pattern .= "((([dl](['" . html_entity_decode("&rsquo;") . "]|&rsquo;|&#8217;)){0,1}" . $character . "[^\s<>=\"]+\s+((" . $stop_word_string . ")\s+){0,4})|(([dl](['" . html_entity_decode("&rsquo;") . "]|&rsquo;|&#8217;)){0,1}" . $character . "[^\s<>=\"]+\s+([^\s<>=\"]+\s+){0,1}?)|(([dl](['" . html_entity_decode("&rsquo;") . "]|&rsquo;|&#8217;)){0,1}" . $character . "[^\s<>=\"]+)|(" . $character . "))";
			}
		}
		return $pattern;
	}
	
	function findAbbreviationDefinitions($match, $offset, $taglessEntitylessCode) {
		$defArray = array();
		// first try to find its definition
		$definition = "definition";
		$neighborhoodOfAcronym = substr($taglessEntitylessCode, $offset+strlen($match), 100);
		$neighborhoodOfAcronym2 = substr($taglessEntitylessCode, $offset-100, 100);
		$pattern = ReTidy::getAbbreviationDefinitionPattern($match);
		preg_match_all('/' . $pattern . '/is', $neighborhoodOfAcronym, $matches17);
		preg_match_all('/' . $pattern . '/is', $neighborhoodOfAcronym2, $matches18);
		if(sizeof($matches17[0]) > 0) {
			foreach($matches17[0] as $index => $value) {
				$definition = $value;
				$definition = ReTidy::tagless($definition);
				$definition = trim(preg_replace('/\s+/is', ' ', $definition));
				if(strlen($definition) > 0 && !ReTidy::areSimilarDefinitions($match, $definition)) {
					$defArray[] = $definition;
				}
			}
		}
		if(sizeof($matches18[0]) > 0) {
			foreach($matches18[0] as $index => $value) {
				$definition = $value;
				$definition = ReTidy::tagless($definition);
				$definition = trim(preg_replace('/\s+/is', ' ', $definition));
				if(strlen($definition) > 0 && !ReTidy::areSimilarDefinitions($match, $definition)) {
					$defArray[] = $definition;					
				}
			}
		}
		if(sizeof($defArray) > 0) {
			return $defArray;
		} else {
			return array("definition");
		}
	}
	
	function findDefinitions($match, $offset, $taglessEntitylessCode) {
		$defArray = array();
		// first try to find its definition
		$definition = "definition";
		//$neighborhoodOfAcronym = substr($taglessEntitylessCode, $offset+strlen($match), 100);
		//$neighborhoodOfAcronym2 = substr($taglessEntitylessCode, $offset - 100, 100);
		if($this->config_profile === 'find_abbr') { // crude, if it works at all
			$neighborhoodOfAcronym = substr($taglessEntitylessCode, $offset + strlen($match), $this->config['near_for_acronyms_finding']);
			$neighborhoodOfAcronym2 = substr($taglessEntitylessCode, $offset - $this->config['near_for_acronyms_finding'], $this->config['near_for_acronyms_finding']);
		} else {
			$neighborhoodOfAcronym = substr($taglessEntitylessCode, $offset + strlen($match), $this->config['near_for_acronyms_application']);
			$neighborhoodOfAcronym2 = substr($taglessEntitylessCode, $offset - $this->config['near_for_acronyms_application'], $this->config['near_for_acronyms_application']);
		}
		$pattern = ReTidy::getDefinitionPattern($match);
		// this regular expression can throw an error like
		// Warning: preg_match_all(): Compilation failed: regular expression is too large at offset 8635 in C:\wamp\www\sweeper\retidy.php on line 2199
		preg_match_all('/' . $pattern . '/is', $neighborhoodOfAcronym, $matches17);
		preg_match_all('/' . $pattern . '/is', $neighborhoodOfAcronym2, $matches18);
		if(sizeof($matches17[0]) > 0) {
			foreach($matches17[0] as $index => $value) {
				$definition = $value;
				$definition = ReTidy::tagless($definition);
				$definition = trim(preg_replace('/\s+/is', ' ', $definition));
				if(strlen($definition) > 0 && !ReTidy::areSimilarDefinitions($match, $definition)) {
					$defArray[] = $definition;
				}
			}
		}
		if(sizeof($matches18[0]) > 0) {
			foreach($matches18[0] as $index => $value) {
				$definition = $value;
				$definition = ReTidy::tagless($definition);
				$definition = trim(preg_replace('/\s+/is', ' ', $definition));
				if(strlen($definition) > 0 && !ReTidy::areSimilarDefinitions($match, $definition)) {
					$defArray[] = $definition;					
				}
			}
		}
		if(sizeof($defArray) > 0) {
			return $defArray;
		} else {
			return array("definition");
		}
	}						

	function findAcronymsAndDefinitions($acronym_pattern2, $code) {
		// split it into 64K blocks since preg has a max string length?
		$strlen = strlen($code);
		$big_offset = 0;
		// restrict the length of acronyms
		if(isset($this->config['maximum_acronym_length'])) {
			$maximum_acronym_length = $this->config['maximum_acronym_length'];
		} else {
			$maximum_acronym_length = 12;
		}
		//$do_the_abbr_count = false;
		//if(!isset($this->abbr_found)) {
		//	$do_the_abbr_count = true;
		//}
		while($big_offset < $strlen) {
			preg_match_all($acronym_pattern2, substr($code, $big_offset, 64000), $matches, PREG_OFFSET_CAPTURE);
			//if($do_the_abbr_count) {
			//	$this->abbr_found += sizeof($matches[0]);
			//}
			foreach($matches[0] as $index => $value) {
				$match = $matches[2][$index][0];
				$offset = $matches[2][$index][1] + $big_offset;
				if(strlen($match) > 1 && strlen($match) < $maximum_acronym_length) {
					$IsAnAcronym = true;				
					foreach($this->stopWords as $index => $NonAcronymPart) {
						// if this is completely a stop word
						if(strpos(strtolower($NonAcronymPart), strtolower($match)) === 0) {
							$IsAnAcronym = false;
							break;
						}				
					}
					if($IsAnAcronym) {
						foreach($this->arrayofNonAcronyms as $index => $NonAcronym) {
							if($NonAcronym === $match) {
								// we call this not an acronym
								$IsAnAcronym = false;
								// exit loop
								break;
							}
						}
					}
					if($IsAnAcronym === true) {
						// clean acronym of extra space...
						$match = preg_replace('/\s+/s', ' ', $match);
						$defArray = ReTidy::findDefinitions($match, $offset, $code);
						foreach($defArray as $definition) {
							ReTidy::addAcronymIfNew($match, $definition);
							//ReTidy::addAcronym($match, $definition);
						}
					}
				}
			}
			$big_offset += 60000;
		}
	}
	
	function findAbbreviationsAndDefinitions($acronym_pattern2, $code) {
		ReTidy::words_init();
		preg_match_all($acronym_pattern2, $code, $matches, PREG_OFFSET_CAPTURE);
		// restrict the length of acronyms
		if(isset($this->config['maximum_acronym_length'])) {
			$maximum_acronym_length = $this->config['maximum_acronym_length'];
		} else {
			$maximum_acronym_length = 12;
		}
		//$do_the_abbr_count = false;
		//if(!isset($this->abbr_found)) {
		//	//$do_the_abbr_count = true;
		//	$this->abbr_found += sizeof($matches[0]);
		//}
		//if($do_the_abbr_count) {
		//	$this->abbr_found += sizeof($matches[0]);
		//}
		foreach($matches[0] as $index => $value) {
			$match = $matches[2][$index][0];
			$offset = $matches[2][$index][1];
			if(strlen($match) > 1 && strlen($match) < $maximum_acronym_length) {
				$IsAnAcronym = true;				
				foreach($this->stopWords as $index => $NonAcronymPart) {
					// if this is completely a stop word
					if(strpos(strtolower($NonAcronymPart), strtolower($match)) === 0) {
						$IsAnAcronym = false;
						break;
					}				
				}
				if($IsAnAcronym) {
					foreach($this->arrayofNonAcronyms as $index => $NonAcronym) {
						if($NonAcronym === $match) {
							// we call this not an acronym
							$IsAnAcronym = false;
							// exit loop
							break;
						}
					}
				}
				$periodless = substr($match, 0, strlen($match)-1);
				if($IsAnAcronym) {
					// check if it only contains number characters
					preg_match('/[0-9\.,\$%\(\)]*/', $periodless, $number_matches);
					if($periodless === $number_matches[0]) {
						$IsAnAcronym = false;
						break;
					}
				}
				if($IsAnAcronym) {
					// check against a word list
					foreach($this->words_array as $word) {
						//print("word: ");var_dump($word);print("<br>\r\n");
						if(strtolower($word) === strtolower($periodless)) {
							//print("abbreviation false by word: ");var_dump($periodless);print("<br>\r\n");
							$IsAnAcronym = false;
							break;
						}
					}
				}
				if($IsAnAcronym === true) {
					//print("abbreviation: ");var_dump($match);print("<br>\r\n");
					// clean acronym of extra space...
					$match = preg_replace('/\s+/s', ' ', $match);
					$defArray = ReTidy::findAbbreviationDefinitions($match, $offset, $code);
					foreach($defArray as $definition) {
						ReTidy::addAcronymIfNew($match, $definition);
						//ReTidy::addAcronym($match, $definition);
					}
				}
			}
		}
	}
	
	function removePartialTags($string) {
		//print('removePartialTags initial string: ' . $string);
		$pos_close = strpos($string, ">");
		if($pos_close != false) {
			$string = substr($string, $pos_close + 1);
		}
		$pos_open = strpos($string, "<");
		if($pos_open != false) {
			$string = substr($string, 0, $pos_open);
		}
		//print('removePartialTags cleaned string: ' . $string);
		return $string;
	}

	function sortAcronyms() {
		sort($this->acronymsArray);
		ReTidy::saveAcronymsFile($this->acronymsFile, $this->acronymsArray);
		$this->acronymsArray = ReTidy::cleanAcronymsArray($this->acronymsArray);
		if(isset($this->newAcronymsArray)) {
			sort($this->newAcronymsArray);
			ReTidy::saveAcronymsFile($this->newAcronymsFile, $this->newAcronymsArray);
		}
	}
	
	function sortAllAcronyms() {
		$EngDepFile = 'abbr' . DS . 'eng' . DS . 'acronyms-GEDS.txt';
		$EngDepContents = file_get_contents($EngDepFile);
		$EngArray = explode("\r\n", $EngDepContents);
		sort($EngArray);
		foreach($EngArray as $acronym_tab_definition) {
			$acronym = substr($acronym_tab_definition, 0, strpos($acronym_tab_definition, "	"));
			$this->department = $acronym;
			ReTidy::acronym_init();
			ReTidy::sortAcronyms();
			ReTidy::cleanAcronymsFile($this->acronymsFile);
		}
	}	
	
	function purgeOldAcronymsFiles($path = "acronyms") {
		if(is_dir($path)) {
			$d = dir($path);
			while(FALSE !== ($entry = $d->read())) {
				if($entry == '.' || $entry == '..') {
					continue;
				}
				$Entry = $path . '/' . $entry;           
				if(is_dir($Entry)) {
					ReTidy::purgeOldAcronymsFiles($Entry);
					continue;
				}
				if(strpos($Entry, ".txt")) {
					preg_match('/-20[0-9]{2}(0[1-9]|1[012])(0[1-9]|1[0-9]|2[0-9]|3[01])-/', $Entry, $date_matches);
					if(strlen($date_matches[0]) > 0) {
						// delete it
						print("1");var_dump($Entry);print("<br>\r\n");
						unlink($Entry);
					}
				}
			}
			$d->close();
		} else {
			if(strpos($path, ".txt")) {
				preg_match('/-20[0-9]{2}(0[1-9]|1[012])(0[1-9]|1[0-9]|2[0-9]|3[01])-/', $path, $date_matches);
				if(strlen($date_matches[0]) > 0) {
					// delete it
					print("2");var_dump($path);print("<br>\r\n");
					unlink($path);
				}
			}
		}
	}
	
	function cleanAcronymsFile($filename) {
		$initial_contents = file_get_contents($filename);
		//$contents = iconv('iso-8859-1', $this->config['encoding'] . "//TRANSLIT", $initial_contents);
		$contents = $initial_contents;
		$special_chars_array = DTD::getEntities('DTD' . DS . 'xhtml-special-for-acronyms.ent');
		//$ct1 = 0;
		foreach($special_chars_array as $index => $value) {
			$special_char = html_entity_decode($value[1]);
			if(strpos($contents, $special_char) !== false) {
				$contents = str_replace($special_char, htmlentities($special_char), $contents);
				print("Acronyms file repaired: " . $filename . ". unencoded " . htmlentities(htmlentities($special_char)) . " was found.<br>\r\n");
				//$ct1++;
			}
		}
		$contents = str_replace('

', '
', $contents, $tab_counter);
		//$ct1 += $tab_counter;
		$contents = str_replace('	
', '', $contents, $tab_counter2);
		//$ct1 += $tab_counter;
		//$ct1 += $tab_counter2;
		if($initial_contents != $contents) {
			//file_put_contents($filename, iconv($this->config['encoding'], 'iso-8859-1' . "//TRANSLIT", $contents));
			file_put_contents($filename, $contents);
		}
	}	

	function saveAcronyms() {
		$newContents = "";
		foreach($this->newAcronymsArray as $index => $value) {
			$acronym = $value[0];
			$definition = $value[1];
			if(is_array($definition)) {
				foreach($definition as $def) {
					$newContents .= $acronym . '	' . $def . '
';
				}
			} else {
				$newContents .= $acronym . '	' . $definition . '
';			
			}
		}
		//$oldContents = iconv('iso-8859-1', $this->config['encoding'] . "//TRANSLIT", file_get_contents($this->newAcronymsFile));
		$oldContents = file_get_contents($this->newAcronymsFile);
		if($newContents != $oldContents) {
			$minus_extension = substr($this->newAcronymsFile, 0, strpos($this->newAcronymsFile, "."));
			$extension = substr($this->newAcronymsFile, strpos($this->newAcronymsFile, "."));		
			$time = round(self::getmicrotime() - $this->timer_start, 4) * 10000;
			while(is_file($minus_extension . "-20" . date("ymd--h-i-s--") . $time . $extension)) {
				print($time . "<br>\r\n");
				$time++;
			}
			rename($this->newAcronymsFile, $minus_extension . "-20" . date("ymd--h-i-s--") . $time . $extension);
			//file_put_contents($this->newAcronymsFile, iconv($this->config['encoding'], 'iso-8859-1' . "//TRANSLIT", $newContents));
			file_put_contents($this->newAcronymsFile, $newContents);
		}
	}
	
	function saveAcronymsFile($filename, $acronyms_array) {
		$newContents = "";
		foreach($acronyms_array as $index => $value) {
			$acronym = $value[0];
			$definition = $value[1];
			if(is_array($definition)) {
				foreach($definition as $def) {
					$newContents .= $acronym . '	' . $def . '
';
				}
			} else {
				$newContents .= $acronym . '	' . $definition . '
';			
			}
		}
		//$oldContents = iconv('iso-8859-1', $this->config['encoding'] . "//TRANSLIT", file_get_contents($filename));
		$oldContents = file_get_contents($filename);
		if($newContents != $oldContents) {
			//file_put_contents($filename, iconv($this->config['encoding'], 'iso-8859-1' . "//TRANSLIT", $newContents));
			file_put_contents($filename, $newContents);
		}
	}	

	function preg_escape($string) {
		return str_replace('/', '\/', preg_quote($string));
	}
	
	function preg_escape_replacement($string) {
		$string = str_replace('$', '\$', $string);
		$string = str_replace('{', '\{', $string);
		$string = str_replace('}', '\}', $string);
		return $string;
	}

	protected function DOM_acronyms() {
		ReTidy::acronym_init();
		ReTidy::DOM_remove_acronyms();
		ReTidy::DOM_apply_acronyms();
	}
	
	protected function acronyms() {
		ReTidy::acronym_init();
		ReTidy::apply_acronyms();
	}
	
	protected function detected_acronyms() {
		ReTidy::detected_acronym_init();
		ReTidy::apply_acronyms();
	}
	
	protected function abbr() {
		ReTidy::abbr_init();
		ReTidy::apply_acronyms();
	}	
	
	protected function clean_openoffice() {
		$array_str_replaces = array(
		' target="_top"' => '',
		);
		foreach($array_str_replaces as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code);
			$this->logMsgIf(htmlentities($search), $count);
		}
		$array_replaces = array(
		' class="[^"]*?"' => '',
		'<li([^<>]*?)>\s*<p([^<>]*?)>' => '<li$1><p$2 stripme="y">',
		'<td([^<>]*?)>\s*<p([^<>]*?)>' => '<td$1><p$2 stripme="y">',
		'<th([^<>]*?)>\s*<p([^<>]*?)>' => '<th$1><p$2 stripme="y">',
		'<table[^<>]*?>' => '<table>',
		'<col([^<>]*?)>' => '<col stripme="y"$1>',
		' style="[^"]*?"' => '',
		' width="[^"]*?"' => '',
		'<a name="header[^"]*?"><\/a>' => '',
		'<img([^<>]*?) name="[^"]*?"([^<>]*?)>' => '<img$1$2>',
		);
		foreach($array_replaces as $search => $replace) {
			$this->code = preg_replace('/' . $search . '/is', $replace, $this->code, -1, $count);
			$this->logMsgIf(htmlentities($search), $count);
		}
		// links
		preg_match('/table of contents(.*?)<h/is', $this->code, $TOC_matches);
		preg_match_all('/href="([^"]*?)"/is', $TOC_matches[0], $TOC_link_matches);
		$the_links_are_all_the_same = true;
		$page = substr($TOC_link_matches[1][0], 0, strpos($TOC_link_matches[1][0], '#'));
		foreach($TOC_link_matches[0] as $index => $value) {
			$page2 = substr($TOC_link_matches[1][$index], 0, strpos($TOC_link_matches[1][$index], '#'));
			if($page !== $page2) {
				$the_links_are_all_the_same = false;
			}
		}
		if($the_links_are_all_the_same) {
			$this->code = str_replace($page, '', $this->code);
		}
		// acronyms
	}
	
	protected function remove_tags_intra_tags() {
		// remove tags from inside other tags (as opposed to between); intra not inter.
		$ct_intra_tags = 0;
		$ct2 = -1;
		while($ct2 != 0) {
			/*preg_match_all('/(<[^>]*)<[^<>]+?>/is', $this->code, $debug_matches);
			print('$debug_matches: ');var_dump($debug_matches);*/
			$this->code = preg_replace('/(<(![^\-][^<>]+|[^!<>]+))<[^<>]+?>/is', '$1', $this->code, -1, $ct2); // changed (2012-01-25)
			$ct_intra_tags += $ct2;
		}
		$this->logMsgIf("tags intra tags removed", $ct_intra_tags);
		// we must also ignore the <head>!
		// the only tag that has content in the head that I can think of is <title>, so:
		preg_match_all('/<title>(.*?)<\/title>/is', $this->code, $title_matches);
		if(sizeof($title_matches[0]) > 1) {
			print("Well, that's not good; found more than one (" . sizeof($title_matches[0]) . ") &lt;title&gt; tags on this page!");exit(0);
		}
		if(sizeof($title_matches[0]) === 0) {
			// nothing to do
		} else {
			$ct_title = 0;
			$initial_title_string = $title_string = $title_matches[0][0];
			$ct1 = -1;
		
			while($ct1 != 0) {
				$title_string = preg_replace('/<title>(.*?)<[^<>]+?>(.*?)<\/title>/is', '<title>$1$2</title>', $title_string, -1, $ct1);
				$ct_title += $ct1;
			}
			$this->code = str_replace($initial_title_string, $title_string, $this->code);
		}
		$this->logMsgIf("tags removed from title tag", $ct_title);
		// this should only happen if something exists in both the acronyms and abbr files (erroneously) or if
		// an bbreviation is a substring of another abbreviation but we'll still clean it up
		//$this->code = preg_replace('/<(abbr|acronym) title="([^"]*?)"><(abbr|acronym) title="([^"]*?)">(.*?)<\/(abbr|acronym)><\/(abbr|acronym)>/is', '<$1 title="$2">$4</$5>', $this->code, -1, $ct_redundant_acro);
		$ct_redundant_acro = 0;
		$array_tags = array('abbr', 'acronym');
		$tagNamesString = implode('|', $array_tags);
		foreach($array_tags as $tagName) {
			$OStrings = OM::getAllOStrings($this->code, '<' . $tagName, '</' . $tagName . '>');
			//var_dump($OStrings);exit(0);
			$counter = sizeof($OStrings) - 1;
			while($counter >= 0) {
				$OString = $OStrings[$counter][0];
				$opening_tag = substr($OString, 0, strpos($OString, '>') + 1);
				$closing_tag = substr($OString, ReTidy::strpos_last($OString, '<'));
				$code_to_clean = substr($OString, strlen($opening_tag), strlen($OString) - strlen($opening_tag) - strlen($closing_tag));
				$needs_to_be_cleaned = false;
				foreach($array_tags as $tagName2) {
					if(strpos($code_to_clean, '<' . $tagName2) !== false) {
						$needs_to_be_cleaned = true;
						break;
					}
				}
				if($needs_to_be_cleaned) {
					$offset = $OStrings[$counter][1];
					$code_to_clean = preg_replace('/<(' . $tagNamesString . ')[^<>]*?>/is', '', $code_to_clean);
					$code_to_clean = preg_replace('/<\/(' . $tagNamesString . ')>/is', '', $code_to_clean);
					$new_OString = $opening_tag . $code_to_clean . $closing_tag;
					$this->code = substr($this->code, 0, $offset) . $new_OString . substr($this->code, $offset + strlen($OString));
					$ct_redundant_acro += 1;
				}
				$counter--;
			}
		}
		$this->logMsgIf("redundant acronyms applications removed", $ct_redundant_acro);
	}	

	protected function abbr_init() {
		$this->acronymsArray = array();
		$this->newAcronymsArray = array();
		
		if($this->department) {
			if ($this->language === "french") {
				$this->abbr_ignore = 'abbr' . DS . 'fra' . DS . 'abbr_ignore.txt';
				$this->stopWordsFile = 'abbr' . DS . 'fra' . DS . 'stop_words.txt';
				$this->acronymsFile = 'abbr' . DS . 'GoC' . DS . $this->department . DS . 'fra' . DS . 'abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . 'GoC' . DS . $this->department . DS . 'fra' . DS . 'newabbr.txt';
			} else {
				// default to english
				$this->abbr_ignore = 'abbr' . DS . 'eng' . DS . 'abbr_ignore.txt';
				$this->stopWordsFile = 'abbr' . DS . 'eng' . DS . 'stop_words_small.txt';
				$this->acronymsFile = 'abbr' . DS . 'GoC' . DS . $this->department . DS . 'eng' . DS . 'abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . 'GoC' . DS . $this->department . DS . 'eng' . DS . 'newabbr.txt';
			}
			if(!is_dir('abbr' . DS . 'GoC' . DS . $this->department)) {
				mkdir('abbr' . DS . 'GoC' . DS . $this->department);
			}
			if(!is_dir('abbr' . DS . 'GoC' . DS . $this->department . DS . 'fra')) {
				mkdir('abbr' . DS . 'GoC' . DS . $this->department . DS . 'fra');
			}
			if(!is_dir('abbr' . DS . 'GoC' . DS . $this->department . DS . 'eng')) {
				mkdir('abbr' . DS . 'GoC' . DS . $this->department . DS . 'eng');
			}			
		} elseif(strlen($this->abbr_path) > 0) {
			if($this->language === "french") {
				$this->abbr_ignore = 'abbr' . DS . 'fra' . DS . 'abbr_ignore.txt';	
				$this->stopWordsFile = 'abbr' . DS . 'fra' . DS . 'stop_words.txt';
				$this->acronymsFile = 'abbr' . DS . $this->abbr_path . DS . 'fra' . DS . 'abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . $this->abbr_path . DS . 'fra' . DS . 'newabbr.txt';
			} else {
				$this->abbr_ignore = 'abbr' . DS . 'eng' . DS . 'abbr_ignore.txt';	
				$this->stopWordsFile = 'abbr' . DS . 'eng' . DS . 'stop_words_small.txt';
				$this->acronymsFile = 'abbr' . DS . $this->abbr_path . DS . 'eng' . DS . 'abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . $this->abbr_path . DS . 'eng' . DS . 'newabbr.txt';
			}
			if(!is_dir('abbr' . DS . $this->abbr_path)) {
				mkdir('abbr' . DS . $this->abbr_path);
			}
			if(!is_dir('abbr' . DS . $this->abbr_path . DS . 'fra')) {
				mkdir('abbr' . DS . $this->abbr_path . DS . 'fra');
			}
			if(!is_dir('abbr' . DS . $this->abbr_path . DS . 'eng')) {
				mkdir('abbr' . DS . $this->abbr_path . DS . 'eng');
			}			
		} else {
			if ($this->language === "french") {
				$this->abbr_ignore = 'abbr' . DS . 'fra' . DS . 'abbr_ignore.txt';
				$this->stopWordsFile = 'abbr' . DS . 'fra' . DS . 'stop_words.txt';
				$this->acronymsFile = 'abbr' . DS . 'fra' . DS . 'sample-document-abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . 'fra' . DS . 'new-sample-document-abbr.txt';				
			}
			if ($this->language === "english") {
				$this->abbr_ignore = 'abbr' . DS . 'eng' . DS . 'abbr_ignore.txt';	
				$this->stopWordsFile = 'abbr' . DS . 'eng' . DS . 'stop_words_small.txt';
				$this->acronymsFile = 'abbr' . DS . 'eng' . DS . 'sample-document-abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . 'eng' . DS . 'new-sample-document-abbr.txt';				
			}
		}
		
		// create the abbreviations file if necessary
		if(!is_file($this->acronymsFile)) {
			file_put_contents($this->acronymsFile, "ABC	definition");
		}
		// create the new abbreviations file if necessary
		if(!is_file($this->newAcronymsFile)) {
			file_put_contents($this->newAcronymsFile, "ABC	definition");
		}
		
		$globalignore = 'abbr' . DS . 'abbr_ignore.txt';
		$globalignoreArray = explode("\r\n", file_get_contents($globalignore));
		$ArrayofNonAcronyms = explode("\r\n", file_get_contents($this->abbr_ignore));
		$this->arrayofNonAcronyms = array_merge($ArrayofNonAcronyms, $globalignoreArray);
		$this->stopWords = explode("\r\n", file_get_contents($this->stopWordsFile));
		
		ReTidy::cleanAcronymsFile($this->acronymsFile);

		//$acronymsFileContents = iconv('iso-8859-1', $this->config['encoding'] . "//TRANSLIT", file_get_contents($this->acronymsFile));
		//$newAcronymsFileContents = iconv('iso-8859-1', $this->config['encoding'] . "//TRANSLIT", file_get_contents($this->newAcronymsFile));
		$acronymsFileContents = file_get_contents($this->acronymsFile);
		$newAcronymsFileContents = file_get_contents($this->newAcronymsFile);
		
		$newArrayToAdd = explode("\r\n", $acronymsFileContents);
		$newArrayToAdd2 = explode("\r\n", $newAcronymsFileContents);		
		foreach($newArrayToAdd as $acr_tab_def) {
			if(strpos($acr_tab_def, "\r\n") !== false) {
				print("Error: abbreviations file not properly formatted (tab in either an abbreviation or definition): " . $acronymsFile);
				exit(0);
			}
			if(strlen($acr_tab_def) > 0) {
				$acronym = substr($acr_tab_def, 0, strpos($acr_tab_def, "	"));
				$definition = substr($acr_tab_def, strpos($acr_tab_def, "	") + 1);
				$acronymExists = false;
				foreach($this->acronymsArray as $index => $value) {
					$acronym17 = $value[0];
					$definition17 = $value[1];				
					if($acronym17 === $acronym) {
						$acronymExists = true;
						if(is_array($definition17)) {
							$this->acronymsArray[$index][1][] = $definition;
						} else {
							$this->acronymsArray[$index][1] = array($this->acronymsArray[$index][1], $definition);
						}
						break;
					}
				}
				if(!$acronymExists) {
					$this->acronymsArray[] = array($acronym, $definition);
				}
			}
		}
		foreach($newArrayToAdd2 as $acr_tab_def) {
			if(strpos($acr_tab_def, "\r\n") !== false) {
				print("Error: new abbreviations file not properly formatted (tab in either an abbreviation or definition): " . $newAcronymsFile);
				exit(0);
			}
			if(strlen($acr_tab_def) > 0) {
				$acronym = substr($acr_tab_def, 0, strpos($acr_tab_def, "	"));
				$definition = substr($acr_tab_def, strpos($acr_tab_def, "	") + 1);
				$acronymExists = false;
				foreach($this->newAcronymsArray as $index => $value) {
					$acronym17 = $value[0];
					$definition17 = $value[1];
					if($acronym17 === $acronym) {
						$acronymExists = true;
						if(is_array($definition17)) {
							$this->newAcronymsArray[$index][1][] = $definition;
						} else {
							$this->newAcronymsArray[$index][1] = array($this->newAcronymsArray[$index][1], $definition);
						}
						break;
					}
				}
				if(!$acronymExists) {
					$this->newAcronymsArray[] = array($acronym, $definition);
				}
			}
		}
		$this->allowedAcronymLeftLimiters = '([\s>;\(\)\[\]\{\}\'’"“”\\\\\/\-~\*=])';		
		// for, for example, french characters.
		$this->allowedAcronyms = '((\w+\.)(\s*(\w|(&[^\s;]+;))+\.)*)';
		// this will need to be compared to a word list so that we do not catch the ends of sentences.
		$this->allowedAcronymRightLimiters = '([\s<&\(\)\[\]\{\}\'’"“”,;:?!\.\\\\\/\-#~\*=]|s[\s<&\(\)\[\]\{\}\'’"“”,;:?!\.\\\\\/\-#~\*]|es[\s<&\(\)\[\]\{\}\'’"“”,;:?!\.\\\\\/\-#~\*])';		
		$this->acronym_pattern = "/" . $this->allowedAcronymLeftLimiters . $this->allowedAcronyms . $this->allowedAcronymRightLimiters . "/s";
	}
	
	protected function detected_acronym_init() {
		$this->acronymsArray = array();		
		if($this->language === "french") {
			$this->acronymsFile = 'not-swept' . DS . 'abbr-fra.txt';
		} else {
			$this->acronymsFile = 'not-swept' . DS . 'abbr-eng.txt';
		}
		ReTidy::cleanAcronymsFile($this->acronymsFile);
		$acronymsFileContents = file_get_contents($this->acronymsFile);
		$newArrayToAdd = explode("\r\n", $acronymsFileContents);		
		foreach($newArrayToAdd as $acr_tab_def) {
			if(strpos($acr_tab_def, "\r\n") !== false) {
				print("Error: acronyms file not properly formatted (tab in either an acronym or definition): " . $acronymsFile);
				exit(0);
			}
			if(strlen($acr_tab_def) > 0) {
				$acronym = substr($acr_tab_def, 0, strpos($acr_tab_def, "	"));
				$definition = substr($acr_tab_def, strpos($acr_tab_def, "	") + 1);
				$acronymExists = false;
				foreach($this->acronymsArray as $index => $value) {
					$acronym17 = $value[0];
					$definition17 = $value[1];				
					if($acronym17 === $acronym) {
						$acronymExists = true;
						if(is_array($definition17)) {
							$this->acronymsArray[$index][1][] = $definition;
						} else {
							$this->acronymsArray[$index][1] = array($this->acronymsArray[$index][1], $definition);
						}
						break;
					}
				}
				if(!$acronymExists) {
					$this->acronymsArray[] = array($acronym, $definition);
				}
			}
		}

		$this->allowedAcronymLeftLimiters = '([\s>;\(\)\[\]\{\}\'’"“”\\\\\/\-~\*=])';		
		// we assume entities are unencoded and ignore tags
		// we also assume that the acronym begins and ends with a capital letter (or else this is more difficult)
		//$this->allowedAcronyms = '([A-ZŒÇÄÉÆÖÜÑ]+)';
		//$this->allowedAcronyms = '(([A-ZŒÇÄÉÆÖÜÑ]+)(((\s*(&|&amp;)\s*)|([a-z_\(\)\[\]\{\}\\\\\/\-~\*])|(\s*[A-ZŒÇÄÉÆÖÜÑ])){0,3}([A-ZŒÇÄÉÆÖÜÑ]+))*)';
		// changed (2011-10-12)
		$this->allowedAcronyms = '(([A-ZŒÇÄÉÆÖÜÑ]+)(((\s*(&|&amp;)\s*)|([a-z_\(\)\[\]\{\}\\\\\/\-~\*]))(\s*[A-ZŒÇÄÉÆÖÜÑ]+)){0,3})';
		$this->allowedAcronymRightLimiters = '((|s|es|ing|er|ers|[0-9])[\s<&\(\)\[\]\{\}\'’"“”,;:?!\.\\\\\/\-#~\*=])';
		$this->acronym_pattern = "/" . $this->allowedAcronymLeftLimiters . $this->allowedAcronyms . $this->allowedAcronymRightLimiters . "/s";
	}
	
	protected function acronym_init() {
		$this->acronymsArray = array();
		$this->newAcronymsArray = array();		
		
		if($this->department) {
			if ($this->language === "french") {
				$this->abbr_ignore = 'abbr' . DS . 'fra' . DS . 'abbr_ignore.txt';
				$this->stopWordsFile = 'abbr' . DS . 'fra' . DS . 'stop_words.txt';
				$this->acronymsFile = 'abbr' . DS . 'GoC' . DS . $this->department . DS . 'fra' . DS . 'abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . 'GoC' . DS . $this->department . DS . 'fra' . DS . 'newabbr.txt';
			} else {
				// default to english
				$this->abbr_ignore = 'abbr' . DS . 'eng' . DS . 'abbr_ignore.txt';
				$this->stopWordsFile = 'abbr' . DS . 'eng' . DS . 'stop_words_small.txt';
				$this->acronymsFile = 'abbr' . DS . 'GoC' . DS . $this->department . DS . 'eng' . DS . 'abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . 'GoC' . DS . $this->department . DS . 'eng' . DS . 'newabbr.txt';
			}
			if(!is_dir('abbr' . DS . 'GoC' . DS . $this->department)) {
				mkdir('abbr' . DS . 'GoC' . DS . $this->department);
			}
			if(!is_dir('abbr' . DS . 'GoC' . DS . $this->department . DS . 'fra')) {
				mkdir('abbr' . DS . 'GoC' . DS . $this->department . DS . 'fra');
			}
			if(!is_dir('abbr' . DS . 'GoC' . DS . $this->department . DS . 'eng')) {
				mkdir('abbr' . DS . 'GoC' . DS . $this->department . DS . 'eng');
			}			
		} elseif(strlen($this->abbr_path) > 0) {
			if($this->language === "french") {
				$this->abbr_ignore = 'abbr' . DS . 'fra' . DS . 'abbr_ignore.txt';	
				$this->stopWordsFile = 'abbr' . DS . 'fra' . DS . 'stop_words.txt';
				$this->acronymsFile = 'abbr' . DS . $this->abbr_path . DS . 'fra' . DS . 'abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . $this->abbr_path . DS . 'fra' . DS . 'newabbr.txt';
			} else {
				$this->abbr_ignore = 'abbr' . DS . 'eng' . DS . 'abbr_ignore.txt';	
				$this->stopWordsFile = 'abbr' . DS . 'eng' . DS . 'stop_words_small.txt';
				$this->acronymsFile = 'abbr' . DS . $this->abbr_path . DS . 'eng' . DS . 'abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . $this->abbr_path . DS . 'eng' . DS . 'newabbr.txt';
			}
			if(!is_dir('abbr' . DS . $this->abbr_path)) {
				mkdir('abbr' . DS . $this->abbr_path);
			}
			if(!is_dir('abbr' . DS . $this->abbr_path . DS . 'fra')) {
				mkdir('abbr' . DS . $this->abbr_path . DS . 'fra');
			}
			if(!is_dir('abbr' . DS . $this->abbr_path . DS . 'eng')) {
				mkdir('abbr' . DS . $this->abbr_path . DS . 'eng');
			}			
		} else {
			if ($this->language === "french") {
				$this->abbr_ignore = 'abbr' . DS . 'fra' . DS . 'abbr_ignore.txt';
				$this->stopWordsFile = 'abbr' . DS . 'fra' . DS . 'stop_words.txt';
				$this->acronymsFile = 'abbr' . DS . 'fra' . DS . 'sample-document-abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . 'fra' . DS . 'new-sample-document-abbr.txt';				
			}
			if ($this->language === "english") {
				$this->abbr_ignore = 'abbr' . DS . 'eng' . DS . 'abbr_ignore.txt';	
				$this->stopWordsFile = 'abbr' . DS . 'eng' . DS . 'stop_words_small.txt';
				$this->acronymsFile = 'abbr' . DS . 'eng' . DS . 'sample-document-abbr.txt';
				$this->newAcronymsFile = 'abbr' . DS . 'eng' . DS . 'new-sample-document-abbr.txt';				
			}
		}
		
		// create the acronyms file if necessary
		if(!is_file($this->acronymsFile)) {
			file_put_contents($this->acronymsFile, "ABC	definition");
		}
		// create the new acronyms file if necessary
		if(!is_file($this->newAcronymsFile)) {
			file_put_contents($this->newAcronymsFile, "ABC	definition");
		}
		
		$globalignore = 'abbr' . DS . 'abbr_ignore.txt';
		$globalignoreArray = explode("\r\n", file_get_contents($globalignore));
		$ArrayofNonAcronyms = explode("\r\n", file_get_contents($this->abbr_ignore));
		$this->arrayofNonAcronyms = array_merge($ArrayofNonAcronyms, $globalignoreArray);
		$this->stopWords = explode("\r\n", file_get_contents($this->stopWordsFile));
		
		ReTidy::cleanAcronymsFile($this->acronymsFile);

		//$acronymsFileContents = iconv('iso-8859-1', $this->config['encoding'] . "//TRANSLIT", file_get_contents($this->acronymsFile));
		//$newAcronymsFileContents = iconv('iso-8859-1', $this->config['encoding'] . "//TRANSLIT", file_get_contents($this->newAcronymsFile));
		$acronymsFileContents = file_get_contents($this->acronymsFile);
		$newAcronymsFileContents = file_get_contents($this->newAcronymsFile);
		
		$newArrayToAdd = explode("\r\n", $acronymsFileContents);
		$newArrayToAdd2 = explode("\r\n", $newAcronymsFileContents);		
		foreach($newArrayToAdd as $acr_tab_def) {
			if(strpos($acr_tab_def, "\r\n") !== false) {
				print("Error: acronyms file not properly formatted (tab in either an acronym or definition): " . $acronymsFile);
				exit(0);
			}
			if(strlen($acr_tab_def) > 0) {
				$acronym = substr($acr_tab_def, 0, strpos($acr_tab_def, "	"));
				$definition = substr($acr_tab_def, strpos($acr_tab_def, "	") + 1);
				$acronymExists = false;
				foreach($this->acronymsArray as $index => $value) {
					$acronym17 = $value[0];
					$definition17 = $value[1];				
					if($acronym17 === $acronym) {
						$acronymExists = true;
						if(is_array($definition17)) {
							$this->acronymsArray[$index][1][] = $definition;
						} else {
							$this->acronymsArray[$index][1] = array($this->acronymsArray[$index][1], $definition);
						}
						break;
					}
				}
				if(!$acronymExists) {
					$this->acronymsArray[] = array($acronym, $definition);
				}
			}
		}
		foreach($newArrayToAdd2 as $acr_tab_def) {
			if(strpos($acr_tab_def, "\r\n") !== false) {
				print("Error: new acronyms file not properly formatted (tab in either an acronym or definition): " . $newAcronymsFile);
				exit(0);
			}
			if(strlen($acr_tab_def) > 0) {
				$acronym = substr($acr_tab_def, 0, strpos($acr_tab_def, "	"));
				$definition = substr($acr_tab_def, strpos($acr_tab_def, "	") + 1);
				$acronymExists = false;
				foreach($this->newAcronymsArray as $index => $value) {
					$acronym17 = $value[0];
					$definition17 = $value[1];
					if($acronym17 === $acronym) {
						$acronymExists = true;
						if(is_array($definition17)) {
							$this->newAcronymsArray[$index][1][] = $definition;
						} else {
							$this->newAcronymsArray[$index][1] = array($this->newAcronymsArray[$index][1], $definition);
						}
						break;
					}
				}
				if(!$acronymExists) {
					$this->newAcronymsArray[] = array($acronym, $definition);
				}
			}
		}
		$this->allowedAcronymLeftLimiters = '([\s>;\(\)\[\]\{\}\'’"“”\\\\\/\-~\*=])';		
		// we assume entities are unencoded and ignore tags
		// we also assume that the acronym begins and ends with a capital letter (or else this is more difficult)
		//$this->allowedAcronyms = '([A-ZŒÇÄÉÆÖÜÑ]+)';
		//$this->allowedAcronyms = '(([A-ZŒÇÄÉÆÖÜÑ]+)(((\s*(&|&amp;)\s*)|([a-z_\(\)\[\]\{\}\\\\\/\-~\*])|(\s*[A-ZŒÇÄÉÆÖÜÑ])){0,3}([A-ZŒÇÄÉÆÖÜÑ]+))*)';
		// changed (2011-10-12)
		$this->allowedAcronyms = '(([A-ZŒÇÄÉÆÖÜÑ]+)(((\s*(&|&amp;)\s*)|([a-z_\(\)\[\]\{\}\\\\\/\-~\*]))(\s*[A-ZŒÇÄÉÆÖÜÑ]+)){0,3})';
		$this->allowedAcronymRightLimiters = '((|s|es|ing|er|ers|[0-9])[\s<&\(\)\[\]\{\}\'’"“”,;:?!\.\\\\\/\-#~\*=])';
		$this->acronym_pattern = "/" . $this->allowedAcronymLeftLimiters . $this->allowedAcronyms . $this->allowedAcronymRightLimiters . "/s";
	}
	
	//protected function entities_init() {
	function entities_init() {
		// a new cleaner object is created for every file. this may be inefficient but tolerably so. if this was going to change we would do something like set code on the same cleaner object in sweeper for each file instead of creating a new object for each file.
		//if(isset($this->entities_array)) {
		//	
		//} else {
			ReTidy::set_entities_array();
		//}
		return true;
	}
	
	protected function set_entities_array() {
		include('mappings' . DS . 'latin1.php');
		$entities_array = $latin1array;
		
		$entities_array[] = array(html_entity_decode('&#160;'), "&#160;", "&#xa0;", "&#xA0;", "&nbsp;");
		$entities_array[] = array("¡", "&#161;", "&#xa1;", "&iexcl;");
		$entities_array[] = array("¢", "&#162;", "&#xa2;", "&cent;");
		$entities_array[] = array("£", "&#163;", "&#xa3;", "&pound;");
		$entities_array[] = array("¤", "&#164;", "&#xa4;", "&curren;");
		$entities_array[] = array("¥", "&#165;", "&#xa5;", "&yen;");
		$entities_array[] = array("¦", "&#166;", "&#xa6;", "&brvbar;");
		$entities_array[] = array("§", "&#167;", "&#xa7;", "&sect;");
		$entities_array[] = array("¨", "&#168;", "&#xa8;", "&uml;");
		$entities_array[] = array("©", "&#169;", "&#xa9;", "&copy;");
		$entities_array[] = array("ª", "&#170;", "&#xaa;", "&ordf;");
		$entities_array[] = array("«", "&#171;", "&#xab;", "&laquo;");
		$entities_array[] = array("¬", "&#172;", "&#xac;", "&not;");
		$entities_array[] = array("­", "&#173;", "&#xad;", "&shy;");
		$entities_array[] = array("®", "&#174;", "&#xae;", "&reg;");
		$entities_array[] = array("¯", "&#175;", "&#xaf;", "&macr;");
		$entities_array[] = array("°", "&#176;", "&#xb0;", "&deg;");
		$entities_array[] = array("±", "&#177;", "&#xb1;", "&plusmn;");
		$entities_array[] = array("²", "&#178;", "&#xb2;", "&sup2;");
		$entities_array[] = array("³", "&#179;", "&#xb3;", "&sup3;");
		$entities_array[] = array("´", "&#180;", "&#xb4;", "&acute;");
		$entities_array[] = array("µ", "&#181;", "&#xb5;", "&micro;");
		$entities_array[] = array("¶", "&#182;", "&#xb6;", "&para;");
		$entities_array[] = array("·", "&#183;", "&#xb7;", "&middot;");
		$entities_array[] = array("¸", "&#184;", "&#xb8;", "&cedil;");
		$entities_array[] = array("¹", "&#185;", "&#xb9;", "&sup1;");
		$entities_array[] = array("º", "&#186;", "&#xba;", "&ordm;");
		$entities_array[] = array("»", "&#187;", "&#xbb;", "&raquo;");
		$entities_array[] = array("¼", "&#188;", "&#xbc;", "&frac14;");
		$entities_array[] = array("½", "&#189;", "&#xbd;", "&frac12;");
		$entities_array[] = array("¾", "&#190;", "&#xbe;", "&frac34;");
		$entities_array[] = array("¿", "&#191;", "&#xbf;", "&iquest;");
		
		$entities_array[] = array("–", "&#8211;", "&#x2013;", "&ndash;");
		$entities_array[] = array("—", "&#8212;", "&#x2014;", "&mdash;");
		$entities_array[] = array("‘", "&#8216;", "&#x2018;", "&lsquo;");
		$entities_array[] = array("’", "&#8217;", "&#x2019;", "&rsquo;");
		$entities_array[] = array("‚", "&#8218;", "&#x201a;", "&sbquo;");
		$entities_array[] = array("“", "&#8220;", "&#x201c;", "&ldquo;");
		$entities_array[] = array("”", "&#8221;", "&#x201d;", "&rdquo;");
		$entities_array[] = array("„", "&#8222;", "&#x201e;", "&bdquo;");
		$entities_array[] = array("†", "&#8224;", "&#x2020;", "&dagger;");
		$entities_array[] = array("‡", "&#8225;", "&#x2021;", "&Dagger;");
		$entities_array[] = array("•", "&#8226;", "&#x2022;", "&bull;");
		$entities_array[] = array("…", "&#8230;", "&#x2026;", "&hellip;");
		$entities_array[] = array("‰", "&#8240;", "&#x2030;", "&permil;");
		$entities_array[] = array("′", "&#8242;", "&#x2032;", "&prime;");
		$entities_array[] = array("″", "&#8243;", "&#x2033;", "&Prime;");
		$entities_array[] = array("‹", "&#8249;", "&#x2039;", "&lsaquo;");
		$entities_array[] = array("›", "&#8250;", "&#x203a;", "&rsaquo;");
		$entities_array[] = array("‾", "&#8254;", "&#x203e;", "&oline;");
		
		$this->entities_array = $entities_array;
	}
	
	protected function undoublyencodeentities() {
			
		/*
		// we could use the DTD instead of hard-coding this. BUT IT WOULD TAKE TOO LONG
		$undoubleArray = array(
		'&amp;rsquo;' => '&rsquo;',
		'&amp;eacute;' => '&eacute;',
		'&amp;egrave;' => '&egrave;',
		'&amp;Eacute;' => '&Eacute;',
		'&amp;Egrave;' => '&Egrave;',
		'&amp;ocirc;' => '&ocirc;',
		'&amp;ucirc;' => '&ucirc;',
		'&amp;agrave;' => '&agrave;',
		'&amp;nbsp;' => '&nbsp;',
		);
		foreach($undoubleArray as $search => $replace) {
			$this->code = str_replace($search, $replace, $this->code, $c);
			$ct += $c;
		}*/ // insufficient (2012-01-16)
		$ct = 0;
		$c = -1;
		
		ReTidy::entities_init();
		
		while($c !== 0) {
			$c = 0;
			foreach($this->entities_array as $index => $value) {
				$this->code = str_replace(str_replace('&', '&amp;', $value[1]), $value[1], $this->code, $cnt1);
				$this->code = str_replace(str_replace('&', '&amp;', $value[2]), $value[2], $this->code, $cnt2);
				$this->code = str_replace(str_replace('&', '&amp;', $value[3]), $value[3], $this->code, $cnt3);
				$c += $cnt1 + $cnt2 + $cnt3;
			}
			$ct += $c;
		} // this is still only an approximation that hopefully good code will make useless
		/*$ct = 0;
		$c = -1;
		include('mappings' . DS . 'latin1.php');
		while($c !== 0) {
			$c = 0;
			foreach($latin1array as $index => $value) {
				$this->code = str_replace(str_replace('&', '&amp;', $value[1]), $value[1], $this->code, $cnt1);
				$this->code = str_replace(str_replace('&', '&amp;', $value[2]), $value[2], $this->code, $cnt2);
				$this->code = str_replace(str_replace('&', '&amp;', $value[3]), $value[3], $this->code, $cnt3);
				$c += $cnt1 + $cnt2 + $cnt3;
			}
			$ct += $c;
		}
		$entities_file = 'dtd' . DS . 'xhtml1-strict.dtd';
//$entities_file = 'dtd' . DS . 'many_entities.dtd';

$entities_code = file_get_contents($entities_file);
$array_entities = explode("\r\n", $entities_code);

while($start < $end + 1) {
	print(html_entity_decode("&#" . $start . ";"));
	print("&#" . $start . ";");
	print(htmlentities("&#" . $start . ";"));
	$hex = dechex($start);
	print(htmlentities("&#x" . $hex . ";"));
	// we use something like a .ent lookup for this...
	foreach($array_entities as $line) {
		if(preg_match('/<!ENTITY\s*(\w*)\s*"&#' . $start . ';"\s*>/is', $line, $entities_match)) {
			print(htmlentities("&" . $entities_match[1] . ";"));
			break;
		} elseif(preg_match('/<!ENTITY\s*(\w*)\s*"&#x[0]*' . $hex . ';"\s*>/is', $line, $entities_match)) {
			print(htmlentities("&" . $entities_match[1] . ";"));
			break;
		}
	}
	$start++;
}*/ //darn, this will take too long...
		$this->logMsgIf("undoubled entities", $ct);
	}

	protected function DOM_find_acronyms () {
		// first we are looking for already existing <acronym> tags.
		$query = '//' . ReTidy::get_html_namespace() . 'acronym';
		$acronymTags = $this->xpath->query($query);

		foreach($acronymTags as $acronymTag) {
			if($acronymTag->hasAttributes()) {
				foreach ($acronymTag->attributes as $attribute) {
					if ($attribute->nodeName === "title") {
						$definition = htmlentities($attribute->nodeValue);
					}
				}
			}
			if($acronymTag->hasChildNodes()) {
				foreach ($acronymTag->childNodes as $child) {
					if ($child->nodeName === "#text") {
						$acronym = htmlentities($acronymTag->firstChild->nodeValue);
					}
				}
			}		

			// this is a potential acronym so add it to the acronymsarray
			$IsADuplicate = false;
			foreach($this->acronymsArray as $index => $acronym_tab_definition) {
				$acronym18 = substr($acronym_tab_definition, 0, strpos($acronym_tab_definition, "	"));
				if ($acronym18 === $acronym) {
					$IsADuplicate = true;
					// check if this one is better than the existing one?
				}
			}
			if($IsADuplicate != true) {
				$ToAdd = "$acronym	$definition";
				$this->acronymsArray[] = $ToAdd;
			}
		}
		
		// now we could look for acronym tables and capitalized words and other things (using DOM 
		// to get only nodes that we are interested in).
	}
	
	protected function remove_acronyms_and_abbr() {
		ReTidy::remove_acronyms();
		ReTidy::remove_abbr();
	}
	
	protected function remove_acronyms() {
		$this->code = preg_replace('/<acronym[^>]*?>/is', '', $this->code, -1, $ct1);
		$this->code = str_replace('</acronym>', '', $this->code);
		$this->logMsgIf("acronyms removed", $ct1);
	}
	
	protected function remove_abbr() {
		$this->code = preg_replace('/<abbr[^>]*?>/is', '', $this->code, -1, $ct2);
		$this->code = str_replace('</abbr>', '', $this->code);
		$this->logMsgIf("abbreviations removed", $ct2);
	}
	
	protected function DOM_remove_acronyms() {
		$query = '//' . ReTidy::get_html_namespace() . 'acronym';
		$acronyms = $this->xpath->query($query);
		foreach($acronyms as $acronym) {
			$acronym->setAttribute('stripme', 'y');
			ReTidy::DOM_strip_node($acronym);
		}
	}

	protected function array_qsort(&$array, $column, $order='SORT_ASC', $first=0, $last=0) {
		// $array  - the array to be sorted
		// $column - index (column) on which to sort. can be a string if using an associative array
		// $order  - SORT_ASC (default) for ascending or SORT_DESC for descending
		// $first  - start index (row) for partial array sort
		// $last  - stop  index (row) for partial array sort
		// $keys  - array of key values for hash array sort
		if(is_array($array)) {
			$keys = array_keys($array);
			if($last == -2) {
				$last = count($array) - 1;
			}
			if($last > $first) {
				$alpha = $first;
				$omega = $last;
				$key_alpha = $keys[$alpha];
				$key_omega = $keys[$omega];
				$guess = $array[$key_alpha][$column];
				while($omega >= $alpha) {
					if($order == 'SORT_ASC') {
						while($array[$key_alpha][$column] < $guess) {
							$alpha++;
							$key_alpha = $keys[$alpha]; 
						}
						while($array[$key_omega][$column] > $guess) {
							$omega--;
							$key_omega = $keys[$omega]; 
						}
					} else {
						while($array[$key_alpha][$column] > $guess) {
							$alpha++;
							$key_alpha = $keys[$alpha]; 
						}
						while($array[$key_omega][$column] < $guess) {
							$omega--;
							$key_omega = $keys[$omega]; 
						}
					}
					if($alpha > $omega) {
						break;
					}
					$temporary = $array[$key_alpha];
					$array[$key_alpha] = $array[$key_omega];
					$alpha++;
					$key_alpha = $keys[$alpha];
					$array[$key_omega] = $temporary;
					$omega--;
					$key_omega = $keys[$omega];
				}
				ReTidy::array_qsort ($array, $column, $order, $first, $omega);
				ReTidy::array_qsort ($array, $column, $order, $alpha, $last);
			}
		}
		return $array;
	}

	protected function apply_acronyms() {
		//print("this->acronymsArray: ");var_dump($this->acronymsArray);exit(0);
		$this->acronymReplaceArray = array();
		$this->acronymReplaceArray2 = array();
		ReTidy::sortAcronyms();
		usort($this->acronymsArray, "sortByLengthOfFirst");;
		if(sizeof($this->acronymsArray) === 0) {
			return false;
		}
		foreach($this->acronymsArray as $index => $value) {
			$acronym = $value[0];
			if(strlen($acronym) === 0) {
				continue;
			}
			if((!$this->config['apply_combined_acronyms'] && $this->method === "acronyms") || (!$this->config['apply_combined_abbr'] && $this->method === "abbr")) {
				preg_match_all('/[\s\/\\\\\-]/s', $acronym, $matches4392);
				if(sizeof($matches4392[0]) === 1) {
					$decombine = true;
					$decombined_acronyms_array = explode($matches4392[0][0], $acronym);
					foreach($decombined_acronyms_array as $decombined_acronym) {
						foreach($this->acronymsArray as $index4392 => $value4392) {
							$acronym4392 = $value4392[0];
							if($decombined_acronym === $acronym4392) {
								continue 2;
							}
						}
						$decombine = false;
						break;
					}
					if($decombine) {
						// do not add the combined acronym to the acronym string
						continue;
					}
				}
			}
			// the problem with this is that the check below (that picks the appropriate definition) will not match how we coded
			// the acronym with an ampersand. this is because we are doing one big regular expression to find all the acronyms at once
			// (for the whole document) rather than finding each acronym for the whole document; presumably to save time.
			//if(strpos($acronym, '&amp;') !== false) {
			//	$acronym_string .= "|" . ReTidy::preg_escape($acronym);
			//	$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', '&amp; ', $acronym));
			//	$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', ' &amp;', $acronym));
			//	$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', ' &amp; ', $acronym));
			//	if($this->language === "french") {
			//		$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', 'et', $acronym));
			//		$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', 'et ', $acronym));
			//		$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', ' et', $acronym));
			//		$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', ' et ', $acronym));
			//	} else {
			//		$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', 'and', $acronym));
			//		$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', 'and ', $acronym));
			//		$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', ' and', $acronym));
			//		$acronym_string .= "|" . ReTidy::preg_escape(str_replace('&amp;', ' and ', $acronym));
			//	}
			//	if(htmlentities(html_entity_decode($acronym)) != $acronym) {
			//		$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode($acronym)));
			//		$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', '&amp; ', $acronym))));
			//		$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', ' &amp;', $acronym))));
			//		$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', ' &amp; ', $acronym))));
			//		if($this->language === "french") {
			//			$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', 'et', $acronym))));
			//			$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', 'et ', $acronym))));
			//			$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', ' et', $acronym))));
			//			$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', ' et ', $acronym))));
			//		} else {
			//			$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', 'and', $acronym))));
			//			$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', 'and ', $acronym))));
			//			$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', ' and', $acronym))));
			//			$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode(str_replace('&amp;', ' and ', $acronym))));
			//		}
			//	}			
			//} else {
				$acronym_string .= "|" . ReTidy::preg_escape($acronym);
				if(htmlentities(html_entity_decode($acronym)) != $acronym) {
					$acronym_string .= "|" . ReTidy::preg_escape(htmlentities(html_entity_decode($acronym)));
				}
			//}
		}
		$acronym_string = "(" . substr($acronym_string, 1) . ")";
		$acronym_pattern2 = "/" . $this->allowedAcronymLeftLimiters . $acronym_string . $this->allowedAcronymRightLimiters . "/s";
		preg_match_all($acronym_pattern2, $this->code, $matches490, PREG_OFFSET_CAPTURE);
		if(sizeof($matches490[2]) > 0) {
			foreach($matches490[2] as $index490 => $value490) {
				$acronym = $value490[0];
				$offset490 = $value490[1];
				foreach($this->acronymsArray as $index46 => $value46) {
					if(htmlentities(html_entity_decode($acronym)) === htmlentities(html_entity_decode($value46[0]))) {
						$definition = $value46[1];
						$contextualCode = substr($this->code, $offset490 - 500, 1000);				
						ReTidy::applyAcronym($offset490, $contextualCode, $acronym, $definition);
						break;
					}
				}
				// it is possible to have two acronyms side-by-side.
				$offset492 = $matches490[3][$index490][1] + 1;
				while(preg_match('/' . $acronym_string . $this->allowedAcronymRightLimiters . '/s', substr($this->code, $offset492, 20), $matches88, PREG_OFFSET_CAPTURE)) {
					if($matches88[1][1] === 0) {
						$acronym47 = $matches88[1][0];
						foreach($this->acronymsArray as $index47 => $value47) {
							if(htmlentities(html_entity_decode($acronym47)) === htmlentities(html_entity_decode($value47[0]))) {
								$definition = $value47[1];
								$contextualCode = substr($this->code, $offset492 - 500, 1000);				
								ReTidy::applyAcronym($offset492, $contextualCode, $acronym47, $definition);
								break;								
							}
						}
						$offset492 += $matches88[2][1];
					} else {
						break;
					}
				}
			}
		}
		$this->acronymReplaceArray2 = ReTidy::array_qsort($this->acronymReplaceArray2, 2, 'SORT_ASC');
		$acronymed_code = "";
		$last_recorded_offset = 0;
		foreach($this->acronymReplaceArray2 as $index => $value) {
			$recorded_acronym = $value[0];
			$recorded_definition = $value[1];
			$recorded_offset = $value[2];
			if($this->method === "abbr" || $this->config['abbr_instead_of_acronym'] || $this->config['HTML5'] === true) {
				$acronymed_code .= substr($this->code, $last_recorded_offset + strlen($last_recorded_acronym), $recorded_offset - strlen($last_recorded_acronym) - $last_recorded_offset) . '<abbr title="' . $recorded_definition . '">' . $recorded_acronym . '</abbr>';
			} else {
				$acronymed_code .= substr($this->code, $last_recorded_offset + strlen($last_recorded_acronym), $recorded_offset - strlen($last_recorded_acronym) - $last_recorded_offset) . '<acronym title="' . $recorded_definition . '">' . $recorded_acronym . '</acronym>';
			}
			$last_recorded_acronym = $value[0];
			$last_recorded_definition = $value[1];
			$last_recorded_offset = $value[2];
		}
		$acronymed_code .= substr($this->code, $last_recorded_offset + strlen($last_recorded_acronym));
		$this->code = $acronymed_code;
		sort($this->acronymReplaceArray);
		foreach($this->acronymReplaceArray as $index => $value) {
			$counted_acronym = $value[0];
			$counted_definition = $value[1];
			$counted_count = $value[2];
			$multiple_defintions = $value[3];
			if($multiple_defintions) {
				$md_string = ' <span style="color: orange;">multiple definitions detected</span>';
			} else {
				$md_string = '';
			}
			if($this->method === "abbr") {
				$this->logMsgIf('abbreviations[<abbr title="' . $counted_definition . '">' . htmlentities($counted_acronym) . '</abbr>]' . $md_string, $counted_count);
			} elseif($this->config['abbr_instead_of_acronym'] || $this->config['HTML5'] === true) {
				$this->logMsgIf('abbreviations[<abbr title="' . $counted_definition . '">' . htmlentities($counted_acronym) . '</abbr>]' . $md_string, $counted_count);
			} else {
				$this->logMsgIf('abbreviations[<acronym title="' . $counted_definition . '">' . htmlentities($counted_acronym) . '</acronym>]' . $md_string, $counted_count);
			}
		}
	}

	protected function DOM_apply_acronyms () {
		$query = '/';
		$rootNodes = $this->xpath->query($query);
		foreach($rootNodes as $rootNode) {
			// we should ignore the head of the document (so that, for example, <title> tags do 
			// not have acronyms applied to them.
			$this->acronymReplaceArray = array();
			ReTidy::rec_dom_apply_acronyms_with_ignore($rootNode, "head");
			sort($this->acronymReplaceArray);
			foreach($this->acronymReplaceArray as $index => $value) {
				$counted_acronym = $value[0];
				$counted_definition = $value[1];
				$counted_count = $value[2];
				$multiple_defintions = $value[3];
				if($multiple_defintions) {
					$this->logMsgIf('DOM_abbreviations[<acronym title="' . $counted_definition . '">' . htmlentities($counted_acronym) . '</acronym><span style="color: orange;">multiple definitions detected</span>]', $counted_count);
				} else {
					$this->logMsgIf('DOM_abbreviations[<acronym title="' . $counted_definition . '">' . htmlentities($counted_acronym) . '</acronym>]', $counted_count);
				}
			}
		}	
	}
	
	protected function rec_dom_apply_acronyms_with_ignore($node, $ignore) {
		if($node->nodeType === 1 || $node->nodeType === 9) {
			if($node->hasChildNodes()) {
				foreach ($node->childNodes as $item) {
					if ($item->nodeName !== $ignore) {
						ReTidy::rec_dom_apply_acronyms_with_ignore($item, $ignore);
					}
				}	
			}
		}
		if($node->nodeType === 3) {
			$node->nodeValue = "~" . $node->nodeValue . "~";
			foreach($this->acronymsArray as $index => $value) {
				$acronym = $value[0];
				$definition = $value[1];
				$acronym_pattern2 = "/" . $this->allowedAcronymLeftLimiters . $acronym . $this->allowedAcronymRightLimiters . "/s";
				preg_match_all($acronym_pattern2, $node->nodeValue, $matches490, PREG_OFFSET_CAPTURE);
				if(sizeof($matches490[2]) > 0) {
					foreach($matches490[2] as $index490 => $value490) {
						$offset490 = $value490[1];
						// simple and misses context beyond entities or otherwise not in the text node
						$node->nodeValue = ReTidy::DOM_applyAcronym($node->nodeValue, $offset490, $node->nodeValue, $acronym, $definition);
					}
				}
			}
			$node->nodeValue = substr($node->nodeValue, 1, strlen($node->nodeValue)-2);		
		}
		return true;
	}	

	function strpos_last($haystack, $needle) {
		//print('$haystack, $needle: ');var_dump($haystack, $needle);
		if(strlen($needle) === 0) {
			return false;
		}
		$len_haystack = strlen($haystack);
		$len_needle = strlen($needle);		
		$pos = strpos(strrev($haystack), strrev($needle));
		if($pos === false) {
			return false;
		}
		return $len_haystack - $pos - $len_needle;
	}
	
	function replace_last($search, $replace, $subject) {
		$pos = strripos($subject, $search);
		if(false !== $pos) {
			$sLen = strlen($search);
			$subject = substr_replace($subject, $replace, $pos, $sLen);
		}
		return $subject;
	}
	
	protected function applyAcronym($offset, $contextualCode, $acronym, $definition) {
		if(is_array($definition)) {
			// notice that this looks for context on the first instance and not every instance of the acronym in the string.
			// this seems fine as it is very unlikely that two different definitions for the same acronym shall be used in the same string
			// it is more likely that the definition shall be found near the first instance.
			if($this->method === "abbr") {
				//$defArray = ReTidy::findAbbreviationDefinitions($acronym, 500, $contextualCode);
				$defArray = ReTidy::findAbbreviationDefinitions($acronym, $this->config['near_for_acronyms_application'], $contextualCode);
			} else {
				//$defArray = ReTidy::findDefinitions($acronym, 500, $contextualCode);
				$defArray = ReTidy::findDefinitions($acronym, $this->config['near_for_acronyms_application'], $contextualCode);
			}
			$defArray = array_filter($defArray, "emptyDefinitions");
			if(sizeof($defArray) > 0) { 
				foreach($defArray as $def) {
					foreach($definition as $ExistingDefinition55) {
						if(ReTidy::areSimilarDefinitions($def, $ExistingDefinition55) && 
						($this->config['apply_acronym_if_near_definition'] || !isset($this->config['apply_acronym_if_near_definition']) /* default */)) { 
							// we easily found a definition from the context
							$this->acronymReplaceArray2[] = array($acronym, $ExistingDefinition55, $offset);
							ReTidy::recordTheApplication(1, $acronym, $ExistingDefinition55, true);						
							break 2;
						} else {
							// we do not apply it since the definition is nearby.
						}
					}
				}			
			} else { // the context did not help; check for any patterns of application for this file.
				$definition_to_use = false;
				$highest_count = 0;
				foreach($this->acronymReplaceArray as $index => $value) {
					$counted_acronym = $value[0];
					$counted_definition = $value[1];
					$counted_count = $value[2];
					if($counted_acronym === $acronym && $counted_count > $highest_count) {
						$definition_to_use = $counted_definition;
						$highest_count = $counted_count;
					}
				}
				if($definition_to_use) {
					// it is rare and not very smart to have the same acronym with different definitions in the same document.
					// some choices for how to work are: stubborn (take the most popular definition in the document) and 
					// adaptive (adapt to the latest definition). We are here being stubborn.
					$this->acronymReplaceArray2[] = array($acronym, $definition_to_use, $offset);
					ReTidy::recordTheApplication(1, $acronym, $definition_to_use, true);					
				} else {
					//search the entire text content of the document for definitions
					$highest_count4 = 0;
					if(is_array($definition)) {
						foreach($definition as $ExistingDefinition65) {
							$count_from_doc = substr_count(ReTidy::tagless($this->code), $ExistingDefinition65);
							if($count_from_doc > $highest_count4) {
								$definition_to_use = $ExistingDefinition65;
							}
						}
					}
					if($definition_to_use) {
						$this->acronymReplaceArray2[] = array($acronym, $definition_to_use, $offset);
						ReTidy::recordTheApplication(1, $acronym, $definition_to_use, true);
					} else {
						// if we get to here, then we have no idea which one to apply... so apply the first one.
						$first_definition = $definition[0];
						$this->acronymReplaceArray2[] = array($acronym, $first_definition, $offset);
						ReTidy::recordTheApplication(1, $acronym, $first_definition, true);
					}
				}
			}
		} else {
			if($this->config['apply_acronym_if_near_definition'] === false) {
				$definition_is_nearby = false;
				if($this->method === "abbr") {
					//$defArray = ReTidy::findAbbreviationDefinitions($acronym, 500, $contextualCode);
					$defArray = ReTidy::findAbbreviationDefinitions($acronym, $this->config['near_for_acronyms_application'], $contextualCode);
				} else {
					//$defArray = ReTidy::findDefinitions($acronym, 500, $contextualCode);
					$defArray = ReTidy::findDefinitions($acronym, $this->config['near_for_acronyms_application'], $contextualCode);
				}
				$defArray = array_filter($defArray, "emptyDefinitions");
				if(sizeof($defArray) > 0) { 
					foreach($defArray as $def) {
						if(ReTidy::areSimilarDefinitions($def, $definition)) {
							// we do not apply it since the definition is nearby.
							$definition_is_nearby = true;
							break;
						}
					}
				}
				if(!$definition_is_nearby) {
					$this->acronymReplaceArray2[] = array($acronym, $definition, $offset);
					ReTidy::recordTheApplication(1, $acronym, $definition, false);
				}
			} else {
				$this->acronymReplaceArray2[] = array($acronym, $definition, $offset);
				ReTidy::recordTheApplication(1, $acronym, $definition, false);
			}
		}
	}
	
	protected function DOM_applyAcronym($string, $offset, $contextualCode, $acronym, $definition) {
		$acronym_pattern2 = "/" . $this->allowedAcronymLeftLimiters . $acronym . $this->allowedAcronymRightLimiters . "/s";
		$ct = $ct2 = $ct3 = $ct4 = 0;
		if(is_array($definition)) {
			// notice that this looks for context on the first instance and not every instance of the acronym in the string.
			// this seems fine as it is very unlikely that two different definitions for the same acronym shall be used in the same string
			// it is more likely that the definition shall be found near the first instance.
			$defArray = ReTidy::findDefinitions($acronym, $offset, $contextualCode);
			$defArray = array_filter($defArray, "emptyDefinitions");
			if(sizeof($defArray) > 0) { 
				foreach($defArray as $def) {
					foreach($definition as $ExistingDefinition55) {
						if(ReTidy::areSimilarDefinitions($def, $ExistingDefinition55)) { // we easily found a definition from the context
							$string = preg_replace($acronym_pattern2, '$1XXX9o9BeginAcronymXXX' . htmlentities($ExistingDefinition55) . '9o9XXX' . $acronym . 'XXX9o9EndAcronym9o9XXX$2', $string, -1, $ct2);
							ReTidy::recordTheApplication($ct2, $acronym, $ExistingDefinition55, true);						
							break 2;
						}
					}
				}			
			} else { // the context did not help; check for any patterns of application for this file.
				$definition_to_use = false;
				$highest_count = 0;
				foreach($this->acronymReplaceArray as $index => $value) {
					$counted_acronym = $value[0];
					$counted_definition = $value[1];
					$counted_count = $value[2];
					if($counted_acronym === $acronym && $counted_count > $highest_count) {
						$definition_to_use = $counted_definition;
						$highest_count = $counted_count;
					}
				}
				if($definition_to_use) {
					// it is rare and not very smart to have the same acronym with different definitions in the same document.
					// some choices for how to work are: stubborn (take the most popular definition in the document) and 
					// adaptive (adapt to the latest definition). We are here being stubborn.
					$string = preg_replace($acronym_pattern2, '$1XXX9o9BeginAcronymXXX' . htmlentities($definition_to_use) . '9o9XXX' . $acronym . 'XXX9o9EndAcronym9o9XXX$2', $string, -1, $ct4);
					ReTidy::recordTheApplication($ct4, $acronym, $definition_to_use, true);					
				} else {
					// if we get to here, then we have no idea which one to apply... so apply the first one.
					$first_definition = $definition[0];
					$string = preg_replace($acronym_pattern2, '$1XXX9o9BeginAcronymXXX' . htmlentities($first_definition) . '9o9XXX' . $acronym . 'XXX9o9EndAcronym9o9XXX$2', $string, -1, $ct3);
					ReTidy::recordTheApplication($ct3, $acronym, $first_definition, true);				
				}
			}
		} else {
			$string = preg_replace($acronym_pattern2, '$1XXX9o9BeginAcronymXXX' . htmlentities($definition) . '9o9XXX' . $acronym . 'XXX9o9EndAcronym9o9XXX$2', $string, -1, $ct);
			ReTidy::recordTheApplication($ct, $acronym, $definition, false);
		}
		return $string;
	}		
	
	protected function recordTheApplication($ct, $acronym, $definition, $multiple_definitions = false) {
		if($ct > 0) {
			$counted_acronym_exists = false;
			foreach($this->acronymReplaceArray as $index => $value) {
				$counted_acronym = $value[0];
				$counted_definition = $value[1];
				$counted_count = $value[2];
				if($acronym === $counted_acronym && $definition === $counted_definition) {
					$this->acronymReplaceArray[$index][2] += $ct;
					$counted_acronym_exists = true;
					break;
				}
			}
			if(!$counted_acronym_exists) {
				$this->acronymReplaceArray[] = array($acronym, $definition, $ct, $multiple_definitions);
			}
		}		
	}

	protected function html_to_word () {
		if($this->language === 'french') {
			if(file_exists('swept' . DS . 'abbr-fra.txt')) {
				$temp_acronyms_array = explode('
', file_get_contents('swept' . DS . 'abbr-fra.txt'));
				foreach($temp_acronyms_array as $index => $value) {
					if(strlen($value) > 0) {
						$acronym = substr($value, 0, strpos($value, '	'));
						$definition = substr($value, strpos($value, '	'));
						$this->acronymsArray[$acronym] = $definition;
					}
				}
			} else {
				$this->acronymsArray = array();
			}
		} else {
			if(file_exists('swept' . DS . 'abbr-eng.txt')) {
				$temp_acronyms_array = explode('
', file_get_contents('swept' . DS . 'abbr-eng.txt'));
				foreach($temp_acronyms_array as $index => $value) {
					if(strlen($value) > 0) {
						$acronym = substr($value, 0, strpos($value, '	'));
						$definition = substr($value, strpos($value, '	'));
						$this->acronymsArray[$acronym] = $definition;
					}
				}
			} else {
				$this->acronymsArray = array();
			}
		}
		preg_match_all('/<acronym[^<>]*? title="([^"]*?)"[^<>]*?>(.*?)<\/acronym>/is', $this->code, $acronym_matches);
		foreach($acronym_matches[0] as $index => $value) {
			$this->acronymsArray[$acronym_matches[2][$index]] = $acronym_matches[1][$index];
		}
		preg_match_all('/<abbr[^<>]*? title="([^"]*?)"[^<>]*?>(.*?)<\/abbr>/is', $this->code, $abbr_matches);
		foreach($abbr_matches[0] as $index => $value) {
			//print('here47458589<br>');
			$this->acronymsArray[$abbr_matches[2][$index]] = $abbr_matches[1][$index];
		}
		//$this->acronymsArray = array_unique($this->acronymsArray);
		//var_dump($this->acronymsArray);
		ksort($this->acronymsArray);
		//var_dump($this->acronymsArray);exit(0);
		//$this->acronymsArray = ReTidy::multidimensional_sorted_array_unique($this->acronymsArray);
		$abbr_file_contents = '';
		foreach($this->acronymsArray as $index => $value) {
			$abbr_file_contents .= $index . '	' . $value . '
';
		}
		if($this->language === 'french') {
			file_put_contents('swept' . DS . 'abbr-fra.txt', $abbr_file_contents);
		} else {
			file_put_contents('swept' . DS . 'abbr-eng.txt', $abbr_file_contents);
		}
		// now for accessibility data for this file
		$metadata_file_contents = '[Metadata]
';
		//var_dump($this->saved_code_parts, $this->saved_metadata_matches, $this->file);
		foreach($this->saved_code_parts as $index => $value) {
			if($index === 'h1' || $index === 'content') {
				
			} else {
				$metadata_file_contents .= $index . '	' . $value . '
';
			}
		}
		preg_match_all('/<img[^<>]*? alt="([^"]*?)"[^<>]*?>/is', $this->code, $img_matches);
		$metadata_file_contents .= '[Image alt text]
';
		$counter = 1;
		foreach($img_matches[0] as $index => $value) {
			$metadata_file_contents .= 'Image ' . $counter . ': ' . $img_matches[1][$index] . '
';
			$counter++;
		}
		file_put_contents(str_replace('not-swept', 'swept', substr($this->file, 0, ReTidy::strpos_last($this->file, '.'))) . '_metadata.txt', $metadata_file_contents);
	}
	
	function multidimensional_sorted_array_unique($array) {
		$new_array = array();
		foreach($array as $index => $value) {
			$new_array[serialize($value)] = true;
		}
		$result_array = array();
		foreach($new_array as $index => $value) {
			$result_array[] = unserialize($index);
		}
		return $result_array;
	} 
	
	protected function save_acronyms () {
		// save the acronyms array
		// should have if changed, then save file.
		$minus_extension = substr($this->acronymsFile, 0, strpos($this->acronymsFile, "."));
		$extension = substr($this->acronymsFile, strpos($this->acronymsFile, "."));
		rename($this->acronymsFile, $minus_extension . "-20" . date("ymd-h-i-s") . $extension);
		//file_put_contents($this->acronymsFile, iconv($this->config['encoding'], 'iso-8859-1' . "//TRANSLIT", implode("\r\n", $this->acronymsArray)));
		file_put_contents($this->acronymsFile, implode("\r\n", $this->acronymsArray));
	}
	
	protected function DOM_apply_links () {
		$query = '/';
		$rootNodes = $this->xpath->query($query);
		foreach($rootNodes as $rootNode) {
			rec_dom_apply_links_with_ignore($rootNode, "head");			
		}	
	}
	
	protected function DOM_INAC_apply_links () {
		$query = '/';
		$rootNodes = $this->xpath->query($query);
		foreach($rootNodes as $rootNode) {
			rec_dom_INAC_apply_links_with_ignore($rootNode, "head");			
		}	
	}	
	
	protected function DOM_address_sections () {
		$query = '//' . ReTidy::get_html_namespace() . 'p';
		$Ps = $this->xpath->query($query);
		foreach($Ps as $P) {
			// this does not seem to work; what a bore...
			print("*5*<br>\r\n");
			var_dump(rec_DOM_getNodeString($P));
			$ForeText = 'XXX9o9AddressSectionBegin9o9XXX';
			$AftText = 'XXX9o9AddressSectionEnd9o9XXX';
			$firstChild = $node->firstChild;
			$lastChild = $node->lastChild;
			$paragraph_code = rec_DOM_getNodeString($P);
			preg_match_all('/.*(' . $this->a_postal_code . ').*(' . $this->a_phone_number . ').*(' . $this->an_email . ').*/s', $paragraph_code, $matches);
			foreach($matches[0] as $match) {
				$firstChild->parentNode->insertBefore(new DOMText($ForeText), $firstChild);
				$lastChild->nodeValue = $lastChild->nodeValue . $AftText;
			}
		}	
	}	
	
	protected function DOM_apply_email () {
		$query = '/';
		$rootNodes = $this->xpath->query($query);
		foreach($rootNodes as $rootNode) {
			rec_dom_apply_email_with_ignore($rootNode, "head", $this->an_email);	
		}	
	}		
	
	protected function post_dom_acronyms () {
		preg_match_all('/XXX9o9BeginAcronymXXX([^<>]*?)9o9XXX([^<>]*?)XXX9o9EndAcronym9o9XXX/is', $this->code, $matches);
		foreach($matches[0] as $index => $value) {
			$this->code = str_replace('XXX9o9BeginAcronymXXX' . $matches[1][$index] . '9o9XXX' . $matches[2][$index] . 'XXX9o9EndAcronym9o9XXX', '<acronym title="' . html_entity_decode(html_entity_decode($matches[1][$index])) . '">' . $matches[2][$index] . '</acronym>', $this->code);
		}
		return true;		
	}
	
	protected function post_dom_repair_links () {
		$this->code = preg_replace(
		'/http:\/\/\s*XXX9o9BeginLinkXXX([^<>]*?)9o9XXX([^<>]*?)XXX9o9EndLink9o9XXX/', 
		'XXX9o9BeginLinkXXX${1}9o9XXXhttp://$2XXX9o9EndLink9o9XXX', 
		$this->code, -1, $count);
		$this->code = preg_replace(
		'/XXX9o9BeginLinkXXX([^<>]*?)9o9XXX([^<>]*?)XXX9o9EndLink9o9XXX\s*([^<> ]*(\.html|\.htm|\.php|\.asp))/', 
		'XXX9o9BeginLinkXXX${1}${3}9o9XXX${2}${3}XXX9o9EndLink9o9XXX', 
		$this->code, -1, $count);
		$this->code = preg_replace(
		'/XXX9o9BeginLinkXXX([^<>]*?)\.9o9XXX([^<>]*?)\.XXX9o9EndLink9o9XXX/', 
		'XXX9o9BeginLinkXXX${1}9o9XXX${2}XXX9o9EndLink9o9XXX.', 
		$this->code, -1, $count);				
		$this->logMsgIf("post_dom_repair_links", $count);
		return true;		
	}

	protected function post_dom_links () {
		$this->code = preg_replace('/XXX9o9BeginLinkXXX([^<>]*?)9o9XXX([^<>]*?)XXX9o9EndLink9o9XXX/', '<a href="$1">$2</a>', $this->code, -1, $count);
		$this->logMsg("post_dom_links $count ");
		return true;		
	}
	
	protected function post_dom_email () {
		$this->code = preg_replace('/XXX9o9BeginEmailXXX([^<>]*?)9o9XXX([^<>]*?)XXX9o9EndEmail9o9XXX/', '<a href="$1">$2</a>', $this->code, -1, $count);
		$this->logMsg("post_dom_email $count ");
		return true;		
	}		

	protected function post_dom_address_sections () {
		// for testing:
		$this->code = str_replace('XXX9o9AddressSectionBegin9o9XXX', '<span style="font-size:200%; color:green;">', $this->code);
		$this->code = str_replace('XXX9o9AddressSectionEnd9o9XXX', '</span>', $this->code);		
		/*
		$c = $ct = 0;
		preg_match_all('/XXX9o9AddressSectionBegin9o9XXX.*(' . $this->a_postal_code . ').*(' . $this->a_phone_number . ').*(' . $this->an_email . ').*XXX9o9AddressSectionEnd9o9XXX/', $this->code, $matches);
		foreach($matches[0] as $match) {
			$initial_match = $match;
			$match = preg_replace('/' . $this->a_postal_code . '/', '$0<br />', $match);
			$match = preg_replace('/' . $this->a_phone_number . '/', '$0<br />', $match);
			$match = preg_replace('/' . $this->an_email . '/', '$0<br />', $match);
			$this->code = str_replace('$initial_match', '$match', $this->code, $c);
			$ct += $c;
		}
		$this->logMsgIf("post_dom_address_sections", $ct);*/
		return true;		
	}			
	
	protected function post_dom_remove_undefined_acronyms () {
		$ct_ar = 0;
		if (strpos($this->code, "<acronym") != false) {
			$this->code = preg_replace('/<acronym title="definition">([^<]*)<\/acronym>/is', '$1', $this->code, -1, $ct_ar);
		}
		$this->logMsgIf("undefined acronyms removed", $ct_ar);
	}	
	
	protected function pre_tidy_ASP () {
		// these are not good enough. we would need the ASP server to run so that the
		// document object could properly be created then somehow revert the ASP to its preprocessed state.
		// also: there could be includes with includes in them so we must process until no chances are made
		// but since we need to remove these afterwards; we need some way to mark the level of the include so as to
		// be able to match its closing and ending tags without using the DOM (since we cannot save the DOM after 
		// unincluding some code since it may be necessary for the DOM.
		$ASP_include_statements = array(array(-1),-1);
		$count_of_level_of_include = 1;
		preg_match_all('/<!--#include virtual="([^"]*)" -->/is', $this->code, $ASP_include_statements);
		foreach($ASP_include_statements[0] as $index => $ASP_include_statement) {
			$this->code = str_replace($ASP_include_statements[0][$index], '<!--ASPInclude' . $count_of_level_of_include . 'Begin-->
' . html_entity_decode(file_get_contents(substr($ASP_include_statements[1][$index], 1))) . '<!--ASPInclude' . $count_of_level_of_include . 'End-->
', $this->code);
		}
		$this->code = str_replace('<%', '<!--9o9ASPopen9o9', $this->code);
		$this->code = str_replace('%>', '9o9ASPclose9o9-->', $this->code);
		$count_of_level_of_include++;
		return true;		
	}
	
	protected function post_tidy_ASP () {
		$this->code = preg_replace('/<!--ASPInclude1Begin-->.*?<!--ASPInclude1End-->/is', '', $this->code);
		// for INAC (2008-11-10) this is good enough since its ASP includes do not have ASP includes
		// maybe, for example, parcs canada CLF1 does.
		$this->code = str_replace('<!--9o9ASPopen9o9', '<%', $this->code);
		$this->code = str_replace('9o9ASPclose9o9-->', '%>', $this->code);
		return true;		
	}
	
	function number_missing_abbr() {
		$before_abbr_count = ReTidy::get_abbr_count();
		ReTidy::abbr_macro();
		$after_abbr_count = ReTidy::get_abbr_count();
		//print('$before_abbr_count, $after_abbr_count: ');var_dump($before_abbr_count, $after_abbr_count);
		return $after_abbr_count - $before_abbr_count;
	}
	
	function get_abbr_count() {
		$abbr_count = 0;
		$abbr_count += substr_count($this->code, '<abbr');
		$acronym_count += substr_count($this->code, '<acronym');
		return $abbr_count;
	}
	
	protected function quality_assurance() {
		$quality_assurance_string = "";
		$quality_assuranceRxpArray = array(
		'(<[^>]+? class=")([^"]*)("[^>]*?) class="([^"]*)"([^>]*?>)' => '$1$2 $4$3$5',
		'(<[^>]+? style=")([^"]*)("[^>]*?) style="([^"]*)"([^>]*?>)' => '$1$2 $4$3$5',
		'(<acronym title="[^"]*">)\1([^<]*)<\/acronym><\/acronym>' => '$1$2</acronym>',
		'(<abbr title="[^"]*">)\1([^<]*)<\/abbr><\/abbr>' => '$1$2</abbr>',
		'XXX9o9\w*?9o9XXX' => '',
		);
		foreach($quality_assuranceRxpArray as $search => $replace) {
			$c = -1;
			while($c !== 0) {
				$this->code = preg_replace("/" . $search . "/is", $replace, $this->code, -1, $c);
				if($c > 0) {
					$quality_assurance_string .= htmlentities($search) . " " . $c . "<br>\r\n";
				}
			}
		}
		$quality_assurance_array = array(
		'«[^»]*?«',
		'»[^«]*?»',
		'‘[^’]*?‘',
		'“[^”]*?“',
		'”[^“]*?”',
		'‹[^›]*?‹',
		'›[^‹]*?›',
		);
		foreach($quality_assurance_array as $index => $search) {
			preg_match_all("/" . $search . "/is", $this->code, $matches);
			if(sizeof($matches[0]) > 0) {
				$quality_assurance_string .= "quotes nesting error: " . htmlentities($search) . " " . sizeof($matches[0]) . "<br>\r\n";
			}
		}
		//$double_enc_count = substr_count($this->code, '&amp;&');
		preg_match_all('/&amp;\w+;/is', $this->code, $double_enc_matches);
		if(sizeof($double_enc_matches[0]) > 0) {
			$quality_assurance_string .= "doubly encoded character entities found " . sizeof($double_enc_matches[0]) . "<br>\r\n";
		}
		preg_match_all('/<style[^<>]*?>/is', $this->code, $embedded_stylesheet_matches);
		if(sizeof($embedded_stylesheet_matches[0]) > 0) {
			$quality_assurance_string .= "embedded stylesheets found " . sizeof($embedded_stylesheet_matches[0]) . "<br>\r\n";
		}
		$style_count = substr_count($this->code, ' style="');
		if($style_count > 0) {
			$quality_assurance_string .= "inline styles found " . $style_count . "<br>\r\n";
		}
		$number_of_missing_abbr = ReTidy::number_missing_abbr();
		if($number_of_missing_abbr > 0) {
			$quality_assurance_string .= "missing abbreviations " . $number_of_missing_abbr . "<br>\r\n";
		}
		$number_of_possibly_doubly_encoded_entities = substr_count($this->code, '&amp;#'); // apaprently not working
		if($number_of_possibly_doubly_encoded_entities > 0) {
			$quality_assurance_string .= "possibly doubly-encoded entities " . $number_of_possibly_doubly_encoded_entities . "<br>\r\n";
		}
		if(strlen($quality_assurance_string) > 0) {
			$quality_assurance_string = "<br>\r\n=== quality assurance begin ===<br>\r\n" . $quality_assurance_string . "=== quality assurance end ===<br>\r\n";
			$this->logMsg($quality_assurance_string);
		}
		return true;
	}
	
	function EliminateDuplicateArrayEntries($input) {
		foreach($this->array_for_filtering_duplicates as $arrayElement) {
			if($arrayElement === $input) {
				return false;
			}
		}
		return true;
	}

	protected function DOM_getDocString() {
		return $this->dom->saveXML();
	}
	
	protected function DOM_getNodeString($node) {
		if(!$node->nodeType) {
			print("not a node (DOM_getNodeString) :");var_dump($node);print("<br>\r\n");exit(0);
			return false;
		}
		return $this->dom->saveXML($node);
	}

	
	function giveAttributesToParentWithoutOverwrite($node) {
		$parentNode = $node->parentNode;
		$ignore_array = array('stripme', 'XXX9o9stripme9o9XXX');
		ReTidy::applyAttributesWithoutOverwriteWithIgnore($node, $parentNode, $ignore_array);
		return true;
	}
	
	function giveAttributesToMostAncientConflationaryInlineAllowed($node) {
		if($node->hasAttributes()) {
			$attributesArray = array();
			$ignore_array = array('stripme', 'XXX9o9stripme9o9XXX');
			foreach($node->attributes as $attribute) {
				foreach($ignore_array as $ignore) {
					if($ignore === $attribute->nodeName) {
						continue 2;
					}
					if($ignore === $attribute->nodeValue) {
						continue 2;
					}
				}
				$attributesArray[] = $attribute->nodeName;
			}
			$mostAncientConflationary = ReTidy::mostAncientConflationaryInlineAncestorAllowed($node, $attributesArray);
			if($mostAncientConflationary !== $node) {
				ReTidy::applyAttributesWithoutOverwriteWithIgnore($node, $mostAncientConflationary, $ignore_array);
				return true;
			}
		}
		return false;
	}
	
	function giveAttributesToLeastAncientConflationaryBlockAllowed($node) {
		if($node->hasAttributes()) {
			$attributesArray = array();
			$ignore_array = array('stripme', 'XXX9o9stripme9o9XXX');
			foreach($node->attributes as $attribute) {
				foreach($ignore_array as $ignore) {
					if($ignore === $attribute->nodeName) {
						continue 2;
					}
					if($ignore === $attribute->nodeValue) {
						continue 2;
					}
				}
				$attributesArray[] = $attribute->nodeName;
			}
			$leastAncientConflationary = ReTidy::leastAncientConflationaryBlockAncestorAllowed($node, $attributesArray);
			if($leastAncientConflationary !== $node) {
				ReTidy::applyAttributesWithoutOverwriteWithIgnore($node, $leastAncientConflationary, $ignore_array);
				return true;
			}
		}
		return false;
	}	
	
	protected function mostAncientConflationaryInlineAncestorAllowed($tag, $attributesArray) {
		$original_tag = $tag;
		while(ReTidy::isInlineForMostAncientConflationary($tag->parentNode) && ReTidy::DOM_isConflationaryWithChildIgnoringSpace($tag->parentNode)) {
			$allowed_attributes = DTD::getAttlist($tag->parentNode);
			foreach($attributesArray as $requiredAttribute) {
				foreach($allowed_attributes as $allowed_attribute) {
					if($allowed_attribute === $requiredAttribute) {
						continue 2;
					}
				}
				// if we get to here than a required attribute is not in the attlist.
				$tag = $tag->parentNode;
				continue 2;
			}
			return ReTidy::mostAncientConflationaryInlineAncestorAllowed($tag->parentNode, $attributesArray);
		}
		return $original_tag;
	}

	protected function leastAncientConflationaryBlockAncestorAllowed($tag, $attributesArray) {
		$original_tag = $tag;
		while(ReTidy::DOM_isConflationaryWithChildIgnoringSpace($tag->parentNode)) {
			if(ReTidy::isBlock($tag->parentNode)) { // check if it is a block
			
			} else {
				$tag = $tag->parentNode;
				continue;
			}
			$allowed_attributes = DTD::getAttlist($tag->parentNode);
			foreach($attributesArray as $requiredAttribute) {
				foreach($allowed_attributes as $allowed_attribute) {
					if($allowed_attribute === $requiredAttribute) {
						continue 2;
					}
				}
				// if we get to here than a required attribute is not in the attlist.
				$tag = $tag->parentNode;
				continue 2;
			}
			return $tag->parentNode;
		}
		return $original_tag;
	}
	
	function giveAttributesToMostAncientConflationaryWithoutOverwrite($node) {
		$mostAncientConflationary = ReTidy::mostAncientConflationaryInlineAncestorWithIgnore($node, "sup");
		$ignore_array = array('stripme', 'XXX9o9stripme9o9XXX');
		ReTidy::applyAttributesWithoutOverwriteWithIgnore($node, $mostAncientConflationary, $ignore_array);
		return true;
	}	
	
	function applyAttributesWithoutOverwriteWithIgnore($node_with_attributes, $node_to_apply_attributes_to, $ignore_array) {
		foreach($node_with_attributes->attributes as $attribute_to_apply) {
			foreach($ignore_array as $ignore) {
				if(strpos($attribute_to_apply->nodeName, $ignore) !== false) {
					continue 2;
				}
				if(strpos($attribute_to_apply->nodeValue, $ignore) !== false) {
					continue 2;
				}
			}
			ReTidy::applyAttributeWithoutOverwrite($attribute_to_apply, $node_to_apply_attributes_to);
		}
		return true;	
	}

	function applyAttributesWithoutOverwrite($node_with_attributes, $node_to_apply_attributes_to) {
		foreach($node_with_attributes->attributes as $attribute_to_apply) {
			ReTidy::applyAttributeWithoutOverwrite($attribute_to_apply, $node_to_apply_attributes_to);
		}
		return true;	
	}
	
	function applyHeadersWithoutOverwriteIfNew($value, $node) {
		//print('here485969070<br>');
		$headers_attribute = ReTidy::getAttribute($node, "headers");
		if($headers_attribute) {
			//print('here485969071<br>');
			if(ReTidy::contains_whole_word_for_styles($headers_attribute->nodeValue, $value) === false) {
				//print('here485969071.5<br>');
				$node->setAttribute('headers', $headers_attribute->nodeValue . " " . $value);
			}
		} else {
			//print('here485969072<br>');
			$node->setAttribute('headers', $value);
		}
	}
	
	function applyHeadersWithoutOverwrite($value, $node) {
		$headers = ReTidy::getAttribute($node, "headers");
		if($headers) {
			$node->setAttribute('headers', $headers->nodeValue . " " . $value);
		} else {
			$node->setAttribute('headers', $value);
		}
	}
	
	function applyAttributeWithoutOverwrite($attribute_to_apply, $node_to_apply_attributes_to) {
		if($attribute_to_apply->nodeName === "stripme" || $attribute_to_apply->nodeName === "deleteme") {
			return false;
		}
		$alreadyHasThisAttribute = false;
		foreach($node_to_apply_attributes_to->attributes as $existingAttribute) {
			if($attribute_to_apply->nodeName === $existingAttribute->nodeName) {
				$alreadyHasThisAttribute = true;
				if($attribute_to_apply->nodeName === "style") {
					$existingAttribute->nodeValue = trim($existingAttribute->nodeValue); 
					// it may be more efficient to simply cleanStyles() before we are changing style attributes around.
					$existingAttribute->nodeValue = ReTidy::ensureStyleInformationEndsProperly($existingAttribute->nodeValue); // clean it completely?
					$existingAttribute->nodeValue = $existingAttribute->nodeValue . $attribute_to_apply->nodeValue;
				} elseif($attribute_to_apply->nodeName === "class" || $attribute_to_apply->nodeName === "headers") {
					$existingAttribute->nodeValue = $existingAttribute->nodeValue . " " . $attribute_to_apply->nodeValue;
				} elseif($attribute_to_apply->nodeName === "lang" || $attribute_to_apply->nodeName === "xml:lang") {
					// overwrite it.
					$existingAttribute->nodeValue = $attribute_to_apply->nodeValue;
				} elseif($attribute_to_apply->nodeName === "id") { 
					// the assumption is that if we get here, then we are running clean_word and have merged useless microsft word <div>s.			
					// do nothing.
				} elseif($attribute_to_apply->nodeName === "dir") { 
					// do nothing.
				} elseif($attribute_to_apply->nodeName === "align") { 
					// the assumption is that if we get here, then we want to apply the align attribute to a conflationary parent.
					$node_to_apply_attributes_to->setAttribute($attribute_to_apply->nodeName, $attribute_to_apply->nodeValue);
				} elseif($attribute_to_apply->nodeValue === $existingAttribute->nodeValue) { 
					// do nothing.
				} else {
					// here we assume that other than class and style, there are no attributes that can be added...
					// this works for (the only case considered) align="" but something smarter would be better.
					// that is; something that refers to the DTD... I do not know if tidy can do this... (2009-02-03)
					// (2009-08-20) do nothing does not work for me... at the least assume that if this function is called, then 
					// it wants attributes to be applied...
					print("!!!<br>");
					print("Trying to put attribute on parent but how to merge for this one is not accounted for436:<br>");
					print(ReTidy::DOM_getNodeString($attribute_to_apply));print("to: <br>");
					print(ReTidy::DOM_getNodeString($node_to_apply_attributes_to));print("<br>");
					print("!!!<br>");
				}
			}
		}
		if(!$alreadyHasThisAttribute) {
			$node_to_apply_attributes_to->setAttribute($attribute_to_apply->nodeName, $attribute_to_apply->nodeValue);
		}
		return true;	
	}
	
	function removeComments($styleCode) {
		$styleCode = str_replace('<!--', '', $styleCode);
		$styleCode = str_replace('-->', '', $styleCode);
		$styleCode = preg_replace('/\/\*.*?\*\//s', '', $styleCode);
		return $styleCode;
	}
	
	function removeAts($styleCode) {
		$styleCode = preg_replace('/@(font\-face|page)[^\{]*\{[^\{\}]*\}/s', '', $styleCode);
		return $styleCode;
	}
	
	// music sweeping functions
	
	// I suppose we could use DOM... but it's probably overcomplicated
	function demeasurify() {
		$this->code = str_replace('<measure', '<measure stripme="y"', $this->code, $count);
		$this->logMsgIf('measures removed', $count);
	}
	
	function remove_note_types() {
		// assuming the <type> tag is only used for note types
		$this->code = str_replace('<type', '<type stripme="y"', $this->code, $count);
		$this->logMsgIf('note types removed', $count);
	}
	
	function join_rests() {
		$count = 0;
		preg_match_all('/<part([^\-][^<>]*?)>(.*?)<\/part>/is', $this->code, $part_matches, PREG_OFFSET_CAPTURE);
		$part_counter = sizeof($part_matches[0]) - 1;
		while($part_counter > -1) {
			$part = $part_matches[0][$part_counter][0];
			$part_offset = $part_matches[0][$part_counter][1];
			$part_length = strlen($part);
			preg_match_all('/<note(.*?)<\/note>/is', $part, $note_matches, PREG_OFFSET_CAPTURE);
			foreach($note_matches[0] as $note_index => $note_value) {
				if(strpos($note_value[0], '<rest') !== false) {
					$note_matches[0][$note_index][2] = 'is a rest';
				}
			}
			$note_counter = sizeof($note_matches[0]) - 1;
			while($note_counter > 0) { // there is nothing earlier then the first note in a part to possibly join into
				$note = $note_matches[0][$note_counter][0];
				$note_offset = $note_matches[0][$note_counter][1];
				$note_length = strlen($note);
				if($note_matches[0][$note_counter][2] === 'is a rest' && $note_matches[0][$note_counter - 1][2] === 'is a rest') {
					// add the rest duration to the previous rest
					preg_match('/<duration([^<>]*?)>(.*?)<\/duration>/is', $note_matches[0][$note_counter][0], $duration_matches);
					$rest_duration = $duration_matches[2];
					preg_match('/<duration([^<>]*?)>(.*?)<\/duration>/is', $note_matches[0][$note_counter - 1][0], $previous_duration_matches);
					$previous_rest_duration = $previous_duration_matches[2];
					// it probably won't happen that <duration> tags have attributes but whatever
					$note_matches[0][$note_counter - 1][0] = '<duration' . $duration_matches[1] . $previous_duration_matches[1] . '>' . $rest_duration + $previous_rest_duration . '</duration>';
					// then omit the rest
					$part = substr($part, 0, $note_offset) . substr($part, $note_offset + $note_length);
					$count++;
				}
				$note_counter--;
			}
			$this->code = substr($this->code, 0, $part_offset) . $part . substr($this->code, $part_offset + $part_length);
			$part_counter--;
		}
		$this->logMsgIf('rests joined', $count);
	}
	
	function normalize_durations() {
		// this could be a tricky function
		// remember to adjust the tempo...
		// round durations to 2 significant digits
		// go until 10 notes of the same duration are found (less than something like this and we can't really be sure of a good normalization)
		// the duration of these 10 notes becomes the factor to multiply the tempo by and divide all note durations by
		
		// check that all notes durations are whole number... if not then: quit? recurse? recursion probably shouldn't work all the work is multiplicative and choosing a factor that works for some numbers but not others
		// is undispeative when choosing another set of notes so the best when can do is multiply all note durations by whatever factor the problematic note must be multiplied by to become a whole number
		// for this reason we should probably try to find the set of notes with the same duration that is the smallest duration to work with.
		$count = 0;
		$key_factor = 1000000; // a sufficiently large number that we'll practically never deal with durations that are the inverse of it and big enough to avoid key-value associative array key rounding while still using key sorting for this king of array; notice that array indices seem to be 32-bit or something so I guess we should not choose a number higher than this (or maybe half of it?)
		preg_match_all('/<part([^\-][^<>]*?)>(.*?)<\/part>/is', $this->code, $part_matches, PREG_OFFSET_CAPTURE);
		//var_dump($part_matches);exit(0);
		$part_counter = sizeof($part_matches[0]) - 1;
		while($part_counter > -1) {
			$part = $part_matches[0][$part_counter][0];
			$part_offset = $part_matches[0][$part_counter][1];
			$part_length = strlen($part);
			preg_match_all('/<note(.*?)<\/note>/is', $part, $note_matches, PREG_OFFSET_CAPTURE);
			foreach($note_matches[0] as $note_index => $note_value) {
				if(strpos($note_value[0], '<rest') !== false) {
					$note_matches[0][$note_index][2] = 'is a rest';
				}
			}
			$durations_counting_array = array();
			$note_counter = sizeof($note_matches[0]) - 1;
			while($note_counter > -1) {
				$note = $note_matches[0][$note_counter][0];
				$note_offset = $note_matches[0][$note_counter][1];
				$note_length = strlen($note);
				if($note_matches[0][$note_counter][2] === 'is a rest') { // ignore rests for the purposes of this function
					
				} else {
					preg_match('/<duration([^<>]*?)>(.*?)<\/duration>/is', $note_matches[0][$note_counter][0], $duration_matches);
					//var_dump($duration_matches);exit(0);
					// first, round to 2 significant digits
					$rounded_duration = ReTidy::round_to_number_of_significant_digits($duration_matches[2], 2);
					if(isset($durations_counting_array[$key_factor * $rounded_duration])) {
						$durations_counting_array[$key_factor * $rounded_duration]++;
					} else {
						$durations_counting_array[$key_factor * $rounded_duration] = 1;
					}
				}
				$note_counter--;
			}
			ksort($durations_counting_array);
			print('durations_counting_array: ');var_dump($durations_counting_array);
			$smallest_popular_duration = false;
			foreach($durations_counting_array as $index => $value) {
				if($value >= 10) {
					$smallest_popular_duration = $index / $key_factor;
					break;
				}
			}
			// we could normalize all the various parts but we shouldn't ignore that they can have independant timings (although related ones would probably be more pleasing)
			if($smallest_popular_duration !== false) {
				print('The smallest popular duration is: ');var_dump($smallest_popular_duration);
				$note_counter = sizeof($note_matches[0]) - 1;
				while($note_counter > -1) {
					$note = $note_matches[0][$note_counter][0];
					$note_offset = $note_matches[0][$note_counter][1];
					$note_length = strlen($note);
					preg_match('/<duration([^<>]*?)>(.*?)<\/duration>/is', $note, $duration_matches);
					// notice that this does not round to the nearest nice (quarter, half note etc...) duration bot to the nearest whole number duration
					$normalized_duration = round($duration_matches[2] / $smallest_popular_duration);
					$count++;
					if($normalized_duration > 0) { // do we really want to do this? If this function does not behave well then we'll be losing notes
						$note = preg_replace('/<duration([^<>]*?)>(.*?)<\/duration>/is', '<duration$1>' . $normalized_duration . '</duration>', $note);
						$part = substr($part, 0, $note_offset) . $note . substr($part, $note_offset + $note_length);
					} else {
						$part = substr($part, 0, $note_offset) . substr($part, $note_offset + $note_length);
					}
					$note_counter--;
				}
			} else {
				ReTidy::warning('Did not find enough note durations of the same duration to normalize durations.');var_dump($part);
			}
			$this->code = substr($this->code, 0, $part_offset) . $part . substr($this->code, $part_offset + $part_length);
			$part_counter--;
		}
		$this->logMsgIf('durations normalized', $count);
	}
	
	function remove_insignificant_rests() { // needed?
		
	}
	
	function round_to_number_of_significant_digits($number, $significant_digits) {
		//print('duration: ');var_dump($number);
		if(!is_string($number)) {
			print('<span style="color: red;">Function round_to_number_of_significant_digits was supplied with something other than a number.</span>');var_dump($number);exit(0);
		}
		/*print('treat number (long?) as array test');
		$counter = 0;
		while($counter < strlen($number)) {
			print('number[$counter]: ');var_dump($number[$counter]);
		} exit(0);*/
		$split_string = str_split($number);
		$precision = 0;
		$significant_digits_found = 0;
		$found_decimal = false;
		foreach($split_string as $character) {
			if(!$found_decimal) {
				if($character === '.') {
					$found_decimal = true;
				} elseif($significant_digits_found === 0 && $character === '0') {
					// not a significant digit
				} elseif(preg_match('/[0-9]/', $character)) { // this is a significant digit
					$significant_digits_found++;
				}
			} else {
				if($character === '.') {
					print('<span style="color: red;">Trying to parse decimal number in round_to_number_of_significant_digits but more than one decimal pont was found.</span>');var_dump($number);exit(0);
				} elseif($significant_digits_found === 0 && $character === '0') {
					$precision++;
				} elseif(preg_match('/[0-9]/', $character)) { // this is a significant digit
					$precision++;
					$significant_digits_found++;
				}
			}
		}
		//print('rounded duration: ');var_dump(round($number, $significant_digits - $significant_digits_found + $precision));
		return round($number, $significant_digits - $significant_digits_found + $precision);
	}
	
	function apply_note_types() {
		/*
		<attributes>
		<divisions>4</divisions>
		<key>
		<fifths>1</fifths>
		<mode>major</mode>
		</key>
		<time>
		<beats>4</beats>
		<beat-type>4</beat-type>
		</time>
		<clef>
		<sign>G</sign>
		<line>2</line>
		</clef>
		</attributes>
		*/
		
		$count = 0;
		preg_match_all('/<part([^\-][^<>]*?)>(.*?)<\/part>/is', $this->code, $part_matches, PREG_OFFSET_CAPTURE);
		$part_counter = sizeof($part_matches[0]) - 1;
		while($part_counter > -1) {
			$part = $part_matches[0][$part_counter][0];
			$part_offset = $part_matches[0][$part_counter][1];
			$part_length = strlen($part);
			preg_match('/<beat\-type>(.*?)<\/beat\-type>/is', $part, $beat_type_matches);
			$beat_type = $beat_type_matches[1];
			preg_match('/<divisions>(.*?)<\/divisions>/is', $part, $divisions_matches);
			$divisions = $divisions_matches[1];
			preg_match_all('/<note(.*?)<\/note>/is', $part, $note_matches, PREG_OFFSET_CAPTURE);
			$note_counter = sizeof($note_matches[0]) - 1;
			while($note_counter > -1) {
				$note = $note_matches[0][$note_counter][0];
				$note_offset = $note_matches[0][$note_counter][1];
				$note_length = strlen($note);
				preg_match('/<duration([^<>]*?)>(.*?)<\/duration>/is', $note, $duration_matches);
				$duration = $duration_matches[2];
				$note_type = ReTidy::duration_to_note_type($duration, $beat_type, $divisions);
				$part = substr($part, 0, $note_offset) . '<note' . $note_matches[1][$note_counter][0] . '<type>' . $note_type . '</type>
</note>' . substr($part, $note_offset + $note_length);
				$count++;
				$note_counter--;
			}
			$this->code = substr($this->code, 0, $part_offset) . $part . substr($this->code, $part_offset + $part_length);
			$part_counter--;
		}
		$this->logMsgIf('note types applied', $count);
	}
	
	function measurify() {
		// should be a fairly simple matter of counting up to the number of divisions
		// how do notes that span more than one measure work?
		// we could add ids to measures if needed
		// if we have notes that span measure we may need stuff like <notations><tied type="stop"/></notations>
		$count = 0;
		preg_match_all('/<part([^\-][^<>]*?)>(.*?)<\/part>/is', $this->code, $part_matches, PREG_OFFSET_CAPTURE);
		$part_counter = sizeof($part_matches[0]) - 1;
		while($part_counter > -1) {
			$count++;
			$duration_sum = 0;
			$part = $part_matches[0][$part_counter][0];
			$part_offset = $part_matches[0][$part_counter][1];
			$part_length = strlen($part);
			preg_match('/<beat\-type>(.*?)<\/beat\-type>/is', $part, $beat_type_matches);
			$beat_type = $beat_type_matches[1];
			preg_match('/<divisions>(.*?)<\/divisions>/is', $part, $divisions_matches);
			$divisions = $divisions_matches[1];
			$measure_duration = $beat_type * $divisions;
			preg_match_all('/<note(.*?)<\/note>/is', $part, $note_matches, PREG_OFFSET_CAPTURE);
			if(sizeof($note_matches[0]) > 0) {
				$pre_notes_of_part = substr($part, 0, $note_matches[0][0][1]);
				$post_notes_of_part = substr($part, $note_matches[0][sizeof($note_matches[0]) - 1][1] + strlen($note_matches[0][sizeof($note_matches[0]) - 1][0]));
				$part = str_replace('<attributes', '<measure>
<attributes', $pre_notes_of_part);
				foreach($note_matches[0] as $index => $value) {
					$note = $value[0];
					preg_match('/<duration([^<>]*?)>(.*?)<\/duration>/is', $note, $duration_matches);
					$duration = $duration_matches[2];
					$duration_sum += $duration;
					if($duration_sum >= $measure_duration) {
						$note .= '
</measure>
<measure>';
						while($duration_sum >= $measure_duration) {
							$duration_sum -= $measure_duration;
							//print('duration_sum: ');var_dump($duration_sum);print('<br>');
						}
						$count++;
					}
					$part .= $note . '
';
				}
				$part .= str_replace('</part>', '</measure>
</part>', $post_notes_of_part);
				$this->code = substr($this->code, 0, $part_offset) . $part . substr($this->code, $part_offset + $part_length);
			} // could do an else to throw a measure on an empty part if needed
			$part_counter--;
		}
		$this->logMsgIf('measures applied', $count);
	}
	
	function duration_to_note_type($duration, $beat_type, $divisions) {
		// notes are forced into the declared smallest note length (even if their duration is less than 1)
		$power = log($beat_type * $divisions, 2);
		$counter = 0;
		while($duration > pow(2, $counter)) {
			$counter++;
		}
		// notice (presumably) no special treatment for 512th
		if($power - $counter >= 5 && $power - $counter < 6) {
			$note_type = '32nd';
		} elseif($power - $counter >= 13 && $power - $counter < 14) {
			$note_type = '8192nd';
		} elseif($power - $counter >= 4) {
			$note_type = pow(2, floor($power) - $counter) . 'th';
		} elseif($power - $counter < 1) {
			$note_type = 'whole';
		} elseif($power - $counter < 2) {
			$note_type = 'half';
		} elseif($power - $counter < 3) {
			$note_type = 'quarter';
		} elseif($power - $counter < 4) {
			$note_type = 'eighth';
		} else {
			print('Should never get here485040-03-4=');exit(0);
		}
		//var_dump($duration, $beat_type, $divisions, $power, $counter, $note_type);
		return $note_type;
	}
	
	function var_dump_full() {
		$arguments_array = func_get_args();
		foreach($arguments_array as $index => $value) {
			$data_type = gettype($value);
			if($data_type == 'array') {
				$biggest_array_size = ReTidy::get_biggest_sizeof($value);
				if($biggest_array_size > 2000) {
					ini_set('xdebug.var_display_max_children', '2000');
				} elseif($biggest_array_size > ini_get('xdebug.var_display_max_children')) {
					ini_set('xdebug.var_display_max_children', $biggest_array_size);
				}
			} elseif($data_type == 'string') {
				$biggest_string_size = strlen($value);
				if($biggest_string_size > 10000) {
					ini_set('xdebug.var_display_max_data', '10000');
				} elseif($biggest_string_size > ini_get('xdebug.var_display_max_data')) {
					ini_set('xdebug.var_display_max_data', $biggest_string_size);
				}
			} elseif($data_type == 'integer' || $data_type == 'float' || $data_type == 'chr' || $data_type == 'boolean' || $data_type == 'NULL') {
				// these are already compact enough
			} else {
				ReTidy::warning('Unhandled data type in var_dump_full: ' . gettype($value));
			}
			var_dump($value);
		}
	}
	
	function get_biggest_sizeof($array, $biggest = 0) {
		if(sizeof($array) > $biggest) {
			$biggest = sizeof($array);
		}
		foreach($array as $index => $value) {
			if(is_array($value)) {
				$biggest = ReTidy::get_biggest_sizeof($value, $biggest);
			}
		}
		return $biggest;
	}
	
	function fatal_error($message) { 
		print('<span style="color: red;">' . $message . '</span>');exit(0);
	}
	
	function warning($message) { 
		print('<span style="color: orange;">' . $message . '</span><br>');
	}
	
	function fatal_error_once($string) {
		if(!isset($this->printed_strings[$string])) {
			print('<span style="color: red;">' . $string . '</span>');exit(0);
			$this->printed_strings[$string] = true;
		}
		return true;
	}

	function warning_if($string, $count) {
		if($count > 1) {
			ReTidy::warning($string);
		}
	}
	
	function warning_once($string) {
		if(!isset($this->printed_strings[$string])) {
			print('<span style="color: orange;">' . $string . '</span><br>');
			$this->printed_strings[$string] = true;
		}
		return true;
	}
	
}
// end of the ReTidy class.


function strnpos($base, $str, $n) {       
	if ($n <= 0 || intval($n) != $n || substr_count($base, $str) < $n)  return FALSE;
   
	$str = strval($str);
	$len = 0;
   
	for ($i=0 ; $i<$n-1 ; ++$i)
	{
		if ( strpos($base, $str) === FALSE ) return FALSE;
	   
		$len += strlen( substr($base, 0, strpos($base, $str) + strlen($str)) );
	   
		$base = substr($base, strpos($base, $str) + strlen($str) );
	}
	return strpos($base, $str) + $len;
}

function rec_DOM_SearchForNodeName($node, $search, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if ($node->nodeName === $search) {
			 $foundIt = true;
			 return $foundIt;
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				$foundIt = rec_DOM_SearchForNodeName($item, $search, $foundIt);
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_SearchForAttribute($node, $search, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if($node->hasAttributes()) {
			foreach ($node->attributes as $attribute) {
				if ($attribute->nodeName === $search) {
					 $foundIt = true;
					 return $foundIt;
				}
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				$foundIt = rec_DOM_SearchForAttribute($item, $search, $foundIt);
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_SearchForAttributeValue($node, $search, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if($node->hasAttributes()) {
			foreach ($node->attributes as $attribute) {
				if ($attribute->nodeValue === $search) {
					 $foundIt = true;
					 return $foundIt;
				}
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				$foundIt = rec_DOM_SearchForAttributeValue($item, $search, $foundIt);
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_SearchForAttributeWithValue($node, $searchAttribute, $searchAttributeValue, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if($node->hasAttributes()) {
			foreach ($node->attributes as $attribute) {
				if ($attribute->nodeName === $searchAttribute && $attribute->nodeValue === $searchAttributeValue) {
					 $foundIt = true;
					 return $foundIt;
				}
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				$foundIt = rec_DOM_SearchForAttributeValue($item, $searchAttribute, $searchAttributeValue, $foundIt);
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_SearchForNodeNameWithIgnore($node, $search, $ignore, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if ($node->nodeName === $search) {
			 $foundIt = true;
			 return $foundIt;
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				if ($item->nodeName != $ignore) {
					$foundIt = rec_DOM_SearchForNodeNameWithIgnore($item, $search, $ignore, $foundIt);
				}
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_SearchForAttributeWithIgnore($node, $search, $ignore, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if($node->hasAttributes()) {
			foreach ($node->attributes as $attribute) {
				if ($attribute->nodeName === $search) {
					 $foundIt = true;
					 return $foundIt;
				}
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				if ($item->nodeName != $ignore) {
					$foundIt = rec_DOM_SearchForAttributeWithIgnore($item, $search, $ignore, $foundIt);
				}
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_getNodesWithAttribute($node, $search, $array_matching_nodes) {
	if($node->hasAttributes()) {
		foreach ($node->attributes as $attribute) {
			if ($attribute->nodeName === $search) {
				$array_matching_nodes[] = $node;
			}
		}
	}
	if ($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			$array_matching_nodes[] = rec_DOM_SearchForAttribute($item, $search, $array_matching_nodes);
		}	
	}
	return $array_matching_nodes;
}

function rec_DOM_SearchForAttributeValueWithIgnore($node, $search, $ignore, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if($node->hasAttributes()) {
			foreach ($node->attributes as $attribute) {
				if ($attribute->nodeValue === $search) {
					 $foundIt = true;
					 return $foundIt;
				}
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				if ($item->nodeName != $ignore) {
					$foundIt = rec_DOM_SearchForAttributeValueWithIgnore($item, $search, $ignore, $foundIt);
				}
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_SearchForNumbersWithIgnore($node, $ignore, $foundANumber) {
	if ($foundANumber) {
		return $foundANumber;
	} else {
		if($node->nodeType === 3) {
			if (
			strpos($node->nodeValue, "0") !== false ||
			strpos($node->nodeValue, "1") !== false ||
			strpos($node->nodeValue, "2") !== false ||
			strpos($node->nodeValue, "3") !== false ||
			strpos($node->nodeValue, "4") !== false ||
			strpos($node->nodeValue, "5") !== false ||
			strpos($node->nodeValue, "6") !== false ||
			strpos($node->nodeValue, "7") !== false ||
			strpos($node->nodeValue, "8") !== false ||
			strpos($node->nodeValue, "9") !== false
			) {
				 $foundANumber = true;
				 return $foundANumber;
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				if ($item->nodeName != $ignore) {
					$foundANumber = rec_DOM_SearchForNumbersWithIgnore($item, $ignore, $foundANumber);
				}
			}	
		}
	}
	return $foundANumber;
}

function rec_DOM_SearchForAttributeWithValueWithIgnore($node, $searchAttribute, $searchAttributeValue, $ignore, $exactitude_of_match, $foundIt) {
	if ($foundIt === true) {
		return $foundIt;	
	} else {
		if ($exactitude_of_match === "contained") {
			if($node->hasAttributes()) {
				foreach ($node->attributes as $attribute) {
					if ($attribute->nodeName === $searchAttribute && (strpos($attribute->nodeValue, $searchAttributeValue) !== false)) {
						 $foundIt = true;
						 return $foundIt;
					}
				}
			}	
		} else {
			if($node->hasAttributes()) {
				foreach ($node->attributes as $attribute) {
					if ($attribute->nodeName === $searchAttribute && $attribute->nodeValue === $searchAttributeValue) {
						 $foundIt = true;
						 return $foundIt;
					}
				}
			}	
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				if ($item->nodeName != $ignore) {
					$foundIt = rec_DOM_SearchForAttributeWithValueWithIgnore($item, $searchAttribute, $searchAttributeValue, $ignore, $exactitude_of_match, $foundIt);
				}
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_SearchForGoodSummary($node, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if($node->hasAttributes()) {
			foreach ($node->attributes as $attribute) {
				if ($attribute->nodeName === "summary" 
				&& $attribute->nodeValue != "This table is not a Data Table. It is used for the page layout."
				&& $attribute->nodeValue != "Ce table n'est pas un table de donn&eacute;es. Elle est utilis&eacute;e pour la mise en page.") {
					 $foundIt = true;
					 return $foundIt;
				}
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				$foundIt = rec_DOM_SearchForGoodSummary($item, $foundIt);
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_SearchForGoodSummaryWithIgnore($node, $ignore, $foundIt) {
	if ($foundIt) {
		return $foundIt;
	} else {
		if($node->hasAttributes()) {
			foreach ($node->attributes as $attribute) {
				if ($attribute->nodeName === "summary" 
				&& $attribute->nodeValue != "This table is not a Data Table. It is used for the page layout."
				&& $attribute->nodeValue != "Ce table n'est pas un table de donn&eacute;es. Elle est utilis&eacute;e pour la mise en page.") {
					 $foundIt = true;
					 return $foundIt;
				}
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				if ($item->nodeName != $ignore) {
					$foundIt = rec_DOM_SearchForGoodSummaryWithIgnore($item, $ignore, $foundIt);
				}
			}	
		}
	}
	return $foundIt;
}

function rec_DOM_DivMeLabel($node) {
	$ForeText = 'XXX9o9DivMeBegin9o9XXX';
	$AftText = 'XXX9o9DivMeEnd9o9XXX';
	$firstChild = $node->firstChild;
	$lastChild = $node->lastChild;

	if ($node->nodeName === "tr" || $node->nodeName === "td" || $node->nodeName === "th") {
		// if firstChild is a text node then prepend on it, otherwise create a text node				
		if ($firstChild->nodeName === "#text") {
			$firstChild->nodeValue = $ForeText . $firstChild->nodeValue;
		} else {
			$firstChild->parentNode->insertBefore(new DOMText($ForeText), $firstChild);
		}
		$lastChild->nodeValue = $lastChild->nodeValue . $AftText;
	}
	if ($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			rec_DOM_DivMeLabel($item);
		}	
	}
	return true;
}

function rec_DOM_DivMeLabelWithIgnore($node, $DOM, $ignore, $styles_or_classes) {
	$ForeText = 'XXX9o9DivMeBegin9o9XXX';
	$AftText = 'XXX9o9DivMeEnd9o9XXX';
	$firstChild = $node->firstChild;
	$lastChild = $node->lastChild;

	if($styles_or_classes === "styles") {
		if ($node->nodeName === "tr" || $node->nodeName === "table") {		
			$AddStyle = true;
			if($node->hasAttributes()) {
				foreach ($node->attributes as $attribute) {
					if ($attribute->nodeName === "style") {
						$AddStyle = false;
						$attribute->nodeValue = $attribute->nodeValue . "clear:both;";
					}
				}
			}
			if($AddStyle === true) {
				$node->setAttribute('style', 'clear:both;');
			}
			// if firstChild is a text node then prepend on it, otherwise create a text node
			if ($firstChild->nodeName === "#text" || $firstChild->nodeType === 5) {
				$firstChild->nodeValue = $ForeText . $firstChild->nodeValue;
			} else {
				$firstChild->parentNode->insertBefore(new DOMText($ForeText), $firstChild);
			}
			// if lastChild is a text node then append on it, otherwise create a text node
			if ($lastChild->nodeName === "#text" || $lastChild->nodeType === 5) {
				$lastChild->nodeValue = $lastChild->nodeValue . $AftText;
			} else {
				$lastChild->parentNode->appendChild(new DOMText($AftText));
			}		
		}
		if ($node->nodeName === "td" || $node->nodeName === "th") {
			$AddStyle = true;
			if($node->hasAttributes()) {
				foreach ($node->attributes as $attribute) {
					if ($attribute->nodeName === "style") {
						$AddStyle = false;
						$attribute->nodeValue = $attribute->nodeValue . "float:left;";
					}
				}
			}
			if($AddStyle === true) {
				$node->setAttribute('style', 'float:left;');
			}
			// if firstChild is a text node then prepend on it, otherwise create a text node
			// trying to deal with empty nodes; regular expressions can do this...
			if ($firstChild->nodeName === "#text" || $firstChild->nodeType === 5) {
				$firstChild->nodeValue = $ForeText . $firstChild->nodeValue;
			} else {
				if ($firstChild) {
					$firstChild->parentNode->insertBefore(new DOMText($ForeText), $firstChild);
				} else {
					$firstChild->parentNode->firstChild = new DOMText($ForeText);
				}
			}
			// if lastChild is a text node then append on it, otherwise create a text node
			if ($lastChild->nodeName === "#text" || $lastChild->nodeType === 5) {
				$lastChild->nodeValue = $lastChild->nodeValue . $AftText;
			} else {
				if ($lastChild) {
					$lastChild->parentNode->appendChild(new DOMText($AftText));
				} else {
					$lastChild->parentNode->lastChild = new DOMText($AftText);
				}
			}		
		}
	}
	if($styles_or_classes === "classes") {
		if ($node->nodeName === "tr" || $node->nodeName === "table") {		
			$AddClass = true;
			if($node->hasAttributes()) {
				foreach ($node->attributes as $attribute) {
					if ($attribute->nodeName === "class") {
						// consider using styles instead of classes
						$AddClass = false;
						$attribute->nodeValue = $attribute->nodeValue . " clearBoth";
					}
				}
			}
			if($AddClass === true) {
				$node->setAttribute('class', 'clearBoth');
			}
			// if firstChild is a text node then prepend on it, otherwise create a text node
			if ($firstChild->nodeName === "#text" || $firstChild->nodeType === 5) {
				$firstChild->nodeValue = $ForeText . $firstChild->nodeValue;
			} else {
				$firstChild->parentNode->insertBefore(new DOMText($ForeText), $firstChild);
			}
			// if lastChild is a text node then append on it, otherwise create a text node
			if ($lastChild->nodeName === "#text" || $lastChild->nodeType === 5) {
				$lastChild->nodeValue = $lastChild->nodeValue . $AftText;
			} else {
				$lastChild->parentNode->appendChild(new DOMText($AftText));
			}		
		}
		if ($node->nodeName === "td" || $node->nodeName === "th") {
			$AddClass = true;
			if($node->hasAttributes()) {
				foreach ($node->attributes as $attribute) {
					if ($attribute->nodeName === "class") {
						// consider using styles instead of classes
						$AddClass = false;
						$attribute->nodeValue = $attribute->nodeValue . " floatLeft";
					}
				}
			}
			if($AddClass === true) {
				$node->setAttribute('class', 'floatLeft');
			}
			// if firstChild is a text node then prepend on it, otherwise create a text node
			// trying to deal with empty nodes; regular expressions can do this...
			if ($firstChild->nodeName === "#text" || $firstChild->nodeType === 5) {
				$firstChild->nodeValue = $ForeText . $firstChild->nodeValue;
			} else {
				if ($firstChild) {
					$firstChild->parentNode->insertBefore(new DOMText($ForeText), $firstChild);
				} else {
					$firstChild->parentNode->firstChild = new DOMText($ForeText);
				}
			}
			// if lastChild is a text node then append on it, otherwise create a text node
			if ($lastChild->nodeName === "#text" || $lastChild->nodeType === 5) {
				$lastChild->nodeValue = $lastChild->nodeValue . $AftText;
			} else {
				if ($lastChild) {
					$lastChild->parentNode->appendChild(new DOMText($AftText));
				} else {
					$lastChild->parentNode->lastChild = new DOMText($AftText);
				}
			}		
		}
	}	
	if ($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			if ($item->nodeName != $ignore) {		
				rec_DOM_DivMeLabelWithIgnore($item, $DOM, $ignore, $styles_or_classes);
			}
		}	
	}
	return true;
}

function rec_DOM_GrabCells($node, $ArrayCells) {
	if($node->nodeName === "td" || $node->nodeName === "th") {
		$ArrayCells[] = $node;
	}
	if($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			$ArrayCells = rec_DOM_GrabCells($node, $ArrayCells);
		}	
	}
	return $ArrayCells;
}

function rec_DOM_GrabCellsWithIgnore($node, $column, $ArrayCells, $ignore) {
	if($node) {
	print("child:");var_dump(rec_DOM_getNodeString($child));print("<br>\r\n");
	exit(0);
		if ($node->nodeName === "tr") {
			$found_the_cell_in_this_row = false;
			$number_of_cell = 0;
			$child = $node->firstChild;
			while($child->nodeType !== 1) {
				$child = $child->nextSibling;
			}
			while(!$found_the_cell_in_this_row) {
				if($child->nodeName === "td" || $child->nodeName === "th") {
					$number_of_cell++;
					if($number_of_cell === $column) {
						$ArrayCells[] = $node;
						$found_the_cell_in_this_row = true;
					}
				} else {
					$child = $child->nextSibling;
				}
			}
		}
		if ($node->hasChildNodes()) {
			foreach ($node->childNodes as $item) {
				if ($item->nodeName != $ignore) {
					$ArrayCells = rec_DOM_GrabCellsWithIgnore($node, $column, $ArrayCells, $ignore);
				}
			}	
		}
	}
	return $ArrayCells;
}

function rec_DOM_GrabTDsWithIgnore($node, $ArrayCells, $ignore) {
	if($node->nodeName === "td") {
		$ArrayCells[] = $node;
	}
	if($node->hasChildNodes()) {
		foreach($node->childNodes as $item) {
			if($item->nodeName != $ignore) {
				$ArrayCells = rec_DOM_GrabTDsWithIgnore($node, $ArrayCells, $ignore);
			}
		}	
	}
	return $ArrayCells;
}

function rec_DOM_FindWidth($ArrayCells) {
	// we can assume a 600 pixel wide content area...
	// even easier; we can merely take the first width found (as a first step)
	// without comparing to possible others.
	// this is effectively finding the last width, not necessarily the biggest
	$BiggestWidth = "";
	$BiggestWidthFormat = "";
	foreach($ArrayCells as $index => $cell) {
		if($cell->hasAttributes()) {
			foreach ($node->attributes as $attribute) {
				if ($attribute->nodeName === "style") {
					preg_match_all('/width:([^:;]*);/i', $attribute->nodeValue, $stylewidth);
					foreach($stylewidth[1] as $index => $width) {
						$BiggestWidthFormat = "style";
						$BiggestWidth = $width;
					}
				}
				if ($attribute->nodeName === "class") {
					preg_match_all('/width([0-9]*)/', $attribute->nodeValue, $classwidth);
					foreach($classwidth[1] as $index => $width) {
						$BiggestWidthFormat = "class";
						$BiggestWidth = $width;
					}
				}
				if ($attribute->nodeName === "width") {
					preg_match_all('/width="([^"]*)"/', $attribute->nodeValue, $plainwidth);
					foreach($plainwidth[1] as $index => $width) {
						$BiggestWidthFormat = "width";
						$BiggestWidth = $width;
					}
				}
			}
		}
	}
	$BiggestWidthFormatPlusWidth = $BiggestWidthFormat . ":" . $BiggestWidth;
	return $BiggestWidthFormatPlusWidth;
}

function rec_dom_apply_acronyms($node, $acronymsArray, $allowedAcronymLeftLimiters, $allowedAcronymRightLimiters) {
	if ($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			rec_dom_apply_acronyms($item, $acronymsArray, $allowedAcronymLeftLimiters, $allowedAcronymRightLimiters);
		}	
	} else {
		if ($node->nodeName === "#text") {
			$node->nodeValue = "~" . $node->nodeValue . "~";
			foreach ($acronymsArray as $acronym_tab_definition) {
				if (strlen($acronym_tab_definition) > 0) {
					$tab_position = strpos($acronym_tab_definition, "\t");
					$acronym = substr($acronym_tab_definition, 0, $tab_position);
					$definition = substr($acronym_tab_definition, $tab_position + 1);
					$acronym_pattern = "/" . $allowedAcronymLeftLimiters . $acronym . $allowedAcronymRightLimiters . "/s";
					$node->nodeValue = preg_replace(
					$acronym_pattern, 
					'$1XXX9o9BeginAcronymXXX' . $definition . '9o9XXX' . $acronym . 'XXX9o9EndAcronym9o9XXX$2', 
					$node->nodeValue
					);			
				}
			}
			$node->nodeValue = substr($node->nodeValue, 1, strlen($node->nodeValue)-2);
		}
	}
	return true;
}

function rec_dom_apply_links_with_ignore($node, $ignore) {
	if ($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			if ($item->nodeName !== ($ignore) && $item->nodeName !== "a" && $item->nodeType != 2) {
				rec_dom_apply_links_with_ignore($item, $ignore);
			}
		}	
	} else {
		if ($node->nodeName === "#text") {
			$node->nodeValue = preg_replace(
			'/(([^ :\/<>]*:\/\/){0,1}((www\.[^ <>,]+?\.(ca|com|net|org|edu|biz|gov|int|info|mil))[^ <>,]*))(\.?)/',
			'XXX9o9BeginLinkXXXhttp://${3}9o9XXX$1XXX9o9EndLink9o9XXX$3',
			$node->nodeValue
			);
			$node->nodeValue = preg_replace(
			'/(([^ :\/<>]*:\/\/){1}([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}[^ <>,]*))(\.?)/',
			'XXX9o9BeginLinkXXX${2}${3}9o9XXX$1XXX9o9EndLink9o9XXX$3',
			$node->nodeValue
			);			
			// notice that not all addresses use "www." ...
		}
	}
	return true;
}

function rec_dom_INAC_apply_links_with_ignore($node, $ignore) {
	if ($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			if ($item->nodeName !== ($ignore) && $item->nodeName !== "a" && $item->nodeType != 2) {
				rec_dom_INAC_apply_links_with_ignore($item, $ignore);
			}
		}	
	} else {
		if ($node->nodeName === "#text") {
			$node->nodeValue = preg_replace(
			'/(([^ :\/<>]*:\/\/){0,1}((nwt\-tno\.[^ <>,]+?\.(ca|com|net|org|edu|biz|gov|int|info|mil))[^ <>,]*))(\.?)/',
			'XXX9o9BeginLinkXXXhttp://${3}9o9XXX$1XXX9o9EndLink9o9XXX$3',
			$node->nodeValue
			);
			$node->nodeValue = preg_replace(
			'/(([^ :\/<>]*:\/\/){1}([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}[^ <>,]*))(\.?)/',
			'XXX9o9BeginLinkXXX${2}${3}9o9XXX$1XXX9o9EndLink9o9XXX$3',
			$node->nodeValue
			);			
			// notice that not all addresses use "www." ...
		}
	}
	return true;
}

function rec_dom_apply_email_with_ignore($node, $ignore, $an_email) {
	if ($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			if ($item->nodeName !== ($ignore) && $item->nodeName !== "a" && $item->nodeType != 2) {
				rec_dom_apply_email_with_ignore($item, $ignore, $an_email);
			}
		}	
	} else {
		if ($node->nodeName === "#text") {
			$node->nodeValue = preg_replace(
			'/(' . $an_email . ')/',
			'XXX9o9BeginEmailXXXmailto:${1}9o9XXX$1XXX9o9EndEmail9o9XXX',
			$node->nodeValue
			);
		}
	}
	return true;
}

function rec_DOM_getNodeString($node) {
	// home-brew dom->saveXML
	// whitespace between tags must be accounted for.
	if ($node->hasChildNodes()) {
		if($node->hasAttributes()) {
			$string = "<" . $node->nodeName;
			foreach ($node->attributes as $attribute) {
				$string .= " " . $attribute->nodeName . "=\"" . $attribute->nodeValue . "\"";
			}
			$string .= ">";		
		} else {
			$string .= "<" . $node->nodeName . ">";			
		}
		foreach ($node->childNodes as $item) {
			$string .= rec_DOM_getNodeString($item);
		}	
		$string .= "</" . $node->nodeName . ">";
	} else {
		if($node->hasAttributes()) {
			$string .= "<" . $node->nodeName;
			foreach ($node->attributes as $attribute) {
				$string .= " " . $attribute->nodeName . "=\"" . $attribute->nodeValue . "\"";
			}
			$string .= " />";			
		} else {
			if ($node->nodeName === "#text") {
				$string .= $node->nodeValue;
			} else {
				if ($node->nodeType === 1) {
					$string .= "<" . $node->nodeName . " />";
				} elseif($node->nodeType === 5) {
					$string .= "&" . $node->nodeName . ";";
				} else {
					$string .= "<" . $node->nodeName . ">";				
				}
			}
		}
	}
	return $string;
}

function rec_DOM_getStyleCode($node, $styleCode) {
	if ($node->nodeName === "link") { 
		// then this links to an external stylesheet
		foreach($node->attributes as $attribute) {
			if ($attribute->nodeName === "href") {
				$locationOfFile = substr($attribute->nodeValue, 1);
				$contents = file_get_contents($locationOfFile);
				$styleCode .= "\r\n" . $contents;
			}
		}
	}
	if ($node->nodeName === "style") { 
		// then this could have style information and references to stylesheets
		// using the @import command.
		$child = $node->firstChild;
		$styleCode .= "\r\n" . $child->nodeValue;
	}
	if($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			$styleCode = rec_DOM_getStyleCode($item, $styleCode);
		}
	}
	return $styleCode;
}

function rec_DOM_getEmbeddedStylesheetCode($node, $styleCode) {
	if ($node->nodeName === "style") { // then this could have style information and references to stylesheets
		// using the @import command.
		$ForeText = 'XXX9o9StripMeBegin9o9XXX';
		$AftText = 'XXX9o9StripMeEnd9o9XXX';
		$firstChild = $node->firstChild;
		$lastChild = $node->lastChild;
		
		$styleCode .= "\r\n" . $firstChild->nodeValue;
		
		if($firstChild->nodeName === "#text") {
			$firstChild->nodeValue = $ForeText . $firstChild->nodeValue;
		} else {
			$firstChild->parentNode->insertBefore(new DOMText($ForeText), $firstChild);
		}
		$lastChild->nodeValue = $lastChild->nodeValue . $AftText;
		$node->setAttribute('stripme', 'y');
		ReTidy::DOM_strip_node($node);
	}
	if($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			$styleCode = rec_DOM_getEmbeddedStylesheetCode($item, $styleCode);
		}
	}
	return $styleCode;
}

function getStylesFromCode($code) {
	
	// split the CSS into lines
	preg_match_all('/([^\{\}]*)\s*\{\s*([^\{\}]*)\s*\}/', $code, $matches);
	// remove comments and extra spaces (including line breaks)
	$cleanedSelectors = array();
	$cleanedStyles = array();	
	foreach($matches[1] as $match) {
		$match = preg_replace('/\/\*.*\*\//s', '', $match);
		// this should already be taken care of
		$match = preg_replace('/\r\n/', ' ', $match);
		$match = preg_replace('/\s+/', ' ', $match);
		$match = trim($match);
		$cleanedSelectors[] = $match;
	}
	foreach($matches[2] as $match) {
		$match = preg_replace('/\/\*.*\*\//s', '', $match);
		// this should already be taken care of		
		$match = preg_replace('/\r\n/', ' ', $match);
		$match = preg_replace('/\s+/', ' ', $match);
		$match = trim($match);
		$cleanedStyles[] = $match;		
	}	

	$ArrayOfStyleInformation = array($cleanedSelectors, $cleanedStyles);
	return $ArrayOfStyleInformation;
}

function getStylePropertiesFromInlineStyleCode($code) {
	// remove comments (in the unlikely event that there are any)
	$code = preg_replace('/\/\*.*\*\//s', '', $code);
	preg_match_all('/([^:;]*)\s*:\s*([^:;]*)\s*\;/', $code, $matches);
	$cleanedProperties = array();
	$cleanedPropertyValues = array();	
	// remove extra spaces (including line breaks)	
	foreach($matches[1] as $match) {
		$match = preg_replace('/\r\n/', ' ', $match);
		$match = preg_replace('/\s+/', ' ', $match);
		$match = trim($match);
		$cleanedProperties[] = $match;
	}
	foreach($matches[2] as $match) {
		$match = preg_replace('/\r\n/', ' ', $match);
		$match = preg_replace('/\s+/', ' ', $match);
		$match = trim($match);
		$cleanedPropertyValues[] = $match;		
	}	
	$ArrayOfStyleProperties = array($cleanedProperties, $cleanedPropertyValues);
	return $ArrayOfStyleProperties;
}

function processImportCommands($styleCode) {
	preg_match_all('/@import url\(([^\(\)]*)\);/', $styleCode, $matches);
	$how_many_to_do = sizeof($matches[0]);
	$index = 0;
	while($index < $how_many_to_do) {
		$styleCode = str_replace($matches[0][$index], file_get_contents(substr($matches[1][$index], 1)), $styleCode);
		$index++;
	}
	return $styleCode;
}

function removeImportCommands($styleCode) {
	$styleCode = preg_replace('/@import url\(([^\(\)]*)\);/', '', $styleCode);
	return $styleCode;
}

function replaceMultipleSelectors($styleCode) {
	$count = -1;
	while($count !== 0) {
		$styleCode = preg_replace('/([^\{\},]*),\s*([^\{\}]*)\s*\{\s*([^\{\}]*)\s*\}/is', '$1 { $3 }
$2 { $3 }', $styleCode, -1, $count);
	}
	return $styleCode;
}

function EliminateEmptyArrayEntries($input) {
	if(is_string($input)) {
		return (strlen($input) > 0);
	} else {
		return true;
	}
}

function rec_EliminateEmptyArrayEntries($input) {
	if(is_array($input)) {
		return array_filter($input, "rec_EliminateEmptyArrayEntries");
	}
	return (strlen($input) > 0);
}

function EliminateFalseArrays($input) {
	//print("input: ");var_dump($input);print("<br>\r\n");
	if(is_array($input)) {
		foreach($input as $index => $value) {
			if($value) {
				return true;
			}
		}
	} else {
		return true;
	}
	return false;
}

function rec_DOM_getText($node, $ArrayTextStrings) {
	if ($node->hasChildNodes()) {
		foreach ($node->childNodes as $item) {
			$ArrayTextStrings = rec_DOM_getText($item, $ArrayTextStrings);
		}
	}			
	if ($node->nodeName === "#text") {
		$ArrayTextStrings[] = $node->nodeValue;
	}
	return $ArrayTextStrings;
}

function rec_layout_tables($input) {
	// Not useful since it does not use document object model!
	$c = $ct = $cnt = 0;
	//preg_match_all('/<table[^>]*width="600"[^>]*>.*?<\/table>/is', $this->code, $tables);
	preg_match_all('/<table[^>]*>.*?<\/table>/is', $input, $tables);
	if(preg_match_all('/<table[^>]*>.*?<\/table>/is', $tables, $tables_for_rec)) {
		foreach($tables_for_rec[0] as $index => $subtable) {
			$subtable = rec_layout_tables ($subtable);
		}
	}		
	foreach($tables[0] as $index => $table) {
		if (preg_match('/<table[^>]*summary="[^"]*"[^>]*>/is', $table) || 
		preg_match('/<p[^>]*>(<strong>|).*?Table(au|) [0-9]{1,3}( |):.+?(<\/strong>|)<\/p>\s*<table[^>]*>/is', $table) ||
		preg_match('/<p[^>]*>(<strong>|).*?<a name="tab.+?(<\/strong>|)<\/p>\s*<table[^>]*>/is', $table) ||
		preg_match('/<p[^>]*>(<strong>|).*?<a id="tab.+?(<\/strong>|)<\/p>\s*<table[^>]*>/is', $table)) {
			continue;
		}
		$initial_table = $table;
		/*
		$biggest_width_for_table = "0";
		$width_type1 = "";
		preg_match_all('/<tr[^>]>.*?<\/tr>/is', $table, $trs);
		foreach($trs[0] as $index => $tr) {
			preg_match_all('/<(td|th)[^>]*( width="([^"]*)")[^>]*>/is', $tr, $cell_widths1);
			preg_match_all('/<(td|th)[^>]*( style="width:([^;]*);")[^>]*>/is', $tr, $cell_widths2);
			$biggest_width1 = "0";
			$width_type1 = "";
			$biggest_width2 = "0";
			$width_type2 = "";				
			foreach($cell_widths1[3] as $index => $cell_width) {
				preg_match('/([0-9]*)([^0-9]*)/is', $cell_width, $width_match);
				$width_type1 = $width_match[2];
				if ($width_match[1] > $biggest_width1) {
					$biggest_width1 = $width_match[1];
				}
			}
			foreach($cell_widths2[3] as $index => $cell_width) {
				preg_match('/([0-9]*)([^0-9]*)/is', $cell_width, $width_match);
				$width_type2 = $width_match[2];
				if ($width_match[1] > $biggest_width2) {
					$biggest_width2 = $width_match[1];
				}
			}
			if ($biggest_width1 != 0) {
				if ($width_type1 == "") {
					$width_type1 = "px";
				}
				$biggest_width_for_tr = $biggest_width1;
			} else {
				if ($width_type2 == "") {
					$width_type2 = "px";
				}
				$biggest_width_for_tr = $biggest_width2;
			}
			
			$biggest_width_for_tr			
		}
		*/
		foreach($this->config['layout_tables'] as $search => $replace) {
			$table = preg_replace("/" . $search . "/is", $replace, $table, -1, $c);
			//$this->logMsgIf("layout_tables[" . htmlentities($search) . "]", $c);
			//$ct += $c;
		}
		
		preg_match('/<div style="width:100%;">\s*<div[^>]* style="clear:both;">\s*<div([^>]*) style="float:left;[^"]*">/is', $table, $first_cell_attributes);

		if (preg_match('/width:([^;]*);/is', $first_cell_attributes[1], $first_cell_width)){
			$table = preg_replace(
			'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)">/is', 
			'<div$1 style="clear:both;">$2<div$3 style="float:left;$4width:' . $first_cell_width[1] . ';">', 
			$table);
		}
		
		if(preg_match('/class="[^"]*(width[0-9]{1,3})[^"]*"/is', $first_cell_attributes[1], $first_cell_width)) {
			$table = preg_replace(
			'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)">/is', 
			'<div$1 style="clear:both;">$2<div$3 style="float:left;$4" class="' . $first_cell_width[1] . '">', 
			$table);
		}
		
		preg_match('/<div style="width:100%;">\s*<div[^>]* style="clear:both;">\s*<div[^>]* style="float:left;[^"]*"[^>]*>.*?<\/div>\s*<div([^>]*) style="float:left;[^"]*">/is', $table, $second_cell_attributes);						
		/*
		if (preg_match('/width:([^;]*);/is', $second_cell_attributes[1], $second_cell_width)){
			$table = preg_replace(
			'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)">(.*?)<\/div>(\s*)<div([^>]*) style="float:left;([^"]*)">/is', 
			'<div$1 style="clear:both;">$2<div$3 style="float:left;$4">$5<\/div>$6<div$7 style="float:left;$8' . $second_cell_width[1] . ';">', 
			$table);
		}			
		
		if(preg_match('/class="[^"]*(width[0-9]{1,3})[^"]*"/is', $second_cell_attributes[1], $second_cell_width)) {
			$table = preg_replace(
			'/<div([^>]*) style="clear:both;">(\s*)<div([^>]*) style="float:left;([^"]*)"([^>]*)>(.*?)<\/div>(\s*)<div([^>]*) style="float:left;([^"]*)">/is', 
			'<div$1 style="clear:both;">$2<div$3 style="float:left;$4"$5>$6<\/div>$7<div$8 style="float:left;$9" class="' . $second_cell_width[1] . '">', 
			$table);
		}			
		*/
		$this->code = str_replace($initial_table, $table, $this->code, $ct);
		$cnt += $ct;
	}
	$this->logMsgIf("layout_tables", $cnt);
	return $output;
}

function giveAttributesToParentWithoutOverwrite($node) {
	$parentNode = $node->parentNode;
	applyAttributesWithoutOverwrite($node, $parentNode);
	return true;
}

function applyAttributesWithoutOverwrite($node_with_attributes, $node_to_apply_attributes_to) {
	print("this extra-classal applyAttributesWithoutOverwrite should not be used");exit(0);
}

function applyAttributeWithoutOverwrite($attribute_to_apply, $node_to_apply_attributes_to) {
	print("this extra-classal applyAttributeWithoutOverwrite should not be used");exit(0);
}

function searchForData($table) {
	$data_table = false;
	$this_is_a_small_table = false;
	// this method looks in the four cells defined by the last two rows and columns
	$numberOfChildren = 0;
	$numberOfChildren2 = 0;	
	
	foreach($table->childNodes as $childNode) {
		if ($childNode->nodeName === "tr") {
			$numberOfChildren++;
		}
	}/*
	if ($numberOfChildren >= 4) {
		foreach($table->childNodes as $childNode) {
			if ($childNode->nodeName === "tr") {
				$numberOfChildren2++;
				if($numberOfChildren-2 === $numberOfChildren2) {
					$third_last_tr = $childNode;
				}
				if($numberOfChildren-1 === $numberOfChildren2) {
					$second_last_tr = $childNode;
				}
			}
		}
		// notice that cells can span multiple columns and there would thus be fewer <td>s in a <tr>
		// we could account for this by looking for colspan attributes...but then how do we know which 
		// cells are the four cells defined by the last two rows and columns...
		$number_of_cells_in_third_last_tr = 0;
		$number_of_cells_in_second_last_tr = 0;	
		$number_of_cells_in_third_last_tr2 = 0;
		$number_of_cells_in_second_last_tr2 = 0;	
		foreach($third_last_tr->childNodes as $childNode) {
			if ($childNode->nodeName === "th" || $childNode->nodeName === "td") {
				$number_of_cells_in_third_last_tr++;
				if ($childNode->hasAttributes()) {
					foreach($childNode->attributes as $attribute) {
						if($attribute->nodeName === "colspan") {
							$number_of_cells_in_third_last_tr += ($attribute->nodeValue-1);
						}
					}
				}				
			}
		}	
		foreach($second_last_tr->childNodes as $childNode) {
			if ($childNode->nodeName === "th" || $childNode->nodeName === "td") {
				$number_of_cells_in_second_last_tr++;
				if ($childNode->hasAttributes()) {
					foreach($childNode->attributes as $attribute) {
						if($attribute->nodeName === "colspan") {
							$number_of_cells_in_second_last_tr += ($attribute->nodeValue-1);
						}
					}
				}
			}
		}
		// the cells could be missed due to spanning cells. to deal with this we could make it so that the first time 
		// the number of the cell we are on is reached or exceeded, then handle that cell; instead of anytime the 
		// number of the cell we are on is reached (which could be missed):
		$found_third_last_cell_one = false;
		$found_second_last_cell_one = false;		
		$found_third_last_cell_two = false;
		$found_second_last_cell_two = false;		
		if ($number_of_cells_in_third_last_tr >= 4) {
			foreach($number_of_cells_in_third_last_tr->childNodes as $childNode) {
				if ($childNode->nodeName === "th" || $childNode->nodeName === "td") {
					$number_of_cells_in_third_last_tr2++;
					if ($childNode->hasAttributes()) {
						foreach($childNode->attributes as $attribute) {
							if($attribute->nodeName === "colspan") {
								$number_of_cells_in_third_last_tr2 += ($attribute->nodeValue-1);
							}
						}
					}						
					if($number_of_cells_in_third_last_tr-2 >= $number_of_cells_in_third_last_tr2 && !$found_third_last_cell_one) {
						$third_last_cell_one = $childNode;
						$found_third_last_cell_one = true;
					}
					if($number_of_cells_in_third_last_tr-1 >= $number_of_cells_in_third_last_tr2 && !$found_second_last_cell_one) {
						$second_last_cell_one = $childNode;
						$found_second_last_cell_one = true;
					}
				}
			}
		} else {
			$this_is_a_small_table = true;
		}
		if ($number_of_cells_in_second_last_tr >= 4) {
			foreach($number_of_cells_in_second_last_tr->childNodes as $childNode) {
				if ($childNode->nodeName === "th" || $childNode->nodeName === "td") {
					$number_of_cells_in_second_last_tr2++;
					if ($childNode->hasAttributes()) {
						foreach($childNode->attributes as $attribute) {
							if($attribute->nodeName === "colspan") {
								$number_of_cells_in_second_last_tr2 += ($attribute->nodeValue-1);
							}
						}
					}						
					if($number_of_cells_in_second_last_tr-2 >= $number_of_cells_in_second_last_tr2 && !$found_third_last_cell_two) {
						$third_last_cell_two = $childNode;
						$found_third_last_cell_two = true;
					}
					if($number_of_cells_in_second_last_tr-1 >= $number_of_cells_in_second_last_tr2 && !$found_second_last_cell_two) {
						$second_last_cell_two = $childNode;
						$found_second_last_cell_two = true;
					}
				}
			}		
		} else {
			$this_is_a_small_table = true;
		}		
	} else {
		$this_is_a_small_table = true;
	}*/
	if(!$this_is_a_small_table) {
		// we now have the cells; lets look at them.
		$array_of_four_cells = array(
		$third_last_cell_one,
		$second_last_cell_one,
		$third_last_cell_two,
		$second_last_cell_two,
		);
		$number_count = 0;
		$dollar_amount_count = 0;
		$word_count = 0;
		$other_count = 0;
		foreach($array_of_four_cells as $cell) {
			if(!$cell) {
				print("cell not properly found!<br>");
				break;
			}
			//var_dump($cell);exit(0);
			$possibleDataType = rec_DOM_lookForData($cell);
			if ($possibleDataType === "number") {
				$number_count++;
			} else if ($possibleDataType === "dollar amount") {
				$dollar_amount_count++;
			} elseif ($possibleDataType === "word") {
				$word_count++;
			} else {
				$other_count++;
			}
		}
		if (
		$number_count === 3 ||
		$dollar_amount_count === 3 ||
		$word_count === 3 ||
		($number_count === 2 && $dollar_amount_count === 2) ||
		($number_count === 2 && $word_count === 2) ||
		($dollar_amount_count=== 2 && $word_count === 2)		
		) {
			$data_table = true;
		}
	}	
	// this method looks in tables with less than 4 rows or 4 columns
	if($this_is_a_small_table) {
		// I suppose we could look at all the <td>s...
		$ArrayTDs = array();
		$ArrayTDs = rec_DOM_GrabTDsWithIgnore($table, $ArrayTDs, "table");

		$number_count = 0;
		$dollar_amount_count = 0;
		$word_count = 0;
		$other_count = 0;
		$number_of_cells = sizeof($ArrayTDs);
		foreach($ArrayTDs as $cell) {
			$possibleDataType = rec_DOM_lookForData($cell);
			if ($possibleDataType === "number") {
				$number_count++;
			} else if ($possibleDataType === "dollar amount") {
				$dollar_amount_count++;
			} elseif ($possibleDataType === "word") {
				$word_count++;
			} else {
				$other_count++;
			}					
		}
		if (
		$number_count === (0.5*$number_of_cells) ||
		$dollar_amount_count === (0.5*$number_of_cells) ||
		$word_count === (0.5*$number_of_cells)	
		) {
			$data_table = true;
		}
	}
	//print(rec_DOM_getNodeString($first_tr));
	return $data_table;
}

function rec_DOM_lookForData($cell) {
	$possibleDataType = "";
	foreach ($cell->childNodes as $child) {
		if($child->nodeType = 3) {
			// look for data in this text node
			preg_match_all('/(\$( |&nbsp;)*([0-9,. ]|&nbsp;){1,}|([0-9,. ]|&nbsp;){1,}\( |&nbsp;)*$)/', $child->nodeValue, $dollar_amounts);
			preg_match_all('/[0-9]*/', $child->nodeValue, $all_numbers);
			preg_match_all('/[\w]*/', $child->nodevalue, $one_word);
			if (sizeof($all_numbers[0]) === 1 && strlen($all_numbers[0][0]) === strlen(trim($child->nodeValue))) {
				$possibleDataType = "number";
				break;
			}
			if (sizeof($dollar_amounts[1]) === 1 && strlen($dollar_amounts[1][0]) === strlen(trim($child->nodeValue))) {
				$possibleDataType = "dollar amount";
				break;
			}
			if (sizeof($one_word[0]) === 1 && strlen($one_word[0][0]) === strlen(trim($child->nodeValue))) {
				$possibleDataType = "word";
				break;
			}			
		}
		if ($child->hasChildNodes) {
			$possibleDataType = rec_DOM_lookForData($child);
		}
	}
	return $possibleDataType;
}

function str_replaceFirst($search, $replace, $str) {
	$length = strlen($str);
	$a = strpos($str, $search);
	$b = $a + strlen($search);
	$temp = substr($str, 0, $a) . $replace . substr($str, $b, ($length-$b));
	return $temp;
}

function emptyDefinitions($input) {
	return ($input != "definition");
}

function sortByLength($a, $b){
	if($a == $b) return 0;
	return (strlen($a) > strlen($b) ? -1 : 1);
}
function sortByLengthOfFirst($a, $b){
	if($a == $b) return 0;
	if(!is_array($a) || !is_array($b)) return 0;
	return (strlen($a[0]) > strlen($b[0]) ? -1 : 1);
}
function sortByLengthOfIndex($a, $b){
	if($a == $b) return 0;
	if(!is_array($a) || !is_array($b)) return 0;	
	return (strlen(key($a[0])) > strlen(key($b[0])) ? -1 : 1);
}
function sortByNumberOfSecond($a, $b){
	if($a == $b) return 0;
	if(!is_array($a) || !is_array($b)) return 0;
	return ($a[1] < $b[1] ? -1 : 1);
}
function sortAlphabetically($a, $b) {
	return ($a > $b) ? 1 : (($a < $b) ? -1 : 0);
}
?>
